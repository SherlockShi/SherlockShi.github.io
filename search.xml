<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JRebel for Android 破解方法]]></title>
    <url>%2FJRebelForAndroid-crack-method.html</url>
    <content type="text"><![CDATA[Android Studio 的龟速编译是大家有目共睹的，在长期的开发实践过程中，博主体验了 Instant Run、Freeline、JRebel for Android，以及一大堆加速编译的方法。 最终发现，只有 JRebel for Android 才是目前 Android Studio 上最好用、最方便的加速编译工具，没有之一。 初次使用可参考博主之前的文章 Android Studio 加速编译方法汇总。 而在试用 21 天之后，JRebel for Android 就过期了，只能付费使用。而对于像博主一样囊中羞涩的人来说，以下的破解方法会让你省下几十美刀的花费。 1. 下载破解包在下述网站评论中，找到博主 ilanyu 发的最新破解包： http://blog.lanyus.com/archives/179.html#comments 如目前最新版为 2.1.14，下载地址为： https://mega.nz/#!i9Q3iLiZ!6zr47HM8PDv86zeJO7jWLaFpB_6D32AI3oRzfhGJNfs 2. 安装下载下来的 zip 不要解压，打开 Android Studio 的插件设置，选择从磁盘安装，如下图：（安装后，记得重启 Android Studio） 3. 导入 licence运行项目时，如提示 JRebel 过期，则将第 1 步压缩包中的 jrebel-android.lic 文件解压出来，并按 Android Studio 提示导入此 lic 文件。 尽情享受 JRebel 带来的极速体验吧～ 4. 参考资料JRebel for Android 破解/注册 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JRebel for Android</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 单元测试初探【译】]]></title>
    <url>%2Fsimple-unit-tests-for-android.html</url>
    <content type="text"><![CDATA[本文翻译自 Simple unit tests for Android，如能力允许，建议点击原文阅读。 如何测试 Android App 逻辑，是时候向大家分享这个主题了。长久以来，我都没意识到它是 Android App 开发中的一个重要组成部分。但是，学习永远不嫌晚，无论是你，亦或是我 :) 概述首先，让我们来了解一下单元测试是什么？以及为什么我们需要编写单元测试。 以下是维基百科关于单元测试的定义： Unit testing is a software testing method used for testing individual units of source code in order to determine whether they are fit for use. The idea is to write code for each non-trivial function or method. It allows you to relatively quickly check if the latest change in code causes regression, i. e. new errors appear in the part of the program that was already tested, and makes it easy to identify and eliminate such errors. 译文： 单元测试是一种软件测试方法，用于测试独立的源代码单元，来确定这些代码是否满足需求。这种思想是为每个重要的功能或方法写一段测试代码。它使得你能相对快速地检查出最新的代码改动是否导致了回归（regression）。例如，新的错误出现在已经测试过的程序中，并且会使得发现和解决这些错误变得更加容易。 简单地说，单元测试就是检验你的代码效率的一系列方法。但是它是怎么工作的呢？就让我们从头开始说起吧。如果没有错误发生的话，测试就认为是完成了的。而且对于各种各样的检验来说，我们使用类似于 assertXXX “家族”这样的补充方法来进行测试。（详情请看下面的示例） Android 有 2 种单元测试方法： Local unit tests：这是只用 JVM 来执行的测试，主要是用来测试不与操作系统交互的业务逻辑。 Instrumented unit tests：这是用于测试与 Android API 互联的逻辑。它们是在物理设备或者模拟器上执行的，所以会比 Local unit texts 花费更多时间。 那么我们就有 2 种测试方法了，至于哪一种方法就基于我们要测试的逻辑目标。当然，如果可能的话，最好是写本地测试。 此外，在创建测试时，请注意包目录结构，以下这样的结构是很实用的： app/src/main/java：app 源代码 app/src/test/java：local tests 测试代码 app/src/androidTest/java：instrumented tests 测试代码 配置Android Studio 在创建项目的时候，会自动生成上述的目录结构，而如果因为某些原因，你没有使用 Android Studio 来构建项目，那么你就要记住上述的目录结构，并自己创建了。 此外，在 AS 中配置 app module 的build.gradle文件：（ Android Studio 创建项目时已自动添加） 12345678910111213android &#123; ... defaultConfig &#123; ... testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; ...&#125;dependencies &#123; ... testCompile 'junit:junit:4.12'&#125; 另外还有个流行框架，它可以让我们写测试流程更加容易，那就是 Mockito 框架。它的特性包括创建模拟对象（译者注：后文直接称 mock 对象）、跟踪对象，并且也有进行结果验证的辅助工具。要使用它的话，只需要加上一行依赖： 1testCompile 'org.mockito:mockito-core:1.10.19' Local tests in Android现在让我们来看 2 个非常简单的单元测试例子，它们用来验证 2 个对象是否一致（在我们的例子中是两个数值对象）： 123456789101112public class ExampleUnitTest &#123; @Test public void addition_correct() throws Exception &#123; assertEquals(4, 2 + 2); &#125; @Test public void addition_isNotCorrect() throws Exception &#123; assertEquals("Numbers isn't equals!", 5, 2 + 2); &#125;&#125; 在 local test 包（即 app/src/test/java/packageName 包）下面新建一个类，然后放入我们的测试方法。为了让 JUnit 知道这些方法是测试方法，我们需要给他们添加 @Test 注解标记。如果第 1 个参数（期望值）和第 2 个参数（结果值）不一致的时候，assertEquals() 方法会显示 AssertionError 错误。 我们来运行测试方法（右击类名，在弹出的菜单中选择 Run ‘ExampleUnitTest’），并查看输出结果： 从上图可以看到，第一个方法正确执行了，但是第二个方法由于 5 != (2 + 2) 所以会有报错信息。 你也可以使用 expected 参数来配置一个预期的异常（ expected Exception ）： 12345@Test(expected = NullPointerException.class)public void nullStringTest() &#123; String str = null; assertTrue(str.isEmpty());&#125; 在这个例子中，因为我们预期的就是这个异常（NullPointerException），所以测试将被执行。 你也可以为耗时操作指定 timeout 参数，并以毫秒为单位定义该值。如果方法没有在指定时间内执行完，将会被判定为失败。 1234@Test(timeout = 1000)public void requestTest() &#123; …&#125; 另外还有一个非常有趣的 Matchers 机制。比如说，assertThat(T actual, Matcher&lt;? super T&gt; matcher) 接收它们做为输入。它们由 org.hamcrest.CoreMatchers 类中的方法返回，属于重叠逻辑操作。下面我们来看几个例子： 123assertThat(x, is(3));assertThat(x, is(not(4)));assertThat(list, hasItem("3")); 正如它们的名字所暗示的，is() 可以描述为 “等于”，is(not()) 就是 “不等于”，而 hasItem() 就是检验某些元素是不是在 list 中。并且它们都可以用一个连续的句子读出来。在这里你可以找到一个完整的 matchers 列表（list of matchers）。 目前为止，我们已经看到了一些简单的例子，可以用来编写简单的测试。但接下来，我还会带大家来看看 Mockito 库，它可以让我们的测试变得更优秀。 正如前面介绍过的，Mockito 用于创建所谓的 mock 对象（mock objects）。这些对象的目的是代替那些没办法测试、或者不适合测试的复杂对象。有两个方法可以声明 mock 对象： 1List mockedList = mock(List.class); 或者： 12@MockList mockedList; 记住，要使用 @Mock 注解的话，你必须使用 @RunWith(MockitoJUnitRunner.class) 注解来标记你所定义的类，或者在 @Before 方法中调用 MockitoAnnotations.initMocks(this); 1234@Beforepublic void init() &#123; MockitoAnnotations.initMocks(this);&#125; 创建完 mock 对象后，你就可以见证奇迹了！比如说，要从字符串资源文件中重写 app name 的话，你就可以这样做： 12when(mockContext.getString(R.string.app_name)) .thenReturn("Fake name"); 现在，当我们调用 getString(R.string.app_name) 方法的时候，将会返回 “Fake name”，即使它并没有被隐式地调用： 12SomeClass obj = new SomeClass(mockContext);String result = obj.getAppName(); 译者注： 123456789101112public class SomeClass &#123; private Context mContext; public SomeClass(Context context) &#123; this.mContext = context; &#125; public String getAppName() &#123; return mContext.getString(R.string.app_name); &#125;&#125; 但是如果我们要重写所有的字符串资源呢？不可能让我们给每一个字符串都做一次这样的操作吧！当然不会，肯定有别的办法，那就是 anyXXX(), anyInt(), anyString() 等等这些方法。现在，如果你把 R.string.app_name 替换为 anyInt()（不要忘了，在 Android 里面所有的资源都是 Integer 类型的），那么所有的字符串都会被替换为我们定义的字符串。这时候，我们就可以在测试的最后，使用 assertThat() 来检验结果是否正确： 1assertThat(result, is("Fake name")); 如果要移除 Exception 的话，我们可以使用 when(...).thenThrow(...);。还有一个 verify() 方法，如果在它之前没调用指定的方法，测试就会失败。我们来看下代码： 12345mockedList.add("Useless string");mockedList.clear();verify(mockedList).add("one");verify(mockedList).clear(); 它的工作原理是这样的：我们传递 mock 的 list 给 verify(mockedList) 方法，然后指定我们关注的方法。在这个例子中，我们的指定方法是 添加 string 和 清除 list。我相信，这是一个很重要的工具！ :) 但是，当你使用 spy 对象的时候，这个方法（verify 方法）的所有潜能将会展现出来。它们的主要区别在于，跟 mocks 不一样的是，它们并不直接被创建出来。你可能会问：“那到底关键点是什么呢？” 关键在于，通过创建一个 “spy” 对象，你可以像观察一个假对象一样观察它： 1234567List spyList = spy(new LinkedList());spyList.add("one");spyList.clear();verify(spyList).add("one");verify(spyList).clear(); Instrumented tests in Android使用这种类型的测试，我们可以获取到真正的 context，以及所有的 Android API 功能。除此之外，还有一个 “上帝模式”，我们可以用来管理 activity 的生命周期。为了让测试被识别为 instrumented 测试，需要使用相应的注解来标记类： 1234@RunWith(AndroidJUnit4.class)public class ExampleInstrumentedTest &#123; ...&#125; 而测试方法本身还是像 local tests 一样来标记，使用 @Test 注解。我们来看看，context 的包是否对应于我们的 app: 12345@Testpublic void useAppContext() throws Exception &#123; Context appContext = InstrumentationRegistry.getTargetContext(); assertEquals("com.stfalcon.demoapp", appContext.getPackageName());&#125; 使用下面的方法，你可以监听 Activity 的状态： 123456ActivityLifecycleMonitorRegistry.getInstance().addLifecycleCallback(new ActivityLifecycleCallback() &#123; @Override public void onActivityLifecycleChanged(Activity activity, Stage stage) &#123; //do some stuff &#125;&#125;); 甚至可以管理它们的状态： 12Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();instrumentation.callActivityOnCreate(activity, bundle); 总结这些可能是我在熟悉这个主题时发现的最重要的东西。不要朝我扔石头 :) 但我觉得对于初学者来说，这些已经足够入门了。如果你想深入了解 JUnit 的功能，建议你阅读 JUnit 官方文档，另外还有 instrumented test 的功能。 参考资料Getting Started with TestingJUnit4 官方 WikiJUnit 入门教程（极客学院 Wiki）邹小创的 Android 单元测试系列 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 下 SVN 无法上传 .so 文件问题]]></title>
    <url>%2FMacOS-SVN-cant-upload-so-file.html</url>
    <content type="text"><![CDATA[1. 前言最近在使用 Cornerstone 上传文件时，发现 .so 文件无法上传，搜了一下，发现 MacOS 下的 SVN 忽略文件的全局配置是在这个文件：~/.subversion/config： 1vi ~/.subversion/config 2. 修改全局配置找到 [miscellany] 项中的 global-ignores 配置(可能为一行或两行)： 12# global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo# *.rej *~ #*# .#* .*.swp .DS_Store 去掉行首的注释，并将 .so 文件相关的内容删除（*.so 和 *.so.[0-9]*），最后的文件内容如下(如果需要配置其它类型文件，请自行修改)： 1global-ignores = *.o *.lo *.la *.al .libs *.a *.pyc *.pyo *.rej *~ #*# .#* .*.swp .DS_Store 3. 修改 SVN 工具配置如果你像我一样，使用 SVN 工具来进行提交的话，需要再次查看相关工具的 Subversion 配置，此处以 CornerStone 为例： 如果其配置还是忽略 .so 文件，可参考如下配置： 取消勾选 Use default global ignores 删除其中 .so 文件相关的内容 以上，即可正常上传 .so 文件。 如果你使用的是 Android Studio 或 Xcode 等集成开发环境，默认是使用系统全局配置，不需要另外修改。 4. 参考资料SVN：MAC SVN Android studio 不能提交 .so 文件Android Studio With SVN PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>so</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 复制 TextView 内容常用方法汇总]]></title>
    <url>%2FAndroid-copy-TextView-content-methods_summary.html</url>
    <content type="text"><![CDATA[一、前言最近在项目中，需要提供 TextView 的复制功能，让用户可以自由复制 App 中某些界面的特定内容。 需求来源于用户有时需要复制编号，用于其它地方的搜索，比如下图中 TD 开头的这一长串编号。 如果在搜索时，需要手输这一长串字符，先不说记住这一串数据需要怎样的记忆力，就说输入这一长串字符的时间，对于用户来说就是不可接受的。 二、需求分析这时候，我们很自然地就会想到，我们经常使用的复制功能，是类似这样的： 长按某一段文字后，在文字上方或标题栏处会出现 全选、复制 等功能按钮，点击后就能复制，然后在你需要输入的地方长按，就会出现 粘贴 按钮，点击后就能成功粘贴。 三、功能实现查看 TextView 的 API，里面就有这么一段介绍： To allow users to copy some or all of the TextView’s value and paste it somewhere else, set the XML attribute android:textIsSelectable to “true“ or call setTextIsSelectable(true). The textIsSelectable flag allows users to make selection gestures in the TextView, which in turn triggers the system’s built-in copy/paste controls. 意思就是使用 textIsSelectable 属性就可以触发系统内置的复制/粘贴功能。 那么最简单的方法就是直接在XML文件中，给 TextView 设置 textIsSelectable 属性为 true： 12345&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="TD201612120166" android:textIsSelectable="true" /&gt; 当然，也可以使用 java 代码实现： 1tv.setTextIsSelectable(true); 效果也确实立杆见影，一步完成。 好嗨森，可以收工啦，赶紧把项目中另一个地方也改掉，就可以提交代码啦～ 四、掉坑了由于本项目为老项目，列表使用的是 ListView（SDK 使用的是 19），而另一个需要修改的地方，就是 ListView 列表里面的子项 TextView。 当为其设置 textIsSelectable 属性后，长按这一长串数字编号，这时候数字是选中了，但是并没有弹出 复制 的选项啊，而且更重要的是，ListView 的 Item 点击事件没有了啊啊啊～～～ 注：在某些 SDK 版本上，长按 TextView 后，会在 ToolBar(ActionBar) 位置弹出全选、复制 等功能按钮（如下图），而当设置 textIsSelectable 属性后，该功能条会下滑出现，而在一瞬间又上滑消失，实际看到的效果就是 ToolBar 处会有内容闪现并瞬间消失，但是看不清具体内容。 五、解决网上搜索一番，果然也有不少解决方案，但有一些亲测无效，就不列出了，以下是亲测可用的解决方案。 以下方法，基本都是使用系统的剪贴板管理器 ClipboardManager 进行内容的复制。 1. LongClick 事件 + PopupWindow原理是在 TextView 的长按事件中，显示一个带操作按钮的 PopupWindow，点击其中的 复制 按钮后，复制 TextView 内容。 先初始化 PopupWindow，弹出窗口上会有复制按钮（也可以自定义其它需要的按钮）： 12345678910private void initPopupWindow() &#123; View popupView = getLayoutInflater().inflate(R.layout.layout_popup_window, null); mPopupWindow = new PopupWindow(popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true); mPopupWindow.setTouchable(true); mPopupWindow.setOutsideTouchable(true); mPopupWindow.setBackgroundDrawable(new BitmapDrawable(getResources(), (Bitmap) null)); Button btnCopy = (Button) popupView.findViewById(R.id.btn_copy);&#125; 然后为 ListView 中的 TextView 设置长按事件，在 TextView 下方显示 PopupWindow： 1234567891011mTextView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View view) &#123; // 方法1：LongClick 事件 + PopupWindow mPopupWindow.showAsDropDown(view); mCopiedText = ((TextView) view).getText().toString(); return false; &#125;&#125;); 最后为弹出窗口中的复制按钮设置响应事件，利用 ClipboardManager 复制 TextView 内容： 1234567891011121314151617btnCopy.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; copyText(mCopiedText); if (mPopupWindow != null &amp;&amp; mPopupWindow.isShowing()) &#123; mPopupWindow.dismiss(); &#125; &#125;&#125;);private void copyText(String copiedText) &#123; ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE); clipboardManager.setPrimaryClip(ClipData.newPlainText(null, copiedText)); showToast("Copy Text: " + copiedText);&#125; 以上就可以在你需要输入的地方长按，就会出现 粘贴 按钮，点击后就能成功粘贴刚才复制的内容了。 但是这边会有个问题：无法自由选择文字内容，没有选中文字的效果 2. LongClick 事件 + ContextMenu我们也可以使用 ContextMenu 来手动创建上下文菜单，实现跟原生复制功能一样的效果，在标题栏上方显示可操作的菜单，最终效果如下： 首先，实现 ActionMode.Callback 接口。这里面会包含 ActionMode 的生命周期方法，在 onCreateActionMode() 中 创建菜单 项，如复制、全选等功能菜单，在 onActionItemClicked() 中处理菜单项的 点击事件。（重点代码用下三角 ▼▼▼ 标识了） 这两个方法就类似标题栏右边的选项菜单 OptionsMenu，对应于 onCreateOptionsMenu() 和 onOptionsItemSelected() 这两个方法。 12345678910111213141516171819202122232425262728private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() &#123; // Called when the action mode is created; startActionMode() was called @Override public boolean onCreateActionMode(ActionMode mode, Menu menu) &#123; // Inflate a menu resource providing context menu items MenuInflater inflater = mode.getMenuInflater(); // ▼▼▼ 重点：创建上下文菜单 inflater.inflate(R.menu.context_menu, menu); return true; &#125; // Called each time the action mode is shown. Always called after onCreateActionMode, but // may be called multiple times if the mode is invalidated. @Override public boolean onPrepareActionMode(ActionMode mode, Menu menu) &#123; return false; // Return false if nothing is done &#125; ... // Called when the user exits the action mode @Override public void onDestroyActionMode(ActionMode mode) &#123; mActionMode = null; &#125;&#125;; 然后，为 TextView 设置长按事件，显示上下文菜单： 123456789101112131415mTextView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View view) &#123; // 方案2：LongClick 事件 + ContextMenu if (mActionMode != null) &#123; return false; &#125; // Start the CAB using the ActionMode.Callback defined above mActionMode = startActionMode(mActionModeCallback); view.setSelected(true); mCopiedText = ((TextView) view).getText().toString(); return true; &#125;&#125;); 最后，就是在第一步的 onActionItemClicked() 事件中，为 复制 按钮设置响应事件，利用 ClipboardManager 复制 TextView 内容： 12345678910111213141516private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() &#123; ... public boolean onActionItemClicked(ActionMode mode, MenuItem item) &#123; switch (item.getItemId()) &#123; // ▼▼▼ 重点：设置菜单项的点击事件 case R.id.action_copy: copyText(mCopiedText); mode.finish(); // Action picked, so close the CAB return true; default: return false; &#125; &#125;&#125;; 这边同样会有上面的问题：无法自由选择文字内容，没有选中文字的效果 3. Click 事件 + ClipboardManager此方案跟第 1 种原理是一样的，只不过省略了 PopupWindow 部分，点击后直接自动复制 TextView 内容，代码比较简单： 123456mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; copyText(((TextView) view).getText().toString()); &#125;&#125;); 问题：无法自由选择文字内容 4. RecyclerView + textIsSelectable其实最推荐的做法，还是将项目里的 ListView 替换成 RecyclerView，再给 TextView 设置 textIsSelectable=true属性即可： 这让我们再一次见证了 RecyclerView 的伟大啊～本方案对项目后期维护及扩展更有好处，毕竟现在基本可以说，RecyclerView 已经完全取代了 ListView，比 ListView 性能更好，扩展性更强。 5. 额外赠送：SelectableTextHelper网上还有位大神自定义了可选择 TextView 内容的帮助类，使用上非常方便，只要对原来的 TextView 加上如下设置即可： 12345mSelectableTextHelper = new SelectableTextHelper.Builder(mTextView) .setSelectedColor(getResources().getColor(R.color.selected_blue)) .setCursorHandleSizeInDp(20) .setCursorHandleColor(getResources().getColor(R.color.cursor_handle_color)) .build(); 有兴趣的同学可以参考此文章了解更多：自定义选择复制功能的实现 亲测在文字选择时，左右两边选择文字范围的图标不好点中，应该是坐标处理有点问题；而且无法在 ListView 中使用；但不得不说，整体效果非常好，对代码的侵入非常少，在各个平台上的体验也是统一的。 六、总结这几种方案来看的话： 如果项目中需要复制的 TextView 没有嵌套在 ListView 中，那就可以直接大胆地使用 textIsSelectable 属性，一步搞定； 如果使用到 ListView，能改成 RecyclerView 来实现的话，建议直接改成 RecyclerView，再加上 textIsSelectable 属性，也很好解决；（方案4） 如果非要用 ListView 的话，看看是否能在满足项目需求的情况下，直接使用 TextView 的点击事件，配合 ClipboardManager 直接自动复制指定内容，但记得在复制完成后给用户显示必要的提示。（方案3）========&gt; 本项目就是使用这种方案简单粗暴地解决 ListView 中无法长按选择复制 TextView 内容的问题的。 如果这几种方案还不能解决你的问题，可以在其余几种方案中看看是否有符合要求的。 七、疑问虽然项目问题解决了，但是还有以下几个问题，在查看了相关源码、进行一系列测试后，还是未能解决，暂且记录下来，说不定以后什么时候能力达到了，就能解决了呢？或者哪位小伙伴知道原因，还请不吝赐教～ 为什么设置 textIsSelectable 为 true 后，ListView 的 ItemClick 事件不响应了，明明该有的 DOWN、MOVE、UP 事件还是有？ItemClick 的触发条件是什么？ 而这时候，为什么 TextView 不会弹出选中框，以及复制、全选等操作按钮？而在添加了 android:selectAllOnFocus=&quot;true&quot; 后，长按后显示红色选择框，但不显示复制按钮，再次点击红色选择框，就会出现复制按钮。 TextView 长按后，在 LongClick 事件之后，就不再有 Touch 事件产生（如附录最后一项测试结果，以下附录只是记录而已） 附录1. 当 textIsSelectable 为 false 时1.1 未设置 TextView 的点击、长按事件：点击 ListView： 123456ListView: ↓↓↓ACTION_DOWN↓↓↓ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→...ListView: ↑↑↑ACTION_UP↑↑↑ 点击 TextView： 1234567TextView: ↓↓↓ACTION_DOWN↓↓↓ListView: ↓↓↓ACTION_DOWN↓↓↓ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→...ListView: ↑↑↑ACTION_UP↑↑↑ 长按 TextView： 1234567TextView: ↓↓↓ACTION_DOWN↓↓↓ListView: ↓↓↓ACTION_DOWN↓↓↓ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→...ListView: ↑↑↑ACTION_UP↑↑↑ 1.2 有设置 TextView 的点击、长按事件：点击 ListView： 123456ListView: ↓↓↓ACTION_DOWN↓↓↓ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→...ListView: ↑↑↑ACTION_UP↑↑↑ 点击 TextView： 1234567TextView: ↓↓↓ACTION_DOWN↓↓↓TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→...TextView: ↑↑↑ACTION_UP↑↑↑TextView: ↓onClick↓ 长按 TextView： 123456789101112TextView: ↓↓↓ACTION_DOWN↓↓↓TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→...TextView: ↓↓onLongClick↓↓TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→...TextView: ↑↑↑ACTION_UP↑↑↑TextView: ↓onClick↓ 2. 当 textIsSelectable 为 true 时2.1 未设置 TextView 的点击、长按事件：点击 ListView：(ItemClick 事件未响应) 123456ListView: ↓↓↓ACTION_DOWN↓↓↓ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→...ListView: ↑↑↑ACTION_UP↑↑↑ 点击 TextView： 123456TextView: ↓↓↓ACTION_DOWN↓↓↓TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→...TextView: ↑↑↑ACTION_UP↑↑↑ 长按 TextView：（显示出红色选中框后，不再有事件产生） 123456TextView: ↓↓↓ACTION_DOWN↓↓↓TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→...TextView: →→→ACTION_MOVE→→→ 2.2 有设置 TextView 的点击、长按事件：点击 ListView： 123456ListView: ↓↓↓ACTION_DOWN↓↓↓ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→ListView: →→→ACTION_MOVE→→→...ListView: ↑↑↑ACTION_UP↑↑↑ 点击 TextView： 1234567TextView: ↓↓↓ACTION_DOWN↓↓↓TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→...TextView: ↑↑↑ACTION_UP↑↑↑TextView: ↓onClick↓ 长按 TextView：（onLongClick 事件产生后，又产生了一次 MOVE 事件，然后不再有事件产生） 1234567TextView: ↓↓↓ACTION_DOWN↓↓↓TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→TextView: →→→ACTION_MOVE→→→...TextView: ↓↓onLongClick↓↓TextView: →→→ACTION_MOVE→→→ PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包工具 Charles 在移动开发中的应用]]></title>
    <url>%2Fapplication-of-Charles-in-mobile-development.html</url>
    <content type="text"><![CDATA[一、前言Charles 是一个 Web 代理服务器（HTTP 代理 / HTTP 监视器），是一个常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 Charles 的主要功能包括： SSL 代理 流量控制：可以模拟慢速网络以及等待时间（latency）较长的请求 AJAX 调试：可以自动将 json 或 xml 数据格式化 AMF 重发网络请求，方便后端调试 支持修改网络请求参数 可设置断点来拦截请求和响应数据 检查 HTML，CSS 和 RSS 内容是否符合 W3C 标准 本文主要介绍在移动开发中常用的几个功能，希望能对移动开发人员有一定的帮助。 二、安装和激活Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。 不差钱的小主儿可直接到 Charles 官网下载相应操作系统版本，并根据需求在 这里 购买相应的License。 但我相信，更多的小主儿还是觉得在天朝这个神奇的国度，免费才是王道。 Mac 版可上 Xclient 下载，里面的软件一般会有多个版本，更重要的是，都会有激活方法，实在是良心网站啊～ 至于 Windows 版的话，百度谷歌搜索一下，或者官网下载之后，网上搜下注册码，相信在天朝生活了几十年的各位小主儿混得比我还开。 三、Charles 主界面介绍 1. 两种视图模式Charles 主要提供两种查看封包的视图，分别名为 Structure 和 Sequence。 Structure： 视图将网络请求按访问的域名分类。 Sequence： 视图将网络请求按访问的时间排序。 2. 过滤关键字一般我们可以直接在 Filter 栏中输入需要的关键字，来筛选出关注的网络请求，比如我们的服务器地址是：www.youraddress.com，那我们就可以直接在 Filter 栏中输入：youraddress 来过滤。 3. 请求内容和响应内容在界面下方，还可以看到本次请求的概述（Overview）、请求内容（Request）、响应内容（Response）等一系列信息： 概述：包含了 URL、请求状态、请求时间、请求数据大小、响应数据大小等信息 请求内容：包含了请求头信息（请求方式、URL、协议、User-Agent、Host 等信息） 响应内容：包含了请求头、响应数据包内容等信息，而响应数据又可以按原格式、Json 格式、Json Text 格式进行显示，如果响应内容是图片，Charles 还可以显示出图片的预览，极大地方便了数据的阅读 四、截取移动设备上的网络封包介绍完 Charles 的基础使用方法后，接下来就进入本文的正题，也就是怎么在移动开发中使用 Charles 来截取移动设备上的网络封包，进行数据分析。本文以 Android 设备为例进行讲解。 首先我们需要保证电脑和移动设备使用的是 同一个局域网，然后我们需要将移动设备的网络代理设置为电脑的 IP 和端口号。 1. Charles 设置我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 Proxy -&gt; Proxy Settings，填入代理端口 8888（请记住此端口号，后面 Android 设备的设置中会用到），并且勾上 Enable transparent HTTP proxying 就完成了在 Charles 上的设置: 2. 手机设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的菜单栏的 Help -&gt; Local IP Address，即可在弹出的对话框中看到 IP 地址： 在手机的 设置 -&gt; WLAN 中，可以看到当前连接的 wifi 名称： 长按 点击修改网络 打开高级选项 在代理一栏选择手动 代理服务器器主机名填写第 1 步看到的电脑IP：192.168.1.101 代理服务器端口填写 Charles 设置中填入的商品号：8888 保存 设置好之后，我们打开手机上的任意需要网络通讯的程序，就可以看到 Charles 弹出手机请求连接的确认菜单，点击 “Allow” 即可完成设置。 之后，我们就可以在 Charles 上看到手机网络请求的所有数据了。 五、断点Breakpoints 功能类似我们在 Android Studio、Eclipse、Xcode 等开发环境中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这时候我们可以在 Charles 中临时修改网络请求的请求内容、响应内容。 右击我们需要设置断点的请求，选择 Breakpoints： 然后选择菜单栏 Proxy -&gt; Breakpoint Settings... 双击我们要设置断点的请求，进入编辑： 在这里，我们可以编辑断点的相关参数，常用的功能是根据需要为 请求内容（Request） 或 响应内容（Response）设置断点，即图上的两个复选框，默认为请求内容和响应内容都设置断点，即当发起这个网络请求、以及收到服务器返回的响应数据时，都会进入断点；当然，我们也可以只跟踪 Request 或 Response。 当我们发起这个断点设置的网络请求时，会进入断点，我们就可以修改请求参数： 当服务器返回数据后，也可以修改返回数据，这里我们常用来修改返回标识（如成功、失败）、修改返回数据（无数据、数据内容为指定值），再查看我们的客户端程序的处理是否正确。 除了设置断点来修改请求数据，还可以使用 网络请求的修改和重发功能 来进行请求数据的修改和重发。（右键菜单里的 Edit 已改成 Compose，可能是 4.0 的时候改的，使用时请注意一下） 另外也可以使用 Map 功能、 Rewrite 功能对响应数据进行长期和批量的修改。 六、慢速网络在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。 在菜单栏上选择 Proxy -&gt; Throttle Setting，在之后弹出的对话框中，我们可以勾选上 Enable Throttling，并且可以设置 Throttle Preset 的类型。 如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 Only for selected hosts 项，然后在对话框的下半部分设置中增加指定的 hosts 即可。 七、其它Charles 除了以上功能，还可以： 修改、重发网络请求 压力测试 Map Rewrite 反向代理 截取 HTTPS 通讯信息（需安装 SSL 证书） 如有需要，请查阅以下参考资料或相关文档。 八、参考资料Charles 官网Charles 从入门到精通 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 加速编译方法汇总]]></title>
    <url>%2FAndroidStudio-speed-up_methods.html</url>
    <content type="text"><![CDATA[一、JRebel for AndroidJRebel for Android 是一个 Android Studio 的插件，可以大大加速 Android Studio 的编译速度，对于小项目来说或许不明显；但是当项目达到一定的规模时，它对于 Android Studio 乌龟般的编译速度有非常大的改善。 JRebel for Android 使得每次改动代码后，不需要重新安装新的 apk；而是在安装完一次应用后，通过增量包传递到设备或者模拟器上，并且能够在应用运行时进行更新。 据说 JRebel 比 Instant Run 快了 8 倍，详情可查看 官方介绍。 1. 安装你可以直接点击IDE的 Plugins -&gt; Browse Repositories -&gt; 输入 JRebel for Android 来搜索和安装插件。 如果因为某些原因你无法访问 maven 的公有仓库，你可以直接在 JetBrians 官网 下载，然后通过 Plugins &gt; Install plugin from disk… 来安装插件。 当你安装完插件后，你需要重启 Android Studio，在重启之后，你需要提供你的姓名和邮箱来得到 JRebel for Android 的 21 天免费使用（JRebel 是收费的，个人用户每年要 49 美元，但是据说 21 天到期之后你可以重新注册，据说官方对邮件没有验证，由于我暂未使用到 21 天，所以暂时未知，感兴趣的你可以下载试试）。 2. 使用重启 Android Studio，会发现在顶部工具栏出现如下三个按钮： 从左到右分别是： Run app with JRebel for Android Debug app with JRebel for Android Apply changes with JRebel for Android 一般我们只需要第一次安装的时候使用 第一个按钮 运行一次，之后代码变动，只需要点击 第三个按钮 ，你的真机或者模拟器很快就展示出来修改代码之后的效果。 3. 参考资料[译] 怎样用 JRebel for AndroidANDROID 高效调试神器 JREBEL 二、FreelineFreeline 是由蚂蚁聚宝 Android 团队开发的一款针对 Android 平台的增量编译工具。它可以充分利用缓存文件，在几秒钟内迅速地对代码的改动进行编译并部署到设备上，有效地减少了日常开发中的大量重新编译与安装的耗时。 1. 配置配置 project-level 的 build.gradle，加入 freeline-gradle 的依赖： 12345678buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.antfortune.freeline:gradle:0.8.2' &#125;&#125; 然后，在你的主 module 的 build.gradle 中，应用 freeline 插件的依赖： 12345apply plugin: 'com.antfortune.freeline'android &#123; ...&#125; 最后，在命令行执行以下命令来下载 freeline 的 python 和二进制依赖。 Windows[CMD]: gradlew initFreeline Linux/Mac: ./gradlew initFreeline 对于国内的用户来说，如果你的下载的时候速度很慢，你也可以加上参数，执行 gradlew initFreeline -Pmirror，这样就会从国内镜像地址来下载，命令即为： Windows[CMD]: gradlew initFreeline -Pmirror Linux/Mac: ./gradlew initFreeline -Pmirror 你也可以使用参数 -PfreelineVersion={your-specific-version} 来下载特定版本的 freeline 依赖。 如果你的工程结构较为复杂，在第一次使用 freeline 编译的时候报错了的话，你可以添加一些 freeline 提供的配置项，来适配你的工程。具体可以看 Freeline DSL References。 2. 使用Freeline 最快捷的使用方法就是直接安装 Android Studio 插件。 在 Android Studio 中，通过以下路径 Preferences → Plugins → Browse repositories，搜索 “freeline”，并安装。 直接点击 Run Freeline 的按钮，就可以享受 Freeline 带来的开发效率的提升啦（当然，你可能会先需要一个较为耗时的全量编译过程）。 插件也会提示你 Freeline 最新的版本是多少，你也可以通过插件来对 Freeline 进行更新。 3. 参考资料Freeline 官方文档AndroidStudio Freeline 实现工程秒级编译 三、其它方法其实 Android Studio的官方文档 就有关于优化编译速度的配置方法： 网上也有不少关于加速编译的资料： 但是经过实践，要不是配置麻烦，就是效果不佳，目前来看，还是 JRebel 的配置最简单，使用效果最好，如果你有更好的加速方法，欢迎留言交流。 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 BigDecimal 对浮点数据进行精确计算【转】]]></title>
    <url>%2Fuse-BigDecimal-for-accurate-calculation-of-float-data.html</url>
    <content type="text"><![CDATA[本文转载自 Java 中浮点型数据 Float 和 Double 进行精确计算的问题 一、浮点计算中发生精度丢失大概很多有编程经验的朋友都对这个问题不陌生了：无论你使用的是什么编程语言，在使用浮点型数据进行精确计算时，你都有可能遇到计算结果出错的情况。来看下面的例子。 这是一个利用浮点型数据进行精确计算时结果出错的例子，使用 Java 编写，有所省略。 12double a = (1.2 - 0.4) / 0.1;System.out.println(a); 如果你认为这个程序的输出结果是“8”的话，那你就错了。实际上，程序的输出结果是“7.999999999999999”。好，问题来了。到底是哪里出了错？ 浮点型数据进行精确计算时，该类问题并不少见。我们姑且称其为“精度丢失”吧。大家可以试着改一下上面的程序，你会发现一些有趣的现象： 如果你直接使用一个数字代替括号里的表达式，如“0.8 / 0.1”或者“1.1 /0.1”，那么似乎，注意只是似乎不会出现问题； 我们可能会做第二个测试，就是对比“0.8 / 1.1”和“(1.2 - 0.4) / 1.1”的结果，没错，我就是这样做的。那么你会发现，前者的结果是“0.7272727272727273”（四舍五入后的结果），而后者的结果是 “0.7272727272727272”（没有进行四舍五入）。可以推测，经过一次计算后，精度丢失了； 很好，我觉得我们已经很接近真相了，但是接下来的第三个测试或许会让你泄气，我是这样做的：对比“(2.4 - 0.1) / 0.1”、“(1.2 - 0.1) / 0.1”以及“(1.1 - 0.1) / 0.1”的结果，第一个是“22.999999999999996”，第二个是“10.999999999999998”，第三个是“10.0”。似乎完 全推翻了我们的想法； 你可能还不死心，因为在上面的测试里，第三个表达式括号中的结果实在太诡异了，正好是“1.0”。那我们再来对比一下“(2.4 - 0.2) / 0.1”和“(2.4 - 0.3) / 0.1”，前者结果是“21.999999999999996”，后者结果是“21.0”。恭喜你，做到这里，你终于可以放弃这个无聊的测试了。 最后，我们还可以来推翻一下我们第一个测试的假设：当使用“2.3 / 0.1”时，结果为“22.999999999999996”，出现精度丢失。也就是说，所谓“经过一次计算后，精度丢失”的假设是不成立的。 二、为何会出现精度丢失那么为什么会出现精度丢失呢？在查阅了一些资料以后，我稍微有了一些头绪，下面是本人的愚见，仅供参考。 首先得从计算机本身去讨论这个问题。我们知道，计算机并不能识别除了二进制数据以外的任何数据。无论我们使用何种编程语言，在何种编译环境下工作，都要先 把源程序翻译成二进制的机器码后才能被计算机识别。以上面提到的情况为例，我们源程序里的2.4是十进制的，计算机不能直接识别，要先编译成二进制。但问 题来了，2.4的二进制表示并非是精确的2.4，反而最为接近的二进制表示是2.3999999999999999。原因在于浮点数由两部分组成：指数和 尾数，这点如果知道怎样进行浮点数的二进制与十进制转换，应该是不难理解的。如果在这个转换的过程中，浮点数参与了计算，那么转换的过程就会变得不可预 知，并且变得不可逆。我们有理由相信，就是在这个过程中，发生了精度的丢失。而至于为什么有些浮点计算会得到准确的结果，应该也是碰巧那个计算的二进制与 十进制之间能够准确转换。而当输出单个浮点型数据的时候，可以正确输出，如 12double d = 2.4;System.out.println(d); 输出的是2.4，而不是2.3999999999999999。也就是说，不进行浮点计算的时候，在十进制里浮点数能正确显示。这更印证了我以上的想法，即如果浮点数参与了计算，那么浮点数二进制与十进制间的转换过程就会变得不可预知，并且变得不可逆。 事实上，浮点数并不适合用于精确计算，而适合进行科学计算。这里有一个小知识：既然 float 和 double 型用来表示带有小数点的数，那为什么我们不称 它们为“小数”或者“实数”，要叫浮点数呢？因为这些数都以科学计数法的形式存储。当一个数如50.534，转换成科学计数法的形式为5.053e1，它 的小数点移动到了一个新的位置（即浮动了）。可见，浮点数本来就是用于科学计算的，用来进行精确计算实在太不合适了。 三、如何使用浮点数进行精确计算那么能够使用浮点数进行精确计算吗？直接计算当然是不行啦，但是我们当然也可以通过一些方法和技巧来解决这个问题。由于浮点数计算的结果跟正确结果非常接近，你很可能想到使用四舍五入来处理结果，以得到正确的答案。这是个不错的思路。 那么如何实现四舍五入呢？你可能会想到 Math 类中的 round 方法，但是有个问题，round 方法不能设置保留几位小数，如果我们要保留两位小数，我们只能像这样实现： 123public double round(double value)&#123; return Math.round(value*100)/100.0;&#125; 如果这能得到正确的结果也就算了，大不了我们再想方法改进。但是非常不幸，上面的代码并不能正常工作，如果给这个方法传入4.015，它将返回4.01而不是4.02。 java.text.DecimalFormat 也不能解决这个问题，来看下面的例子： 1System.out.println(new java.text.DecimalFormat("0.00").format(4.025)); 它的输出是4.02，而非4.03。 难道没有解决方法了吗？当然有的。在《Effective Java》这本书中就给出了一个解决方法。该书中也指出，float 和 double 只能用来做科学计算或者是工程计算，在商业计算等精确计算中，我们要用 java.math.BigDecimal。 BigDecimal 类一个有 4 个方法，我们只关心对我们解决浮点型数据进行精确计算有用的方法，即 1BigDecimal(double value) // 将double型数据转换成BigDecimal型数据 思路很简单，我们先通过 BigDecimal(double value) 方法，将 double 型数据转换成 BigDecimal 数据，然后就可以正常进行精确计算了。等计算完毕后，我们可以对结果做一些处理，比如 对除不尽的结果可以进行四舍五入。最后，再把结果由 BigDecimal 型数据转换回 double 型数据。 这个思路很正确，但是如果你仔细看看API里关于 BigDecimal 的详细说明，你就会知道，如果需要精确计算，我们不能直接用 double，而非要用 String 来构造 BigDecimal 不可！所以，我们又开始关心 BigDecimal 类的另一个方法，即能够帮助我们正确完成精确计算的 BigDecimal(String value) 方法。 BigDecimal(String value) 能够将 String 型数据转换成 BigDecimal 型数据 那么问题来了，想像一下吧，如果我们要做一个浮点型数据的加法运算，需要先将两个浮点数转为 String 型数据，然后用 BigDecimal(String value) 构造成 BigDecimal，之后要在其中一个上调用 add 方法，传入另一个作为参数，然后把运算的结果 （BigDecimal） 再转换为浮 点数。如果每次做浮点型数据的计算都要如此，你能够忍受这么烦琐的过程吗？至少我不能。所以最好的办法，就是写一个类，在类中完成这些繁琐的转换过程。这 样，在我们需要进行浮点型数据计算的时候，只要调用这个类就可以了。网上已经有高手为我们提供了一个工具类 Arith 来完成这些转换操作。它提供以下静态方法，可以完成浮点型数据的加减乘除运算和对其结果进行四舍五入的操作： 123456public static double add(double v1,double v2)public static double sub(double v1,double v2)public static double mul(double v1,double v2)public static double div(double v1,double v2)public static double div(double v1,double v2,int scale)public static double round(double v,int scale) 下面会附上 Arith 的源代码，大家只要把它编译保存好，要进行浮点数计算的时候，在你的源程序中导入 Arith 类就可以使用以上静态方法来进行浮点数的精确计算了。 附录：Arith 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.math.BigDecimal;/`* 由于Java的简单类型不能够精确的对浮点数进行运算，这个工具类提供精* 确的浮点数运算，包括加减乘除和四舍五入。*/public class Arith &#123; //默认除法运算精度 private static final int DEF_DIV_SCALE = 10; //这个类不能实例化 private Arith()&#123; &#125; /` * 提供精确的加法运算。 * @param v1 被加数 * @param v2 加数 * @return 两个参数的和 */ public static double add(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2).doubleValue(); &#125; /` * 提供精确的减法运算。 * @param v1 被减数 * @param v2 减数 * @return 两个参数的差 */ public static double sub(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2).doubleValue(); &#125; /` * 提供精确的乘法运算。 * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static double mul(double v1,double v2)&#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; /` * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到 * 小数点以后10位，以后的数字四舍五入。 * @param v1 被除数 * @param v2 除数 * @return 两个参数的商 */ public static double div(double v1,double v2)&#123; return div(v1,v2,DEF_DIV_SCALE); &#125; /` * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 * 定精度，以后的数字四舍五入。 * @param v1 被除数 * @param v2 除数 * @param scale 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double div(double v1,double v2,int scale)&#123; if(scale&lt;0)&#123; throw new IllegalArgumentException( "The scale must be a positive integer or zero"); &#125; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2,scale,BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /` * 提供精确的小数位四舍五入处理。 * @param v 需要四舍五入的数字 * @param scale 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v,int scale)&#123; if(scale&lt;0)&#123; throw new IllegalArgumentException( "The scale must be a positive integer or zero"); &#125; BigDecimal b = new BigDecimal(Double.toString(v)); BigDecimal one = new BigDecimal("1"); return b.divide(one,scale,BigDecimal.ROUND_HALF_UP).doubleValue(); &#125;&#125; PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>浮点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义组合控件：SherlockSpinner]]></title>
    <url>%2Fcustom-combine-widget-SherlockSpinner.html</url>
    <content type="text"><![CDATA[如果你觉得从头开始自定义一个 View 比较麻烦，那么组合几个系统现有控件来实现需求的功能，会是你很好的一个选择。 一、前言最近在项目中，需要使用 Spinner 来实现下拉选择功能，UI 方面倒是要求不多。但是难点在于一个界面中有多个 Spinner，并且有联动关系，数据需要在点击 Spinner 的时候请求服务器。而且当前 Spinner 数据依赖于前面选择的一个或多个结果，当获取到最新数据后，才显示下拉选项。 比如说我需要先选择一个仓库，再选择项目（依赖前面选择的仓库），再选择一个批次（依赖前面选择的仓库和项目），如果我在选择完仓库时，就去判断来预加载项目和批次的数据，会使依赖逻辑变得非常复杂。 这时候就想在每次点击一个 Spinner 的时候，去判断依赖的选项是否已经选择，未选择就提示需先选择；如果已选择，则进行网络请求，加载数据显示到下拉选项中。 （本例使用选择语言来进行演示。） 二、使用系统 Spinner1. 首先，我想到的便是使用系统的 Spinner，说干就干，XML 先上：1234&lt;Spinner android:id="@+id/spn_languages" android:layout_width="match_parent" android:layout_height="36dp"/&gt; 2. 然后代码设置 Adapter 匹配数据、设置 OnItemSelectedListener 绑定 item 选择的事件：1234567891011121314spnLanguages = (Spinner) findViewById(R.id.spn_languages);ArrayAdapter&lt;String&gt; mAdapterSystemSpinner = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, mLanguages);spnLanguages.setAdapter(mAdapterSystemSpinner);spnLanguages.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; showMessage("Select " + mLanguages[position]); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; parent) &#123; showMessage("Select Nothing."); &#125;&#125;); OK，现在 Spinner 可以使用了： 3. 接着我们来设置点击事件123456spnLanguages.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; showMessage("Click Spinner"); &#125;&#125;); 什么情况，运行后直接崩了？ 123456789FATAL EXCEPTION: mainProcess: com.sherlockshi.widget.sherlockspinner, PID: 11757java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.sherlockshi.widget.sherlockspinner/com.sherlockshi.widget.MainActivity&#125;: java.lang.RuntimeException: Don&apos;t call setOnClickListener for an AdapterView. You probably want setOnItemClickListener instead ...Caused by: java.lang.RuntimeException: Don&apos;t call setOnClickListener for an AdapterView. You probably want setOnItemClickListener instead at android.widget.AdapterView.setOnClickListener(AdapterView.java:798) at com.sherlockshi.widget.MainActivity.initSystemSpinner(MainActivity.java:169) at com.sherlockshi.widget.MainActivity.onCreate(MainActivity.java:48) ... 简单来说就是，AdapterView 不能设置 Click 事件，看下 Spinner 源码，确实是继承自 AdapterView。（至于为什么 AdapterView 不能设置 Click 事件，这个暂未深究。） 4. 那我们就设置 Touch 事件喽：1234567891011spnLanguages.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: showMessage("Touch Spinner"); break; &#125; return false; &#125;&#125;); 这下确实是可以响应点击事件了，但是响应完，下拉选择就直接显示出来了，无法满足我们的需求。 而且 Spinner 还有个问题，一进入界面的时候，默认就会选择第一项，而我们并不需要这样的默认值。 三、CustomSpinner = EditText + ListPopupWindow那我们是否可以使用别的控件，来实现相同的功能呢？答案是肯定的，我们用 EditText 来接收点击事件，而在请求完数据之后，使用 ListPopupWindow 来显示下拉选项，选择 EditText 的原因主要有以下几点： 默认在底部会有带颜色的横线，Material Design 风格的 EditText 看起来效果很不赖 EditText 可以方便的配置上、下、左、右四个位置的小图标，我们可以在右侧放置一个向下的三角箭头，使它看起来像一个系统的 Spinner 而选择 ListPopupWindow 则是因为： 可以方便的使用下拉列表 可以自由设置锚点 1. XML 布局布局文件依旧很简单，只要一个简单的 EditText，配上一个右侧的下拉图标： 1234567&lt;EditText android:id="@+id/et_languages" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="right" android:drawableRight="@drawable/ic_dropdown" android:hint="Please Select..."/&gt; 2. 代码中创建 ListPopupWindow此部分包含以下逻辑： 初始化 ListPopupWindow，并关联到 EditText 上 当点击 EditText 时，请求数据，请求完成后，显示 ListPopupWindow 选中 ListPopupWindow 的某一项后，将此项内容更新到 EditText 中，并隐藏 ListPopupWindow 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253etLanguages = (EditText) findViewById(R.id.et_languages);etLanguages.setKeyListener(null); // 设置 EditText 不可编辑，等同于在 xml 中设置 editable="false"lpwLanguages = new ListPopupWindow(this);mAdapterLanguages = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, mLanguages);lpwLanguages.setAdapter(mAdapterLanguages);lpwLanguages.setAnchorView(etLanguages); //设置 ListPopupWindow 的锚点，即关联 PopupWindow 的显示位置lpwLanguages.setModal(true); // 是否为模态，当设置为 true 时，会处理返回按键的事件lpwLanguages.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; showMessage("Select " + mLanguages[position]); etLanguages.setText(mLanguages[position]); lpwLanguages.dismiss(); &#125;&#125;);// 如果使用 onClick 事件，会出现第一次点击只获取焦点，第二次点击才出现下拉etLanguages.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; // Do what you want getDataFromNet(); &#125; return false; &#125;&#125;);public void getDataFromNet() &#123; // 延时 2 秒后，修改源数据，用来模拟网络请求 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mLanguages[1] = "C+++++++++++++"; mAdapterLanguages.notifyDataSetChanged(); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; lpwLanguages.show(); &#125; &#125;); &#125; &#125;).start();&#125; 实现效果如下所示： 3. 小结EditText 配合 ListPopupWindow 组合实现 Spinner 的功能，使用起来倒是简单，逻辑也挺清晰的，但是如果界面上有三四个 Spinner，那不是就得把类似的代码写上三四遍？ 其实我们并不关心内部是用 ListPopupWindow 或者其它的控件来实现，也不想处理任何关于 ListPopupWindow 的细节。我们关心的只有 Spinner 的初始化、适配数据、Item 选择事件（ItemClick 事件），如果可以，就再加上 Spinner 的点击事件（Click 或 Touch 事件）、自由控制 Spinner 的显示时机。 那有没有简单易用的方法，可以直接像使用系统的 Spinner 一样，来使用 EditText 和 ListPopupWindow 的组合呢？并且可以提供 Spinner 的点击事件？答案是肯定的，详情且看下一节。 四、自定义组合控件在第二部分我们可以看出，我们的控件要满足以下两大功能： 像系统 Spinner 一样简单易用：初始化、适配数据、Item 选择事件（ItemClick 事件） 支持点击事件（Click 或 Touch 事件），自由控制下拉框显示时机 由于控件源码稍长，就不贴出来了，有兴趣可以点击文末的 Github 链接，源码也比较简单，只是进行控件的组合，并提供相应的方法进行调用，下面主要介绍下使用方法。 1. 引入依赖1234dependencies &#123; ... compile 'com.sherlockshi.widget:sherlockspinner:1.0.2'&#125; 2. 使用方法2.1 像使用系统 Spinner 一样，在 XML 文件中使用:123456&lt;com.sherlockshi.widget.SherlockSpinner android:id="@+id/sherlock_spinner" android:layout_width="match_parent" android:layout_height="wrap_content" app:lineColor="#00FF00" android:hint="Please Select..."/&gt; SherlockSpinner 有以下属性:lineColor: 设置底部横线的颜色同时支持使用代码进行配置：mSherlockSpinner.setLineColor(0x00FF00); 由于 SherlockSpinner 继承自 EditText, 所以你可以使用 EditText 的其它属性，例如 gravity、textSize、textColor… 2.2 还是像使用系统 Spinner 一样，在代码中设置 Adapter 和 ItemClickListener:123456789mSherlockSpinner = (SherlockSpinner) findViewById(R.id.sherlock_spinner);ArrayAdapter&lt;String&gt; mAdapterLanguages = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, mLanguages);mSherlockSpinner.setAdapter(mAdapterLanguages);mSherlockSpinner.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; showMessage("Select " + mLanguages[position]); &#125;&#125;); 以上，就可以像系统 Spinner 一样使用 SherlockSpinner 了，如果没有别的需求，这样也就够用了。如果你有点击请求网络数据，再异步显示下拉框的需求，可以看第 3 步的使用方法。 2.3 (可选) 如果你想在异步加载数据后，再显示出更新后的数据，你可以使用它的点击事件来处理记住：在获取数据后，你必须手动调用 sherlockSpinner.show() 方法来显示 SherlockSpinner 的下拉选项 12345678910111213141516171819202122232425262728293031mSherlockSpinner.setOnClickListener(new SherlockSpinner.OnClickListener() &#123; @Override public void onClick(View v) &#123; getDataFromNet(); &#125;&#125;);public void getDataFromNet() &#123; // after delay 2s, modify the source data, to simulate net request new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mLanguages[4] = "Javaaaaaaaaaaa"; mAdapterLanguages.notifyDataSetChanged(); // then you must manually call sherlockSpinner.show() runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mSherlockSpinner.show(); &#125; &#125;); &#125; &#125;).start();&#125; 3. 更多属性 由于 SherlockSpinner 继承自 EditText，所以你可以使用 EditText 的其它属性，例如 gravity、textSize、textColor… SherlockSpinner 还有一个属性，可以设置下拉框的显示位置，即锚点设置： 1mSherlockSpinner.setAnchorView(findViewById(R.id.llyt_anchor)); 效果如下图中 4 和 5 的区别，在第 4 部分中，下拉框停靠在 Spinner上；而第 5 部分中，下拉框停靠在 Spinner 所在的整行布局上，宽度更大。 五、其它另外，一个小小的 Tip：在 styles.xml 文件中配置以下代码，可使下拉框带上漂亮的分割线： 123456789&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; ... &lt;item name="android:dropDownListViewStyle"&gt;@style/mySpinnerStyle&lt;/item&gt;&lt;/style&gt;&lt;style name="mySpinnerStyle" parent="android:Widget.ListView.DropDown"&gt; &lt;item name="android:divider"&gt;#E0E0E0&lt;/item&gt; &lt;item name="android:dividerHeight"&gt;0.1dp&lt;/item&gt;&lt;/style&gt; 项目代码已共享到 Github：SherlockSpinner欢迎 fork、star、issue。 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android MVP 架构实践]]></title>
    <url>%2FAndroid-MVP-architechure-practise.html</url>
    <content type="text"><![CDATA[一、前言首先声明一下，没有完美的架构，只要适合自己的项目，那就是最好的架构。 本例子是 MVP + Retrofit + RxJava 结合的例子，但本文的重点在于讲解 MVP 架构，所以涉及 Retrofit 和 RxJava 的部分将直接略过，默认读者已了解这两部分内容，如有需要，请自行查阅相关资料，网上资料很多。 史上最全 MVP 资料合集: Android MVP 详解（上） RxJava 学习参考资料: 是时候学习 RxJava 了 二、MVC早期项目中，我们会使用 MVC 架构来构建我们的项目，但是 MVC 架构的缺陷很明显，V 层和 C 层的职责混淆不清，很容易就会写成万能的 Activity，把业务逻辑、View 操作等一系列功能全放到 Activity 中来实现。 三、MVPMVP 是 MVC 的进化版，它把 Controller 的职责从 Activity/Fragment 中拆分出来，作为 Presenter，这样就实现了 Activity/Fragment 和业务逻辑的解耦，更好地解决了数据与界面的关系。 View 层: 对应于 Activity/Fragment，负责 View 的绘制以及与用户交互 Presenter 层: 负责完成 View 与 Model 间的交互 Model 层: 实体模型、与数据进行交互，对数据进行加工处理 1. 架构图 （上图由 ProcessOn 在线工具绘制） 2. 类图（上图由 StarUML 绘制） 四、MVP 实践1. 两个基类接口首先定义两个接口，这两个接口分别是所有 View 和 Presenter 的基类: IBaseView 和 IBasePresenter。 IBaseView 中主要定义一些通用的界面方法，如显示/隐藏进度条、显示提示信息等。 IBasePresenter 中也可以定义一些通用的方法，如初始化方法等。 12345public interface IBaseView &#123; void showLoading(); void hideLoading(); void showMessage(String msg);&#125; 123public interface IBasePresenter &#123; ...&#125; 2. 定义契约类（接口）使用契约类来统一管理 View 与 Presenter 的所有接口，这种方式使得 View 与 Presenter 中有哪些功能，一目了然，维护起来也很方便。 123456789public interface CookDetailContract &#123; interface IView extends IBaseView &#123; void updateCookDetail(CookDetail cookDetail); &#125; interface IPresenter extends IBasePresenter &#123; void getCookDetail(String apikey, String id); &#125;&#125; CookDetailContract 中的 IView 接口定义了该界面（功能）中所有的 UI 状态情况，MainAcitivty 作为 View 层，实现了该接口，这样 MainActivity 就只关注 UI 相关的状态更新。 IPresenter 接口则定义了该界面（功能）中所有的用户操作事件，CookDetailPresenter 作为 Presenter 层，实现了该接口，这样 CookDetailPresenter 就只关注业务层的相关逻辑，UI 的更新只需调用 IView 的状态方法。 3. View 层（Activity/Fragment）Activity/Fragment 是一个全局的控制者，负责创建 View 以及 Presenter 实例，并将二者联系起来。 在本例中，MainActivity 实现了 CookDetailContract.IView 接口，并在 onResume() 回调中创建 CookDetailPresenter 实例，CookDetailPresenter 的构造函数中实现了 View 和 Presenter 的关联。 在创建完 Presenter 后，调用 Presenter 的 getCookDetail() 方法获取相应的数据（如上图步骤①）。 在获取到 Model 层的数据后，Presenter 通过 IView 中的 updateCookDetail() 方法返回数据（如上图步骤④），Activity 获取数据后，将结果展示到界面上反馈给用户。 12345678mCookDetailPresenter = new CookDetailPresenter(MainActivity.this, this);mCookDetailPresenter.getCookDetail(Config.API_KEY, (id++) + "");@Overridepublic void updateCookDetail(CookDetail cookDetail) &#123; tvName.setText(cookDetail.getName()); Picasso.with(this).load(Config.IMAGE_URL_PREFIX + cookDetail.getImg()).into(ivImage);&#125; 4. Presenter 层它实现了契约类中的 IPresenter 接口。 Presenter 翻译过来是主持人的意思，它做为 MVP 架构中最关键的一层，负责连接 View 层和 Model 层。比如控制显示/隐藏进度框、显示/隐藏空布局、错误布局，调用相应的 Model 层方法进行数据的获取，并在 Model 层返回数据后，将数据适配到 View 中展示。这样，便可以让 Model 层只关注数据相关的操作、也让 View 层只专注于界面的展示，让各个层级各司其职，相互协作。 123456789101112131415161718192021222324252627282930public class CookDetailPresenter implements CookDetailContract.IPresenter &#123; private Context mContext; private CookDetailContract.IView mView; private CookDetailManager mCookDetailManager = CookDetailManager.getInstance(); public CookDetailPresenter(Context context, CookDetailContract.IView view) &#123; this.mContext = context; this.mView = view; &#125; @Override public void getCookDetail(String apikey, String id) &#123; mView.showLoading(); mCookDetailManager.getCookDetail(apikey, id, new Callback&lt;CookDetail&gt;() &#123; @Override public void onSuccess(CookDetail object) &#123; mView.updateCookDetail(object); mView.hideLoading(); &#125; @Override public void onFail(int errorNo, String errorMsg) &#123; ErrorUtil.processErrorMessage(mContext, errorNo, errorMsg, mView); mView.hideLoading(); &#125; &#125;); &#125;&#125; 5. Model 层Model 层不只包含实体对象，更主要的功能是处理一切与数据相关的操作，如数据的获取、存储、数据状态变化都是 Model 层的任务，Presenter 会根据需要调用该层的数据处理逻辑（如上图步骤②），如有需要，Model 层会使用回调将数据传回 Presenter 层（如上图步骤③）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CookDetailManager &#123; private volatile static CookDetailManager instance; private CookDetailManager() &#123; &#125; public static CookDetailManager getInstance() &#123; if (instance == null) &#123; synchronized (CookDetailManager.class) &#123; if (instance == null) &#123; instance = new CookDetailManager(); &#125; &#125; &#125; return instance; &#125; public void getCookDetail(String apikey, String id, final Callback&lt;CookDetail&gt; callback) &#123; if (callback == null) &#123; return; &#125; Retrofit retrofit = RetrofitClient.INSTANCE.getRetrofit(); ApiService apiService = retrofit.create(ApiService.class); Observable&lt;CookDetail&gt; observable = apiService.getCookDetail(apikey, id); observable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;CookDetail&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; callback.onFail(Constants.ErrorNo.ServerError, ""); e.printStackTrace(); &#125; @Override public void onNext(CookDetail respEntity) &#123; callback.onSuccess(respEntity); &#125; &#125;); &#125;&#125; 五、总结使用 MVP 架构，缺点在于需要增加很多接口类、实现类，对于刚开始接口 MVP 架构的人来说，增加了不少的学习成本，看着一堆的类、一堆的接口，调来调去的，刚开始肯定会看晕。 但是当你熟悉了 MVP 架构，并掌握了它的精髓后，会发现虽然增加了很多代码，但是整体架构变得非常清晰，代码也可以多处复用。各个类和层的职责都非常明确且单一，后期的扩展，维护都会更加容易。整体的可测试性非常的好，UI 层和业务层可以分别进行单元测试。 项目代码已共享到 Github：AndroidMVPArchitecture 六、效果图 七、参考资料Android 官方 MVP 架构项目解析 Android:“万能” Activity 重构篇-牛晓伟 Android 高仿微信之 mvp 实现(一) RxJava 与 Retrofit 结合的最佳实践 Android MVP 详解（下） Android MVP 实战经验 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MVP</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 TabLayout 添加角标的最简单方法]]></title>
    <url>%2Fsimplest-method-to-badge-TabLayout.html</url>
    <content type="text"><![CDATA[一、前言在开发中，我们常常需要 ViewPager 结合 Fragment一起使用，来实现多页签的切换效果。在以前，我们有以下一系列第三方库来帮我们实现: PagerSlidingTabStrip SmartTabLayout FlycoTabLayout ViewPagerIndicator … 而现在，我们可以使用Design support library 库的 TabLayout 来实现了。 二、最终效果图 三、TabLayout 的使用1. 添加依赖由于 TabLayout 在 design 包内，所以首先需要在 app 目录下的 build.gradle 中添加以下依赖： 1234dependencies &#123; ... compile 'com.android.support:design:23.4.0'&#125; 2. 创建布局布局相当简单，只要添加 TabLayout 和 ViewPager 的布局即可： 1234567891011121314151617181920212223// layout/activity_main.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tab_layout" style="@style/TabLayoutStyle" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/view_pager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="@android:color/white"/&gt;&lt;/LinearLayout&gt; 还有其他的属性我习惯在style文件中设置： 12345678910111213// values/styles.xml&lt;!-- TabLayout 样式 --&gt; &lt;style name="TabLayoutStyle" parent="Widget.Design.TabLayout"&gt; &lt;item name="tabIndicatorColor"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="tabSelectedTextColor"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="tabTextAppearance"&gt;@style/TabTextAppearence&lt;/item&gt; &lt;item name="tabPaddingEnd"&gt;0dp&lt;/item&gt; &lt;/style&gt; &lt;style name="TabTextAppearence" parent="TextAppearance.Design.Tab"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; &lt;item name="textAllCaps"&gt;false&lt;/item&gt; &lt;/style&gt; 3. 创建 Fragment1234567891011121314151617181920212223242526272829303132333435363738package com.sherlockshi.badgedtablayoutpractise;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;/** * Author: SherlockShi * Date: 2016-11-01 16:31 * Description: */public class PageFragment extends Fragment &#123; private static final String PAGE_NAME_KEY = "PAGE_NAME_KEY"; public static PageFragment getInstance(String pageName) &#123; Bundle args = new Bundle(); args.putString(PAGE_NAME_KEY, pageName); PageFragment pageFragment = new PageFragment(); pageFragment.setArguments(args); return pageFragment; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_page, container, false); TextView textView = (TextView) view.findViewById(R.id.tv_page_name); textView.setText(getArguments().getString(PAGE_NAME_KEY)); return view; &#125;&#125; 其中 Fragment 的布局： 123456789// layout/fragment_page.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/tv_page_name" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center"/&gt; 4. ViewPager 的适配器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.sherlockshi.badgedtablayoutpractise;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import java.util.List;/** * Author: SherlockShi * Date: 2016-11-01 17:38 * Description: */public class SimpleFragmentPagerAdapter extends FragmentPagerAdapter &#123; private Context mContext; private List&lt;Fragment&gt; mFragmentList; private List&lt;String&gt; mPageTitleList; private List&lt;Integer&gt; mBadgeCountList; public SimpleFragmentPagerAdapter(Context context, FragmentManager fm, List&lt;Fragment&gt; fragmentList, List&lt;String&gt; pageTitleList, List&lt;Integer&gt; badgeCountList) &#123; super(fm); this.mContext = context; this.mFragmentList = fragmentList; this.mPageTitleList = pageTitleList; this.mBadgeCountList = badgeCountList; &#125; @Override public Fragment getItem(int position) &#123; return mFragmentList.get(position); &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mPageTitleList.get(position); &#125;&#125; 5. 设置 TabLayout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.sherlockshi.badgedtablayoutpractise;import android.os.Bundle;import android.support.design.widget.TabLayout;import android.support.v4.app.Fragment;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private List&lt;String&gt; mPageTitleList = new ArrayList&lt;String&gt;(); private List&lt;Fragment&gt; mFragmentList = new ArrayList&lt;Fragment&gt;(); private List&lt;Integer&gt; mBadgeCountList = new ArrayList&lt;Integer&gt;(); private SimpleFragmentPagerAdapter mPagerAdapter; private TabLayout mTabLayout; private ViewPager mViewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFragments(); initView(); &#125; private void initFragments() &#123; mPageTitleList.add("Tab1"); mPageTitleList.add("Tab2"); mPageTitleList.add("Tab3"); mBadgeCountList.add(6); mBadgeCountList.add(16); mBadgeCountList.add(166); for (int i = 0; i &lt; mPageTitleList.size(); i++) &#123; mFragmentList.add(PageFragment.getInstance(mPageTitleList.get(i))); &#125; &#125; private void initView() &#123; mTabLayout = (TabLayout) findViewById(R.id.tab_layout); mViewPager = (ViewPager) findViewById(R.id.view_pager); mPagerAdapter = new SimpleFragmentPagerAdapter(getSupportFragmentManager(), mFragmentList, mPageTitleList); mViewPager.setAdapter(mPagerAdapter); mTabLayout.setupWithViewPager(mViewPager); initBadgeViews(); setUpTabBadge(); &#125;&#125; 四、设置角标1. 添加角标 Badge添加角标的关键代码只需要一行： 1mBadgeViews.get(i).setTargetView(((ViewGroup) mTabLayout.getChildAt(0)).getChildAt(i)); 完整代码只需要在设置完 TabLayout 和 ViewPager 后，遍历每一个 Tab，为 Tab 添加角标： 123456private void setUpTabBadge() &#123; for (int i = 0; i &lt; mFragmentList.size(); i++) &#123; mBadgeViews.get(i).setTargetView(((ViewGroup) mTabLayout.getChildAt(0)).getChildAt(i)); mBadgeViews.get(i).setText(formatBadgeNumber(mBadgeCountList.get(i))); &#125;&#125; 2. 更新角标在需要更新角标的地方，只要调用以下方法就可实现： 12mBadgeCountList.set(1, count++);setUpTabBadge(); 以上，就可以轻松地为 TabLayout 添加角标，并处理角标的更新了。 五、问题1. 重复选中的状态但是如果需要更新角标，那么在更新角标后，再点击另一个 Tab，会出现上一个Tab和当前Tab都是选中状态（如下图的 Tab1 和 Tab2）： 2. 角标位置不可控而且如上图所示，角标的位置不好控制，有的离文字很近，有的离得很远，无法精确控制。 六、最实用的 TabLayout 加角标方法1. 添加 getTabItemView() 方法在重写的 FragmentPagerAdapter 中添加自定义 Tab 布局方法： 123456789101112131415public View getTabItemView(int position) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.tab_layout_item, null); TextView textView = (TextView) view.findViewById(R.id.textview); textView.setText(mPageTitleList.get(position)); View target = view.findViewById(R.id.badgeview_target); BadgeView badgeView = new BadgeView(mContext); badgeView.setTargetView(target); badgeView.setBadgeMargin(0, 6, 10, 0); badgeView.setTextSize(10); badgeView.setText(formatBadgeNumber(mBadgeCountList.get(position))); return view;&#125; 对应的自定义布局为： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;!-- LinearLayout 的 Height 必须为 wrap_content,如果为 match_parent,那么在第二次加载 Badge 的时候,Tab 布局会出现问题 --&gt; &lt;View android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;TextView android:id="@+id/textview" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="-30dp" android:textColor="@color/tab_text_color_selector"/&gt; &lt;View android:id="@+id/badgeview_target" android:layout_width="0dp" android:layout_weight="1" android:layout_height="40dp" android:layout_marginLeft="4dp" android:layout_gravity="center"/&gt;&lt;/LinearLayout&gt; 2. 设置自定义布局1234567891011121314151617181920private void setUpTabBadge() &#123; for (int i = 0; i &lt; mFragmentList.size(); i++) &#123; TabLayout.Tab tab = mTabLayout.getTabAt(i); // 更新 Badge 前,先 remove 原来的 customView,否则 Badge 无法更新 View customView = tab.getCustomView(); if (customView != null) &#123; ViewParent parent = customView.getParent(); if (parent != null) &#123; ((ViewGroup) parent).removeView(customView); &#125; &#125; // 更新 CustomView tab.setCustomView(mPagerAdapter.getTabItemView(i)); &#125; // 需加上以下代码,不然会出现更新 Tab 角标后,选中的 Tab 字体颜色不是选中状态的颜色 mTabLayout.getTabAt(mTabLayout.getSelectedTabPosition()).getCustomView().setSelected(true);&#125; 上面的示例会有两个坑： 一个坑是每次为 TabLayout 添加 Badge 后，会出现 Tab 的字体颜色不是选中状态的颜色，需要手动设置 Tab 为选中状态，可以参考上面的第 19 行代码解决，这应该是 TabLayout 的一个 Bug； 另一个坑是如果每次更新 Badge 的时候，直接重新 tab.setCustomView 的话，会出现 Badge 不更新，解决办法是先移除之前的自定义布局，然后再重新设置布局，具体可参考第 6-12 行代码解决。 七、总结以上是自己在使用 TabLayout 的过程中发现的一些问题及解决办法，如果大家有更好的解决方法，或者还有别的坑，欢迎留言。 当然，大家也可以直接使用第三方控件来实现以上功能，现在主流的几个控件也都做得很好，也很省心。 项目代码已共享到 Github：BadgedTabLayoutPractise 八、参考资料android design library 提供的 TabLayout的用法 Google Play Style Tabs using TabLayout Android Tablayout tabs with notification badge like whatsApp PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TabLayout</tag>
        <tag>角标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 系统下 STF 的环境搭建和运行]]></title>
    <url>%2Fenvironment-setup-and-operation-of-STF-under-MacOS.html</url>
    <content type="text"><![CDATA[本文参考以下文章整理：MAC 下 STF 的环境搭建和运行 一、 前言STF，全称是Smartphone Test Farm，WEB 端批量移动设备管理控制工具，就是可以用浏览器来批量控制你的移动设备，目前只支持Android设备。 二、环境搭建1. 安装xcode和xcode 命令行工具（安装Macport需要） Xcode：直接在App Store下载安装 Xcode Command Line Tools：在terminal中输入以下命令，然后在弹出的安装步骤中猛点下一步自动安装。 1xcode-select --install 2. 安装Macport，后面需要用到port参考：http://www.ccvita.com/434.html 1.1 直接到官网下载安装包进行安装http://www.macports.org/install.php 1.2 添加环境变量将/opt/local/bin和/opt/local/sbin添加到$PATH搜索路径中： 1vi ~/.bash_profile 在文件中加入： 12export PATH=/opt/local/bin:$PATHexport PATH=/opt/local/sbin:$PATH 更新环境变量： 1source ~/.bash_profile 1.3 更新ports tree和MacPorts版本强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。 1sudo port -v selfupdate 3. linux的基本包安装Mac之前有类似环境忽略。 4. SDK环境安装这里不做详细说明估计都有 Java android 留意安装完成后配置环境变量 5. nodejs安装 https://nodejs.org/en/ 验证： 1node -v 6. 安装bower1sudo npm install bower -g 验证： 1bower -v 7. 安装rethinkdb（这里建议通过pgk安装） https://www.rethinkdb.com/docs/install/ 验证： 1rethinkdb -v 8. 安装graphicsmagick1sudo port install graphicsmagick 9. 安装libsodium（zeromq的依赖）1sudo port install libsodium 10. 安装zeromp1sudo port install zmq 11. 安装protobuf1sudo port install protobuf-cpp 不用理会环境变量 12. 安装pkg-config1sudo port install pkgconfig 13. 安装stf1sudo npm install -g stf 时间应该是看网速，原文中备注会很长，但是我这边很快就安装完成了。 三、运行1. 运行stf1.1 启动rethinkdb在终端中输入以下命令，这时访问浏览器就可以看到rethinkdb的管理界面： http://localhost:8080/ 1rethinkdb 成功则会显示下面提示： 这时候访问浏览器可以看到RethinkDB启动好了： 1.2 启动stf（需新建终端） 1stf local --public-ip 本机IP --allow-remote 如： 1stf local --public-ip 192.168.1.102 --allow-remote 其中--allow-remote表示允许远程访问。 成功则会显示下面提示，如果已经连接手机，还会有手机信息： 注：官方文档中给的例子实际测试无法访问：stf local 2. 运行客户端 浏览器输入http://localhost:7100/，只要填入符合规则的登录信息即可： 成功，可以实现远程操作啦！ 四、效果图 五、其它系统1. Linux类系统Linux类的操作系统，如Ubuntu，可参考WEB 端批量移动设备管理控制工具 STF 的环境搭建和运行进行搭建。 2. WindowsWindows下直接安装据说相当麻烦，有很多坑，比较常见的做法是使用虚拟机（如docker）虚拟出一个Linux系统，然后参考上一步的搭建方法进行搭建。 六、使用1. 远程控制搭建好环境之后，这就是一台连接着N台Android手机的服务器了（这个服务器可能是放在你们公司某个神秘的地方，一般称为无线实验室），在上图的手机控制界面可以看到： 这时候，在你自己的电脑上（客户端），通过命令行输入adb connect 192.168.1.102:7401，就可以将自己的电脑连接到远程服务器上的手机真机，就好像手机是连接在自己电脑上一样，你可以在Android Studio中Android Device Monitor上看到手机硬件，可以直接打断点debug。 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>STF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之8_nest]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B8_nest.html</url>
    <content type="text"><![CDATA[一、描述将一个Observable转换为一个发射这个Observable的Observable。 当和 嵌套的 Observable 打交道的时候，就要使用 nest 函数了。nest 函数把一个普通的非 嵌套 Observable 变为一个嵌套的 Observable。 nest 把一个源 Observable 变为一个嵌套的 Observable 发射出去就结束了。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233Observable.just(1, 2, 3, 4) .nest() .subscribe(new Subscriber&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Observable&lt;Integer&gt; observable) &#123; observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted(inner)."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError(inner): " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); &#125; &#125;); 四、运行结果12345onNext: 1onNext: 2onNext: 3onNext: 4onCompleted. 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之7_toSortedList]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B7_toSortedList.html</url>
    <content type="text"><![CDATA[一、描述toSortedList类似于toList，不同的是，它会对产生的列表排序，默认是自然升序，如果发射的数据项没有实现Comparable接口，会抛出一个异常。 然而，你也可以传递一个函数作为用于比较两个数据项，这是toSortedList不会使用Comparable接口。 toSortedList默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(5, 2, 7, 3) .toSortedList() .subscribe(new Subscriber&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; System.out.println("onNext: " + integers); &#125; &#125;); 四、运行结果12onNext: [2, 3, 5, 7]onCompleted. 五、更多toSortedList操作符还有以下变体： toSortedList() toSortedList(Func2) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之6_toMultimap]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B6_toMultiMap.html</url>
    <content type="text"><![CDATA[一、描述toMultiMap类似于toMap，不同的是，它生成的这个Map同时还是一个ArrayList（默认是这样，你可以传递一个可选的工厂方法修改这个行为）。 toMultiMap默认不在任何特定的调度器上执行。 二、示意图 三、示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Student &#123; private int id; private String name; public Student(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125;&#125;Student stu1 = new Student(1001, "ZhangSan");Student stu2 = new Student(1002, "LiSi");Observable.just(stu1, stu2) .toMultimap(new Func1&lt;Student, Integer&gt;() &#123; @Override public Integer call(Student student) &#123; return student.getId(); &#125; &#125;) .subscribe(new Subscriber&lt;Map&lt;Integer, Collection&lt;Student&gt;&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Map&lt;Integer, Collection&lt;Student&gt;&gt; map) &#123; System.out.println("onNext: " + map.toString()); &#125;&#125;); 四、运行结果12onNext: onNext: &#123;1002=[Student&#123;id=1002, name='LiSi'&#125;], 1001=[Student&#123;id=1001, name='ZhangSan'&#125;]&#125;onCompleted. toMap(Func1)将原Observable发送的数据保存到一个MAP中，并在参数函数中，设定sutdent的id属性作为key。但toMultimap操作符在将数据保存到MAP前，先将数据保存到Collection，而toMap操作符将数据直接保存到MAP中，并没有再包裹一层Collection。 五、更多toMultimap操作符还有以下变体： toMultiMap(Func1) toMultiMap(Func1,Func1) toMultiMap(Func1,Func1,Func0) toMultiMap(Func1,Func1,Func0,Func1) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之5_toMap]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B5_toMap.html</url>
    <content type="text"><![CDATA[一、描述toMap收集原始Observable发射的所有数据项到一个Map（默认是HashMap）然后发射这个Map。 你可以提供一个用于生成Map的Key的函数，还可以提供一个函数转换数据项到Map存储的值（默认数据项本身就是值）。 toMap默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Student &#123; private int id; private String name; public Student(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125;&#125;Student stu1 = new Student(1001, "ZhangSan");Student stu2 = new Student(1002, "LiSi");Observable.just(stu1, stu2).toMap(new Func1&lt;Student, Integer&gt;() &#123; @Override public Integer call(Student student) &#123; return student.getId(); &#125;&#125;).subscribe(new Subscriber&lt;Map&lt;Integer, Student&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Map&lt;Integer, Student&gt; map) &#123; System.out.println("onNext: " + map.toString()); &#125;&#125;); 四、运行结果12onNext: &#123;1002=Student&#123;id=1002, name='LiSi'&#125;, 1001=Student&#123;id=1001, name='ZhangSan'&#125;&#125;onCompleted. toMap(Func1)将原Observable发送的数据保存到一个MAP中，并在参数函数中，设定sutdent的id属性作为key。 五、更多toMap操作符还有以下变体： toMap(Func1) toMap(Func1,Func1) toMap(Func1,Func1,Func0) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之4_toList]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B4_toList.html</url>
    <content type="text"><![CDATA[一、描述这个操作符让Observable将多项数据组合成一个List，然后调用一次onNext方法传递整个列表。 通常，发射多项数据的Observable会为每一项数据调用onNext方法。你可以用toList操作符改变这个行为，让Observable将多项数据组合成一个List，然后调用一次onNext方法传递整个列表。 如果原始Observable没有发射任何数据就调用了onCompleted，toList返回的Observable会在调用onCompleted之前发射一个空列表。如果原始Observable调用了onError，toList返回的Observable会立即调用它的观察者的onError方法。 toList默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617Observable.just(1, 2, 3, 4).toList() .subscribe(new Subscriber&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; System.out.println("onNext: " + integers); &#125; &#125;); 四、运行结果12onNext: [1, 2, 3, 4]onCompleted. 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之3_toIterable]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B3_toIterable.html</url>
    <content type="text"><![CDATA[一、描述这个操作符将Observable转换为一个Iterable，你可以通过它迭代原始Observable发射的数据集。 二、示意图 三、示例代码12345Iterable&lt;Integer&gt; iterable = Observable.just(1,2, 3, 4).toBlocking().toIterable();for (Integer i : iterable) &#123; System.out.println("Data: " + i);&#125; 四、运行结果1234Data: 1Data: 2Data: 3Data: 4 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之2_toFuture]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B2_toFuture.html</url>
    <content type="text"><![CDATA[一、描述这个操作符将Observable转换为一个返回单个数据项的Future。 toFuture操作符也是只能用于BlockingObservable。这个操作符将Observable转换为一个返回单个数据项的Future，如果原始Observable发射多个数据项，Future会收到一个IllegalArgumentException；如果原始Observable没有发射任何数据，Future会收到一个NoSuchElementException。 如果你想将发射多个数据项的Observable转换为Future，可以这样用：myObservable.toList().toBlocking().toFuture()。 二、示意图 三、示例代码12345678910111213Future future = Observable.just(1).toBlocking().toFuture();try &#123; System.out.println("Data: " + future.get());&#125; catch (NoSuchElementException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (IllegalArgumentException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (InterruptedException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (ExecutionException e) &#123; System.out.println("Error: " + e.getCause());&#125; 四、运行结果1Data: 1 五、更多1. 发射多个数据项(异常处理)12345678910111213Future future = Observable.just(1, 2, 3, 4, 5).toBlocking().toFuture();try &#123; System.out.println("Data: " + future.get());&#125; catch (NoSuchElementException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (IllegalArgumentException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (InterruptedException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (ExecutionException e) &#123; System.out.println("Error: " + e.getCause());&#125; 运行结果1Error: java.lang.IllegalArgumentException: Sequence contains too many elements 可见当原始Observable发射多个数据项，Future会收到一个IllegalArgumentException。 2. 发射多个数据项(正确处理)如果你想将发射多个数据项的Observable转换为Future，可以这样用：myObservable.toList().toBlocking().toFuture()。 12345678910111213Future future = Observable.just(1, 2, 3, 4, 5).toList().toBlocking().toFuture();try &#123; System.out.println("Data: " + future.get());&#125; catch (NoSuchElementException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (IllegalArgumentException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (InterruptedException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (ExecutionException e) &#123; System.out.println("Error: " + e.getCause());&#125; 运行结果1Data: [1, 2, 3, 4, 5] 3. 不发射任何数据12345678910111213Future future = Observable.empty().toBlocking().toFuture();try &#123; System.out.println("Data: " + future.get());&#125; catch (NoSuchElementException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (IllegalArgumentException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (InterruptedException e) &#123; System.out.println("Error: " + e.getCause());&#125; catch (ExecutionException e) &#123; System.out.println("Error: " + e.getCause());&#125; 运行结果1Error: java.util.NoSuchElementException: Sequence contains no elements 可见原始Observable没有发射任何数据，Future会收到一个NoSuchElementException。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：11_转换操作之1_getIterator]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A11_%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B1_getIterator.html</url>
    <content type="text"><![CDATA[一、描述这个操作符将Observable转换为一个Iterator，你可以通过它迭代原始Observable发射的数据集。 getIterator操作符只能用于BlockingObservable的子类，要使用它，你首先必须把原始的Observable转换为一个BlockingObservable。可以使用这两个操作符：BlockingObservable.from或the Observable.toBlocking。 二、示意图 三、示例代码1234Iterator&lt;Integer&gt; iterator = Observable.just(1, 2, 3, 4, 5).toBlocking().getIterator();while (iterator.hasNext()) &#123; System.out.println("Data: " + iterator.next());&#125; 四、运行结果12345Data: 1Data: 2Data: 3Data: 4Data: 5 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：10_连接操作之4_refCount]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A10_%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E4%B9%8B4_refCount.html</url>
    <content type="text"><![CDATA[一、描述让一个可连接的Observable行为像普通的Observable。 可连接的Observable (connectable Observable)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了Connect操作符时才会开始。用这种方法，你可以在任何时候让一个Observable开始发射数据。 RefCount操作符把从一个可连接的Observable连接和断开的过程自动化了。它操作一个可连接的Observable，返回一个普通的Observable。当第一个订阅者订阅这个Observable时，RefCount连接到下层的可连接Observable。RefCount跟踪有多少个观察者订阅它，直到最后一个观察者完成才断开与下层可连接Observable的连接。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677System.out.println("&lt;========before refCount()=======&gt;");ConnectableObservable connectableObservable = Observable.range(1, 50000).sample(10, TimeUnit.MILLISECONDS).publish();connectableObservable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted1."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError1: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext1: " + integer); &#125;&#125;);connectableObservable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted2."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError2: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext2: " + integer); &#125;&#125;);connectableObservable.connect();System.out.println("&lt;========after refCount()=======&gt;");Observable observable = connectableObservable.refCount();observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted3."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError3: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext3: " + integer); &#125;&#125;);observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted4."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError4: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext4: " + integer); &#125;&#125;); 四、运行结果12345678910111213141516171819202122&lt;========before refCount()=======&gt;onNext1: 11653onNext2: 11653onNext1: 21317onNext2: 21317onNext1: 32731onNext2: 32731onNext1: 40808onNext2: 40808onCompleted1.onCompleted2.&lt;========after refCount()=======&gt;onNext3: 15517onNext3: 30592onNext3: 45208onCompleted3.onNext4: 16052onNext4: 16090onNext4: 20936onNext4: 31274onNext4: 47841onCompleted4. 由运行结果可以看出，RefCount操作符将一个Connectable Observable 对象重新转化为一个普通的Observable对象，这时候订阅者进行订阅将会触发数据的发射。 五、更多refCount操作符还有以下变体： share() 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：10_连接操作之3_replay]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A10_%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E4%B9%8B3_replay.html</url>
    <content type="text"><![CDATA[一、描述保证所有的观察者收到相同的数据序列，即使它们在Observable开始发射数据之后才订阅。 可连接的Observable (connectable Observable)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了Connect操作符时才会开始。用这种方法，你可以在任何时候让一个Observable开始发射数据。 如果在将一个Observable转换为可连接的Observable之前对它使用Replay操作符，产生的这个可连接Observable将总是发射完整的数据序列给任何未来的观察者，即使那些观察者在这个Observable开始给其它观察者发射数据之后才订阅。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839404142final ConnectableObservable observable = Observable.range(1, 6).replay();final Subscriber subscriber2 = new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted2."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError2: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext2: " + integer); &#125;&#125;;Subscriber subscriber1 = new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted1."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError1: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; if (integer == 3) &#123; observable.subscribe(subscriber2); &#125; System.out.println("onNext1: " + integer); &#125;&#125;;observable.subscribe(subscriber1);observable.connect(); 四、运行结果1234567891011121314onNext1: 1onNext1: 2onNext2: 1onNext2: 2onNext2: 3onNext1: 3onNext1: 4onNext2: 4onNext1: 5onNext2: 5onNext1: 6onNext2: 6onCompleted1.onCompleted2. Replay操作符返回一个Connectable Observable 对象并且可以缓存其发射过的数据，这样即使有订阅者在其发射数据之后进行订阅也能收到其之前发射过的数据。不过使用Replay操作符我们最好还是限定其缓存的大小，否则缓存的数据太多了可会占用很大的一块内存。对缓存的控制可以从空间和时间两个方面来实现。 五、更多replay操作符还有以下变体： replay() replay(int) replay(long,TimeUnit) replay(int,long,TimeUnit) replay(Func1) replay(Func1,int) replay(Func1,long,TimeUnit) replay(Func1,int,long,TimeUnit) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：10_连接操作之2_publish]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A10_%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E4%B9%8B2_publish.html</url>
    <content type="text"><![CDATA[一、描述将普通的Observable转换为可连接的Observable。 可连接的Observable (connectable Observable)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了Connect操作符时才会开始。用这种方法，你可以在任何时候让一个Observable开始发射数据。 有一个变体接受一个函数作为参数。这个函数用原始Observable发射的数据作为参数，产生一个新的数据作为ConnectableObservable给发射，替换原位置的数据项。实质是在签名的基础上添加一个Map操作。 二、示意图 三、示例代码1. 未使用publish操作符时123456789101112131415161718192021222324252627282930313233343536Observable observable = Observable.range(1, 1000000) .sample(10, TimeUnit.MILLISECONDS);observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted1."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError1: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext1: " + integer); &#125;&#125;);observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted2."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError2: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext2: " + integer); &#125;&#125;); 2. 运行结果12345678910onNext1: 15281onNext1: 40401...onNext1: 983620onCompleted1.onNext2: 25895onNext2: 48456...onNext2: 983356onCompleted2. 可见Observable在订阅的时候就开始发射数据，导致两个观察者收到的数据是不一样的。 3. 使用publish操作符后12345678910111213141516171819202122232425262728293031323334353637ConnectableObservable observable = Observable.range(1, 1000000).sample(10, TimeUnit.MILLISECONDS).publish();observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted1."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError1: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext1: " + integer); &#125;&#125;);observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted2."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError2: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext2: " + integer); &#125;&#125;);observable.connect(); 四、运行结果123456789onNext1: 20491onNext2: 20491onNext1: 39191onNext2: 39191...onNext1: 997372onNext2: 997372onCompleted1.onCompleted2. 可见在订阅的时候，并不会开始发射数据，只有等到connect连接后，才开始发射数据，所以两个观察者接收到的数据是一样的。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：10_连接操作之1_connect]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A10_%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E4%B9%8B1_connect.html</url>
    <content type="text"><![CDATA[一、描述让一个可连接的Observable开始发射数据给订阅者。 可连接的Observable (connectable Observable)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了Connect操作符时才会开始。用这个方法，你可以等待所有的观察者都订阅了Observable之后再开始发射数据。 RxJava中connect是ConnectableObservable接口的一个方法，使用publish操作符可以将一个普通的Observable转换为一个ConnectableObservable。 调用ConnectableObservable的connect方法会让它后面的Observable开始给发射数据给订阅者。 connect方法返回一个Subscription对象，可以调用它的unsubscribe方法让Observable停止发射数据给观察者。 即使没有任何订阅者订阅它，你也可以使用connect方法让一个Observable开始发射数据（或者开始生成待发射的数据）。这样，你可以将一个”冷”的Observable变为”热”的。 二、示意图 三、示例代码1. 未使用connect操作符时123456789101112131415161718192021222324252627282930313233343536Observable observable = Observable.range(1, 1000000) .sample(10, TimeUnit.MILLISECONDS);observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted1."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError1: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext1: " + integer); &#125;&#125;);observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted2."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError2: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext2: " + integer); &#125;&#125;); 2. 运行结果12345678910onNext1: 15281onNext1: 40401...onNext1: 983620onCompleted1.onNext2: 25895onNext2: 48456...onNext2: 983356onCompleted2. 可见Observable在订阅的时候就开始发射数据，导致两个观察者收到的数据是不一样的。 3. 使用connect操作符后12345678910111213141516171819202122232425262728293031323334353637ConnectableObservable observable = Observable.range(1, 1000000).sample(10, TimeUnit.MILLISECONDS).publish();observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted1."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError1: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext1: " + integer); &#125;&#125;);observable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted2."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError2: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext2: " + integer); &#125;&#125;);observable.connect(); 四、运行结果123456789onNext1: 20491onNext2: 20491onNext1: 39191onNext2: 39191...onNext1: 997372onNext2: 997372onCompleted1.onCompleted2. 可见在订阅的时候，并不会开始发射数据，只有等到connect连接后，才开始发射数据，所以两个观察者接收到的数据是一样的。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：9_反压操作之3_onBackpressureLatest]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A9_%E5%8F%8D%E5%8E%8B%E6%93%8D%E4%BD%9C%E4%B9%8B3_onBackpressureLatest.html</url>
    <content type="text"><![CDATA[一、描述当Observable发出的元素的速度比订阅者消化得要快,订阅者会接收Observable最新发出的item进行处理。 二、示意图 三、示例代码123456789101112131415161718192021222324Observable.interval(1, TimeUnit.MILLISECONDS) .onBackpressureLatest() .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 四、运行结果12345678910onNext: 0onNext: 1onNext: 2...onNext: 15onNext: 1607onNext: 1608...onNext: 1622... 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 RxJava 教程第四部分：并发 之数据流发射太快如何办 RxJava中backpressure这个概念的理解 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：9_反压操作之2_onBackpressureDrop]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A9_%E5%8F%8D%E5%8E%8B%E6%93%8D%E4%BD%9C%E4%B9%8B2_onBackpressureDrop.html</url>
    <content type="text"><![CDATA[一、描述如果消费者无法处理数据，则 onBackpressureDrop 就把该数据丢弃了。 二、示意图 三、示例代码123456789101112131415161718192021222324Observable.interval(1, TimeUnit.MILLISECONDS) .onBackpressureDrop() .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 四、运行结果12345678910onNext: 0onNext: 1onNext: 2...onNext: 15onNext: 1608onNext: 1609...onNext: 1623... 由运行结果可以看出，前面 16 个数据正常的被处理的，这是应为 observeOn 在切换线程的时候， 使用了一个 16 个数据的小缓冲。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 RxJava 教程第四部分：并发 之数据流发射太快如何办 RxJava中backpressure这个概念的理解 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：9_反压操作之1_onBackpressureBuffer]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A9_%E5%8F%8D%E5%8E%8B%E6%93%8D%E4%BD%9C%E4%B9%8B1_onBackpressureBuffer.html</url>
    <content type="text"><![CDATA[一、描述onBackpressureBuffer 会缓存所有当前无法消费的数据，直到 Observer 可以处理为止。 你可以指定缓冲的数量，如果缓冲满了则会导致数据流失败。 二、示意图 三、示例代码123456789101112131415161718192021222324Observable.interval(1, TimeUnit.MILLISECONDS) .onBackpressureBuffer(1000) .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 四、运行结果123456789101112onNext: 0onNext: 1onNext: 2onNext: 3onNext: 4onNext: 5onNext: 6onNext: 7onNext: 8onNext: 9onNext: 10onError: Overflowed buffer of 1000 由运行结果可以看出，生产者比消费者快 100 倍。使用 1000个缓冲来处理这种消费者比较慢的情况。当消费者消费 11个数据的时候，缓冲区满了，生产者生产了 1100个数据，数据流就抛出异常了。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 RxJava 教程第四部分：并发 之数据流发射太快如何办 RxJava中backpressure这个概念的理解 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：8_算术和聚合操作之7_reduce]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A8_%E7%AE%97%E6%9C%AF%E5%92%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B7_reduce.html</url>
    <content type="text"><![CDATA[一、描述按顺序对Observable发射的每项数据应用一个函数并发射最终的值。 Reduce操作符对原始Observable发射数据的第一项应用一个函数，然后再将这个函数的返回值与第二项数据一起传递给函数，以此类推，持续这个过程知道原始Observable发射它的最后一项数据并终止，此时Reduce返回的Observable发射这个函数返回的最终值。 在其它场景中，这种操作有时被称为累积，聚集，压缩，折叠，注射等。 注意如果原始Observable没有发射任何数据，reduce抛出异常IllegalArgumentException。 reduce默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4) .reduce(new Func2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer1, Integer integer2) &#123; return integer1 + integer2; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 10onCompleted. 五、更多reduce操作符还有以下变体： reduce(R,Func2) 跟reduce相关的操作符还有： collect(Func0,Action2) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：8_算术和聚合操作之6_count]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A8_%E7%AE%97%E6%9C%AF%E5%92%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B6_count.html</url>
    <content type="text"><![CDATA[一、描述计算原始Observable发射物的数量，然后只发射这个值。 Count操作符将一个Observable转换成一个发射单个值的Observable，这个值表示原始Observable发射的数据的数量。 如果原始Observable发生错误终止，Count不发射数据而是直接传递错误通知。如果原始Observable永远不终止，Count既不会发射数据也不会终止。 RxJava的实现是count和countLong。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4) .count() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 4onCompleted. 五、更多count操作符还有以下变体： countLong() 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：8_算术和聚合操作之5_concat]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A8_%E7%AE%97%E6%9C%AF%E5%92%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B5_concat.html</url>
    <content type="text"><![CDATA[一、描述不交错的发射两个或多个Observable的发射物。 Concat操作符连接多个Observable的输出，就好像它们是一个Observable，第一个Observable发射的所有数据在第二个Observable发射的任何数据前面，以此类推。 直到前面一个Observable终止，Concat才会订阅额外的一个Observable。注意：因此，如果你尝试连接一个”热”Observable（这种Observable在创建后立即开始发射数据，即使没有订阅者），Concat将不会看到也不会发射它之前发射的任何数据。 在ReactiveX的某些实现中有一种ConcatMap操作符（名字可能叫concat_all, concat_map, concatMapObserver, for, forIn/for_in, mapcat, selectConcat或selectConcatObserver），他会变换原始Observable发射的数据到一个对应的Observable，然后再按观察和变换的顺序进行连接操作。 StartWith操作符类似于Concat，但是它是插入到前面，而不是追加那些Observable的数据到原始Observable发射的数据序列。 Merge操作符也差不多，它结合两个或多个Observable的发射物，但是数据可能交错，而Concat不会让多个Observable的发射物交错。 二、示意图 三、示例代码123456789101112131415161718192021222324Observable observable1 = Observable.interval(1000, TimeUnit.MILLISECONDS, Schedulers.newThread()).take(2);Observable observable2 = Observable.interval(500, 1000, TimeUnit.MILLISECONDS, Schedulers.newThread()).take(2);Observable.concat(observable1, observable2) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); &#125; &#125;); 四、运行结果12345onNext: 0onNext: 1onNext: 0onNext: 1onCompleted. 五、更多跟concat相关的操作符还有： concatWith 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：8_算术和聚合操作之4_sum]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A8_%E7%AE%97%E6%9C%AF%E5%92%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B4_sum.html</url>
    <content type="text"><![CDATA[一、描述计算Observable发射的数值的和并发射这个和。 Sum操作符操作一个发射数值的Observable，仅发射单个值：原始Observable所有数值的和。 RxJava的实现是sumDouble, sumFloat, sumInteger, sumLong，它们不是RxJava核心模块的一部分，属于rxjava-math模块。 二、示意图 三、示例代码由于max操作符是属于可选的rxjava-math模块的，所以需要加入下面的依赖： 1compile 'io.reactivex:rxjava-math:1.0.0' 1234567891011121314151617MathObservable.sumInteger(Observable.just(1, 2, 3, 4)) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 10onCompleted. 五、更多跟sum相关的操作符还有： stringConcat join 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：8_算术和聚合操作之3_min]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A8_%E7%AE%97%E6%9C%AF%E5%92%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B3_min.html</url>
    <content type="text"><![CDATA[一、描述发射原始Observable的最小值。 Min操作符操作一个发射数值的Observable并发射单个值：最小的那个值。 RxJava中，min属于rxjava-math模块。 min接受一个可选参数，用于比较两项数据的大小，如果最小值的数据超过一项，min会发射原始Observable最近发射的那一项。 minBy类似于min，但是它发射的不是最小值，而是发射Key最小的项，Key由你指定的一个函数生成。 二、示意图 三、示例代码由于max操作符是属于可选的rxjava-math模块的，所以需要加入下面的依赖： 1compile 'io.reactivex:rxjava-math:1.0.0' 1234567891011121314151617MathObservable.min(Observable.just(10, 6, 23, 9)) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 6onCompleted. 五、更多跟min相关的操作符还有： minBy 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：8_算术和聚合操作之2_max]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A8_%E7%AE%97%E6%9C%AF%E5%92%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B2_max.html</url>
    <content type="text"><![CDATA[一、描述发射原始Observable的最大值。 Max操作符操作一个发射数值的Observable并发射单个值：最大的那个值。 RxJava中，max属于rxjava-math模块。 max接受一个可选参数，用于比较两项数据的大小，如果最大值的数据超过一项，max会发射原始Observable最近发射的那一项。 maxBy类似于max，但是它发射的不是最大值，而是发射Key最大的项，Key由你指定的一个函数生成。 二、示意图 三、示例代码由于max操作符是属于可选的rxjava-math模块的，所以需要加入下面的依赖： 1compile 'io.reactivex:rxjava-math:1.0.0' 1234567891011121314151617MathObservable.max(Observable.just(10, 6, 23, 9)) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 23onCompleted. 五、更多跟max相关的操作符还有： maxBy 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：8_算术和聚合操作之1_average]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A8_%E7%AE%97%E6%9C%AF%E5%92%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B1_average.html</url>
    <content type="text"><![CDATA[一、描述计算原始Observable发射数字的平均值并发射它。 Average操作符操作符一个发射数字的Observable，并发射单个值：原始Observable发射的数字序列的平均值。 这个操作符不包含在RxJava核心模块中，它属于不同的rxjava-math模块。它被实现为四个操作符：averageDouble, averageFloat, averageInteger, averageLong。 如果原始Observable不发射任何数据，这个操作符会抛异常：IllegalArgumentException。 二、示意图 三、示例代码由于average操作符是属于可选的rxjava-math模块的，所以需要加入下面的依赖： 1compile 'io.reactivex:rxjava-math:1.0.0' 1234567891011121314151617MathObservable.averageInteger(Observable.just(1, 2, 3, 4)) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 2onCompleted. 五、更多average操作符还有以下变体： averageInteger averageDouble averageFloat averageLong 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之9_sequenceEqual]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B9_sequenceEqual.html</url>
    <content type="text"><![CDATA[一、描述判定两个Observables是否发射相同的数据序列。 传递两个Observable给SequenceEqual操作符，它会比较两个Observable的发射物，如果两个序列是相同的（相同的数据，相同的顺序，相同的终止状态），它就发射true，否则发射false。 它还有一个版本接受第三个参数，可以传递一个函数用于比较两个数据项是否相同。 这个操作符默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920Observable observable1 = Observable.just(1, 2, 3, 4).delay(1000, TimeUnit.MILLISECONDS);Observable observable2 = Observable.just(1, 2, 3, 4).delay(2000, TimeUnit.MILLISECONDS);Observable.sequenceEqual(observable1, observable2) .subscribe(new Subscriber&lt;Boolean&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Boolean aBoolean) &#123; System.out.println("onNext: " + aBoolean); &#125; &#125;); 四、运行结果12onNext: trueonCompleted. 五、更多async操作符还有以下变体： sequenceEqual(Observable,Observable,Func2) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之8_contains]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B8_contains.html</url>
    <content type="text"><![CDATA[一、描述判定一个Observable是否发射一个特定的值。 给Contains传一个指定的值，如果原始Observable发射了那个值，它返回的Observable将发射true，否则发射false。 contains默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5) .contains(5) .subscribe(new Subscriber&lt;Boolean&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Boolean aBoolean) &#123; System.out.println("onNext: " + aBoolean); &#125; &#125;); 四、运行结果12onNext: trueonCompleted. 发射的数据里面包含5，符合判断条件，所以结果返回true。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之7_all]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B7_all.html</url>
    <content type="text"><![CDATA[一、描述判定是否Observable发射的所有数据都满足某个条件。 传递一个谓词函数给All操作符，这个函数接受原始Observable发射的数据，根据计算返回一个布尔值。All返回一个只发射一个单个布尔值的Observable，如果原始Observable正常终止并且每一项数据都满足条件，就返回true；如果原始Observable的任何一项数据不满足条件就返回False。 RxJava将这个操作符实现为all，它默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4, 5) .all(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer &lt; 10; &#125; &#125;) .subscribe(new Subscriber&lt;Boolean&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Boolean aBoolean) &#123; System.out.println("onNext: " + aBoolean); &#125; &#125;); 四、运行结果12onNext: trueonCompleted. 由于所有数据都小于10，符合判断条件，所以结果返回true。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之6_takeWhile]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B6_takeWhile.html</url>
    <content type="text"><![CDATA[一、描述发射Observable发射的数据，直到一个指定的条件不成立。 TakeWhile发射原始Observable，直到你指定的某个条件不成立的那一刻，它停止发射原始Observable，并终止自己的Observable。 RxJava中的takeWhile操作符返回一个镜像原始Observable行为的Observable，直到某一项数据你指定的函数返回false那一刻，这个新的Observable发射onCompleted终止通知。 takeWhile默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4, 5) .takeWhile(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer != 3; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果123onNext: 1onNext: 2onCompleted. 发射前2个数据的时候，1和2都符合判断条件，即不等于3，takeWhile正常将数据发射出去； 直到发射3的时候，判断条件不成立了，即3是等于3的； takeWhile才将后续的所有数据发射出来（3、4、5和完成事件）。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之5_takeUntil]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B5_takeUntil.html</url>
    <content type="text"><![CDATA[一、描述当第二个Observable发射了一项数据或者终止时，丢弃原始Observable发射的任何数据。 TakeUntil订阅并开始发射原始Observable，它还监视你提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，TakeUntil返回的Observable会停止发射原始Observable并终止。 RxJava中的实现是takeUntil。注意：第二个Observable发射一项数据或一个onError通知或一个onCompleted通知都会导致takeUntil停止发射数据。 takeUntil默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920Observable observable1 = Observable.interval(1000, TimeUnit.MILLISECONDS).take(5);Observable observable2 = Observable.just(1, 2).delay(2500, TimeUnit.MILLISECONDS);observable1.takeUntil(observable2) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); &#125; &#125;); 四、运行结果123onNext: 0onNext: 1onCompleted. observable1每隔1秒发一个数据（第1秒时发射0，第2秒时发射1），takeUntil正常把数据发射出来； 直到observable2在2.5秒的时候发射了第1个数据； takeUntil就停止发射数据了。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之4_skipWhile]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B4_skipWhile.html</url>
    <content type="text"><![CDATA[一、描述丢弃Observable发射的数据，直到一个指定的条件不成立。 SkipWhile订阅原始的Observable，但是忽略它的发射物，直到你指定的某个条件变为false的那一刻，它开始发射原始Observable。 skipWhile默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4, 5) .skipWhile(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer != 3; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234onNext: 3onNext: 4onNext: 5onCompleted. 发射前2个数据的时候，1和2都符合判断条件，即不等于3，skipWhile并不会将数据发射出去； 直到发射3的时候，判断条件不成立了，即3是等于3的； skipWhile才将后续的所有数据发射出来（3、4、5和完成事件）。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之3_skipUntil]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B3_skipUntil.html</url>
    <content type="text"><![CDATA[一、描述丢弃原始Observable发射的数据，直到第二个Observable发射了一项数据。 SkipUntil订阅原始的Observable，但是忽略它的发射物，直到第二个Observable发射了一项数据那一刻，它开始发射原始Observable。 RxJava中对应的是skipUntil，它默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920Observable observable1 = Observable.interval(1000, TimeUnit.MILLISECONDS).take(5);Observable observable2 = Observable.just(1, 2).delay(2500, TimeUnit.MILLISECONDS);observable1.skipUntil(observable2) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); &#125; &#125;); 四、运行结果1234onNext: 2onNext: 3onNext: 4onCompleted. observable1每隔1秒发一个数据（第1秒时发射0，第2秒时发射1），但是skipUntil并不会把数据发射出来； 直到observable2在2.5秒的时候发射了第1个数据； skipUntil才将observable1后续的所有数据发射出来（2、3、4和完成事件）。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之2_defaultIfEmpty]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B2_defaultIfEmpty.html</url>
    <content type="text"><![CDATA[一、描述发射来自原始Observable的值，如果原始Observable没有发射任何值，就发射一个默认值。 DefaultIfEmpty简单的精确地发射原始Observable的值，如果原始Observable没有发射任何数据正常终止（以onCompletedd的形式），DefaultIfEmpty返回的Observable就发射一个你提供的默认值。 RxJava将这个操作符实现为defaultIfEmpty。它默认不在任何特定的调度器上执行。 还有一个新的操作符switchIfEmpty，不在RxJava 1.0.0版中，它和defaultIfEmtpy类似，不同的是，如果原始Observable没有发射数据，它发射一个备用Observable的发射物。 二、示意图 三、示例代码123456789101112131415161718Observable.empty() .defaultIfEmpty(1) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println("onNext: " + o); &#125; &#125;); 四、运行结果12onNext: 1onCompleted. 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：7_条件和布尔操作之1_amb]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A7_%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E4%B9%8B1_amb.html</url>
    <content type="text"><![CDATA[一、描述给定两个或多个Observables，它只发射首先发射数据或通知的那个Observable的所有数据。 当你传递多个Observable给Amb时，它只发射其中一个Observable的数据和通知：首先发送通知给Amb的那个，不管发射的是一项数据还是一个onError或onCompleted通知。Amb将忽略和丢弃其它所有Observables的发射物。 RxJava的实现是amb，有一个类似的对象方法ambWith。例如，Observable.amb(o1,o2)和o1.ambWith(o2)是等价的。 这个操作符默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920Observable just1 = Observable.just(1, 2, 3).delay(1000, TimeUnit.MILLISECONDS);Observable just2 = Observable.just(11, 12, 13).delay(800, TimeUnit.MILLISECONDS);Observable.amb(just1, just2) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234onNext: 11onNext: 12onNext: 13onCompleted. 由运行结果可以看出，just2在800毫秒的时候，发射了第1个数据给Amb，Amb就只发射just2的数据，而忽略了其它Observable的数据。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之12_do]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B12_do.html</url>
    <content type="text"><![CDATA[一、描述注册一个动作作为原始Observable生命周期事件的一种占位符。 你可以注册回调，当Observable的某个事件发生时，Rx会在与Observable链关联的正常通知集合中调用它。Rx实现了多种操作符用于达到这个目的。 RxJava实现了很多Do操作符的变体。 doOnEach操作符让你可以注册一个回调，它产生的Observable每发射一项数据就会调用它一次。你可以以Action的形式传递参数给它，这个Action接受一个onNext的变体Notification作为它的唯一参数，你也可以传递一个Observable给doOnEach，这个Observable的onNext会被调用，就好像它订阅了原始的Observable一样。 二、示意图 三、示例代码1234567891011121314151617181920212223242526Observable.just(1, 2, 3) .doOnEach(new Action1&lt;Notification&lt;? super Integer&gt;&gt;() &#123; @Override public void call(Notification&lt;? super Integer&gt; notification) &#123; if (notification.getKind() == Notification.Kind.OnNext &amp;&amp; (Integer) notification.getValue() == 2) &#123; throw new RuntimeException("The value is 2!"); &#125; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 1onError: The value is 2! 五、更多do操作符还有以下变体： doOnEach(Action1) doOnEach(Observer) doOnNext doOnSubscribe doOnUnsubscribe doOnCompleted doOnError doOnTerminate finallyDo 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之11_using]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B11_using.html</url>
    <content type="text"><![CDATA[一、描述创建一个只在Observable生命周期内存在的一次性资源。 Using操作符让你可以指示Observable创建一个只在它的生命周期内存在的资源，当Observable终止时这个资源会被自动释放。 using操作符接受三个参数： 一个用户创建一次性资源的工厂函数 一个用于创建Observable的工厂函数 一个用于释放资源的函数 当一个观察者订阅using返回的Observable时，using将会使用Observable工厂函数创建观察者要观察的Observable，同时使用资源工厂函数创建一个你想要创建的资源。当观察者取消订阅这个Observable时，或者当观察者终止时（无论是正常终止还是因错误而终止），using使用第三个函数释放它创建的资源。 using默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Animal &#123; public Animal() &#123; System.out.println("Animal create."); &#125; public void release() &#123; System.out.println("Animal release."); &#125;&#125;Observable.using(new Func0&lt;Animal&gt;() &#123; @Override public Animal call() &#123; return new Animal(); &#125; &#125;, new Func1&lt;Animal, Observable&lt;?&gt;&gt;() &#123; @Override public Observable&lt;?&gt; call(Animal animal) &#123; return Observable.timer(5000, TimeUnit.MILLISECONDS); &#125; &#125;, new Action1&lt;Animal&gt;() &#123; @Override public void call(Animal animal) &#123; animal.release(); &#125; &#125;) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println("onNext: " + o); &#125; &#125;); 四、运行结果1234Animal create.onNext: 0onCompleted.Animal release. 从运行结果可以看出，经过5秒后，timer发射了一个数据项，Observable就终止了，using就使用第三个函数释放它创建的资源。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之10_timeout]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B10_timeout.html</url>
    <content type="text"><![CDATA[一、描述对原始Observable的一个镜像，如果过了一个指定的时长仍没有发射数据，它会发一个错误通知。 如果原始Observable过了指定的一段时长没有发射任何数据，Timeout操作符会以一个onError通知终止这个Observable。 RxJava中的实现为timeout，但是有好几个变体。 第一个变体接受一个时长参数，每当原始Observable发射了一项数据，timeout就启动一个计时器，如果计时器超过了指定指定的时长而原始Observable没有发射另一项数据，timeout就抛出TimeoutException，以一个错误通知终止Observable。 这个timeout默认在computation调度器上执行，你可以通过参数指定其它的调度器。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; for (int i = 1; i &lt; 4; i++) &#123; try &#123; Thread.sleep(100 * i); &#125; catch (InterruptedException e) &#123; subscriber.onError(e); &#125; subscriber.onNext(i); &#125; subscriber.onCompleted(); &#125;&#125;) .timeout(250, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果123onNext: 1onNext: 2onError: null 经过100毫秒后，发射1； 再经过200毫秒后，发射2； 然后再经过250毫秒，还没有再发射新的数据项（这一次要300毫秒才发射），就超时了，就报出TimeoutException，以一个错误通知终止Observable。 五、更多timeout操作符还有以下变体： timeout(long,TimeUnit) timeout() timeout(long,TimeUnit,Observable) timeout(long,TimeUnit,Observable,Scheduler) timeout(Func1) timeout(Func1,Observable) timeout(Func0,Func1) timeout(Func0,Func1,Observable) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之9_timeInterval]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B9_timeInterval.html</url>
    <content type="text"><![CDATA[一、描述将一个发射数据的Observable转换为发射那些数据发射时间间隔的Observable。 TimeInterval操作符拦截原始Observable发射的数据项，替换为发射表示相邻发射物时间间隔的对象。 RxJava中的实现为timeInterval，这个操作符将原始Observable转换为另一个Obserervable，后者发射一个标志替换前者的数据项，这个标志表示前者的两个连续发射物之间流逝的时间长度。新的Observable的第一个发射物表示的是在观察者订阅原始Observable到原始Observable发射它的第一项数据之间流逝的时间长度。不存在与原始Observable发射最后一项数据和发射onCompleted通知之间时长对应的发射物。 timeInterval默认在immediate调度器上执行，你可以通过传参数修改。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; for (int i = 1; i &lt; 4; i++) &#123; try &#123; Thread.sleep(100 * i); &#125; catch (InterruptedException e) &#123; subscriber.onError(e); &#125; subscriber.onNext(i); &#125; subscriber.onCompleted(); &#125;&#125;) .timeInterval() .subscribeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;TimeInterval&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(TimeInterval&lt;Integer&gt; timeInterval) &#123; System.out.println("onNext: interval=" + timeInterval.getIntervalInMilliseconds() + ", Value=" +timeInterval.getValue()); &#125; &#125;); 四、运行结果1234onNext: interval=100, Value=1onNext: interval=100, Value=2onNext: interval=100, Value=3onCompleted. 五、更多delay操作符还有以下变体： timeInterval() timeInterval(Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之8_delay]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B8_delay.html</url>
    <content type="text"><![CDATA[一、描述延迟一段指定的时间再发射来自Observable的发射物。 Delay操作符让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量。 RxJava的实现是 delay和delaySubscription。 第一种delay接受一个定义时长的参数（包括数量和单位）。每当原始Observable发射一项数据，delay就启动一个定时器，当定时器过了给定的时间段时，delay返回的Observable发射相同的数据项。 注意：delay不会平移onError通知，它会立即将这个通知传递给订阅者，同时丢弃任何待发射的onNext通知。然而它会平移一个onCompleted通知。 delay默认在computation调度器上执行，你可以通过参数指定使用其它的调度器。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3) .delay(2000, TimeUnit.MILLISECONDS) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12345(2秒后...）onNext: 1onNext: 2onNext: 3onCompleted. 五、更多delay操作符还有以下变体： delay(long,TimeUnit) delay() delay(Func1) delay(Func0,Func1) 跟delay相关的操作符还有： delaySubscription(long,TimeUnit) delaySubscription(long,TimeUnit,Scheduler) delaySubscription(Func0) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之7_subscribeOn]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B7_subscribeOn.html</url>
    <content type="text"><![CDATA[一、描述指定Observable自身在哪个调度器上执行。 很多ReactiveX实现都使用调度器 “Scheduler”来管理多线程环境中Observable的转场。你可以使用SubscribeOn操作符指定Observable在一个特定的调度器上运转。 ObserveOn操作符的作用类似，但是功能很有限，它指示Observable在一个指定的调度器上给观察者发通知。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839404142System.out.println("ThreadName: " + Thread.currentThread().getName());Observable.just(1, 2) .map(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; System.out.println("ThreadName(just): " + Thread.currentThread().getName()); return integer; &#125; &#125;) .subscribeOn(Schedulers.newThread()) .map(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; System.out.println("ThreadName(subscribeOn): " + Thread.currentThread().getName()); return integer; &#125; &#125;)// .observeOn(Schedulers.newThread())// .map(new Func1&lt;Integer, Integer&gt;() &#123;// @Override// public Integer call(Integer integer) &#123;// System.out.println("ThreadName(observeOn): " + Thread.currentThread().getName());// return integer;// &#125;// &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12345678ThreadName: mainThreadName(just): RxNewThreadScheduler-1ThreadName(just): RxNewThreadScheduler-1ThreadName(observeOn): RxNewThreadScheduler-1onNext: 1ThreadName(observeOn): RxNewThreadScheduler-1onNext: 2onCompleted. 由运行结果可以看出，相比使用observeOn()方法切换线程，使用subscribeOn()来切换线程的话，会在指定的线程上执行这个Observable，而且会改变创建Observable时所在的线程。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 在正确的线程上使用Observable PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之6_subscribe]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B6_subscribe.html</url>
    <content type="text"><![CDATA[一、描述操作来自Observable的发射物和通知。 Subscribe操作符是连接观察者和Observable的胶水。一个观察者要想看到Observable发射的数据项，或者想要从Observable获取错误和完成通知，它首先必须使用这个操作符订阅那个Observable。 Subscribe操作符的一般实现可能会接受一到三个方法（然后由观察者组合它们），或者接受一个实现了包含这三个方法的接口的对象（有时叫做Observer或Subscriber）： onNext 每当Observable发射了一项数据它就会调用这个方法。这个方法的参数是这个Observable发射的数据项。 onError Observable调用这个方法表示它无法生成期待的数据或者遇到了其它错误。这将停止Observable，它在这之后不会再调用onNext或onCompleted。onError方法的参数是导致这个错误的原因的一个表示（有时可能是一个Exception或Throwable对象，其它时候也可能是一个简单的字符串，取决于具体的实现）。 onCompleted 如果没有遇到任何错误，Observable在最后一次调用onCompleted之后会调用这个方法。 如果一个Observable直到有一个观察者订阅它才开始发射数据项，就称之为”冷”的Observable；如果一个Observable可能在任何时刻开始发射数据，就称之为”热”的Observable，一个订阅者可能从开始之后的某个时刻开始观察它发射的数据序列，它可能会错过在订阅之前发射的数据。 RxJava中的实现是subscribe方法。 如果你使用无参数的版本，它将触发对Observable的一个订阅，但是将忽略它的发射物和通知。这个操作会激活一个”冷”的Observable。 你也可以传递一到三个函数给它，它们会按下面的方法解释： onNext onNext和onError onNext, onError和onCompleted 最后，你还可以传递一个Observer或Subscriber接口给它，Observer接口包含这三个以on开头的方法。Subscriber接口也实现了这三个方法，而且还添加了几个额外的方法，用于支持使用反压操作(reactive pull backpressure)，这让Subscriber可以在Observable完成前取消订阅。 subscribe方法返回一个实现了Subscription接口的对象。这个接口包含unsubscribe方法，任何时刻你都可以调用它来断开subscribe方法建立的Observable和观察者之间的订阅关系。 二、示例代码1234567891011121314151617Observable.just(1, 2) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 三、运行结果123onNext: 1onNext: 2onCompleted. 四、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之5_observeOn]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B5_observeOn.html</url>
    <content type="text"><![CDATA[一、描述指定一个观察者在哪个调度器上观察这个Observable。 很多ReactiveX实现都使用调度器 “Scheduler”来管理多线程环境中Observable的转场。你可以使用ObserveOn操作符指定Observable在一个特定的调度器上发送通知给观察者 (调用观察者的onNext, onCompleted, onError方法)。 注意：当遇到一个异常时ObserveOn会立即向前传递这个onError终止通知，它不会等待慢速消费的Observable接受任何之前它已经收到但还没有发射的数据项。这可能意味着onError通知会跳到（并吞掉）原始Observable发射的数据项前面，正如图例上展示的。 SubscribeOn操作符的作用类似，但它是用于指定Observable本身在特定的调度器上执行，它同样会在那个调度器上给观察者发通知。 RxJava中，要指定Observable应该在哪个调度器上调用观察者的onNext, onCompleted, onError方法，你需要使用observeOn操作符，传递给它一个合适的Scheduler。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839404142System.out.println("ThreadName: " + Thread.currentThread().getName());Observable.just(1, 2) .map(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; System.out.println("ThreadName(just): " + Thread.currentThread().getName()); return integer; &#125; &#125;)// .subscribeOn(Schedulers.newThread())// .map(new Func1&lt;Integer, Integer&gt;() &#123;// @Override// public Integer call(Integer integer) &#123;// System.out.println("ThreadName(subscribeOn): " + Thread.currentThread().getName());// return integer;// &#125;// &#125;) .observeOn(Schedulers.newThread()) .map(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; System.out.println("ThreadName(observeOn): " + Thread.currentThread().getName()); return integer; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12345678ThreadName: mainThreadName(just): mainThreadName(just): mainThreadName(observeOn): RxNewThreadScheduler-3onNext: 1ThreadName(observeOn): RxNewThreadScheduler-3onNext: 2onCompleted. 由运行结果可以看出，使用observeOn()方法切换线程后，观察者会在指定的线程上观察这个Observable，但这个方法并不会改变创建Observable时所在的线程。（后面介绍的subscribeOn方法会改变创建Observable时所在的线程） 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 在正确的线程上使用Observable PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之4_serialize]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B4_serialize.html</url>
    <content type="text"><![CDATA[一、描述强制一个Observable连续调用并保证行为正确。 一个Observable可以异步调用它的观察者的方法，可能是从不同的线程调用。这可能会让Observable行为不正确，它可能会在某一个onNext调用之前尝试调用onCompleted或onError方法，或者从两个不同的线程同时调用onNext方法。使用Serialize操作符，你可以纠正这个Observable的行为，保证它的行为是正确的且是同步的。 RxJava中的实现是serialize，它默认不在任何特定的调度器上执行。 二、示意图 三、示例代码如果你无法确保自定义的操作符符合 Rx 的约定，例如从多个源异步获取数据，则可以使用 serialize 操作函数。 serialize 可以把一个不符合约定的 Observable 转换为一个符合约定的 Observable。 1. 首先创建一个不符合约定的 Observable，并且订阅到该 Observable上： 1234567891011121314151617181920212223242526272829303132Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; subscriber.onNext(1); subscriber.onNext(2); subscriber.onCompleted(); subscriber.onNext(3); subscriber.onCompleted(); &#125;&#125;) .doOnUnsubscribe(new Action0() &#123; @Override public void call() &#123; System.out.println("onUnsubscribe."); &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 2. 运行结果1234onNext: 1onNext: 2onCompleted.onUnsubscribe. 先不管上面的 Observable 发射的数据，订阅结束的情况看起来符合 Rx 约定。 这是由于 subscribe 认为当前数据流结束的时候会主动结束这个 Subscription。但这并不意味着总是这样的。 还有一个函数为 unsafeSubscribe ，该函数不会自动取消订阅。 3. 其次1234567891011121314151617181920212223242526272829303132Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; subscriber.onNext(1); subscriber.onNext(2); subscriber.onCompleted(); subscriber.onNext(3); subscriber.onCompleted(); &#125;&#125;) .doOnUnsubscribe(new Action0() &#123; @Override public void call() &#123; System.out.println("onUnsubscribe."); &#125; &#125;) .unsafeSubscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 4. 运行结果12345onNext: 1onNext: 2onCompleted.onNext: 3onCompleted. 上面的示例最后就没有打印 Unsubscribed 字符串。 unsafeSubscribe 也不能很好的处理错误情况。所以该函数几乎没用。在文档中说：该函数应该仅仅在自定义操作函数中处理嵌套订阅的情况。 为了避免这种操作函数接受到不合法的数据流，我们可以在其上应用 serialize 操作函数。 5. 使用serialize123456789101112131415161718192021222324252627282930313233Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; subscriber.onNext(1); subscriber.onNext(2); subscriber.onCompleted(); subscriber.onNext(3); subscriber.onCompleted(); &#125;&#125;) .serialize() .doOnUnsubscribe(new Action0() &#123; @Override public void call() &#123; System.out.println("onUnsubscribe."); &#125; &#125;) .unsafeSubscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果123onNext: 1onNext: 2onCompleted. 尽管上面的代码中没有调用unsubscribe， 但是数据流事件依然符合约定，最后也收到了完成事件。 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 RxJava 教程第三部分：驯服数据流之自定义操作函数 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之3_timestamp]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B3_timestamp.html</url>
    <content type="text"><![CDATA[一、描述给Observable发射的数据项附加一个时间戳。 RxJava中的实现为timestamp，它将一个发射T类型数据的Observable转换为一个发射类型为Timestamped的数据的Observable，每一项都包含数据的原始发射时间。 timestamp默认在immediate调度器上执行，但是可以通过参数指定其它的调度器。 二、示意图 三、示例代码1234567891011121314151617181920Observable.just(1, 2, 3) .timestamp() .subscribe(new Subscriber&lt;Timestamped&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Timestamped&lt;Integer&gt; time) &#123; String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss") .format(new Date(time.getTimestampMillis())); System.out.println("onNext: " + time.getValue() + "(" + timestamp + ")"); &#125; &#125;); 四、运行结果1234onNext: 1(2016-10-17 22:05:04)onNext: 2(2016-10-17 22:05:04)onNext: 3(2016-10-17 22:05:04)onCompleted. 五、更多timestamp操作符还有以下变体： timestamp(Scheduler) 详情可查阅下面的参考资料。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之2_dematerialize]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B2_dematerialize.html</url>
    <content type="text"><![CDATA[一、描述Dematerialize操作符是Materialize的逆向过程，它将Materialize转换的结果还原成它原本的形式。 dematerialize反转这个过程，将原始Observable发射的Notification对象还原成Observable的通知。 dematerialize默认不在任何特定的调度器 (Scheduler) 上执行。 二、示意图 三、示例代码12345678910111213141516171819Observable.just(1, 2, 3, 4) .materialize() .dematerialize() .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println("onNext: " + o); &#125; &#125;); 四、运行结果12345onNext: 1onNext: 2onNext: 3onNext: 4onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：6_辅助操作之1_materialize]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A6_%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C%E4%B9%8B1_materialize.html</url>
    <content type="text"><![CDATA[一、描述Materialize将数据项和事件通知都当做数据项发射。 一个合法的有限的Obversable将调用它的观察者的onNext方法零次或多次，然后调用观察者的onCompleted或onError正好一次。Materialize操作符将这一系列调用，包括原来的onNext通知和终止通知onCompleted或onError都转换为一个Observable发射的数据序列。 RxJava的materialize将来自原始Observable的通知转换为Notification对象，然后它返回的Observable会发射这些数据。 materialize默认不在任何特定的调度器 (Scheduler) 上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4) .materialize() .subscribe(new Subscriber&lt;Notification&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Notification&lt;Integer&gt; integerNotification) &#123; System.out.println("onNext: Type=" + integerNotification.getKind() + ", Value=" + integerNotification.getValue()); &#125; &#125;); 四、运行结果123456onNext: Type=OnNext, Value=1onNext: Type=OnNext, Value=2onNext: Type=OnNext, Value=3onNext: Type=OnNext, Value=4onNext: Type=OnCompleted, Value=nullonCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：5_错误处理之2_retry]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A5_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B9%8B2_retry.html</url>
    <content type="text"><![CDATA[一、描述如果原始Observable遇到错误，重新订阅它期望它能正常终止。 Retry操作符不会将原始Observable的onError通知传递给观察者，它会订阅这个Observable，再给它一次机会无错误地完成它的数据序列。Retry总是传递onNext通知给观察者，由于重新订阅，可能会造成数据项重复，如上图所示。 RxJava中的实现为retry和retryWhen。 无论收到多少次onError通知，无参数版本的retry都会继续订阅并发射原始Observable。 接受单个count参数的retry会最多重新订阅指定的次数，如果次数超了，它不会尝试再次订阅，它会把最新的一个onError通知传递给它的观察者。 还有一个版本的retry接受一个谓词函数作为参数，这个函数的两个参数是：重试次数和导致发射onError通知的Throwable。这个函数返回一个布尔值，如果返回true，retry应该再次订阅和镜像原始的Observable，如果返回false，retry会将最新的一个onError通知传递给它的观察者。 retry操作符默认在trampoline调度器上执行。 二、示意图 三、示例代码12345678910111213141516171819202122232425262728293031323334Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; if (subscriber.isUnsubscribed()) &#123; return; &#125; for (int i = 0; i &lt; 7; i++) &#123; if (i == 4) &#123; subscriber.onError(new Exception("Integer is 4!")); &#125; else &#123; subscriber.onNext(i); &#125; &#125; subscriber.onCompleted(); &#125;&#125;) .retry(1) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果123456789onNext: 0onNext: 1onNext: 2onNext: 3onNext: 0onNext: 1onNext: 2onNext: 3onError: Integer is 4! 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多retry操作符还有以下变体： retry() retry(long) retry(Func2) 跟retry相关的操作符还有： retryWhen(Func1) retryWhen(Func1,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：5_错误处理之1_3_onExceptionResumeNext]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A5_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B9%8B1_3_onExceptionResumeNext.html</url>
    <content type="text"><![CDATA[一、描述让Observable在遇到错误时继续发射后面的数据项。 和onErrorResumeNext类似，onExceptionResumeNext方法返回一个镜像原有Observable行为的新Observable，也使用一个备用的Observable，不同的是，如果onError收到的Throwable不是一个Exception，它会将错误传递给观察者的onError方法，不会使用备用的Observable。 二、示意图 三、示例代码12345678910111213141516171819202122232425262728293031323334Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; if (subscriber.isUnsubscribed()) &#123; return; &#125; for (int i = 0; i &lt; 7; i++) &#123; if (i == 4) &#123; subscriber.onError(new Exception("Integer is 4!")); &#125; else &#123; subscriber.onNext(i); &#125; &#125; subscriber.onCompleted(); &#125; &#125;) .onExceptionResumeNext(Observable.just(166, 167, 168)) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12345678onNext: 0onNext: 1onNext: 2onNext: 3onNext: 166onNext: 167onNext: 168onCompleted. 将第10行代码改为new Throwable后，会看到输出结果为： 12345onNext: 0onNext: 1onNext: 2onNext: 3onError: Integer is 4! 可见上文提到的结论是正确的：如果onError收到的Throwable不是一个Exception，它会将错误传递给观察者的onError方法，不会使用备用的Observable。 关于Error和Exception的区别，大家可以查看Android官方文档，或查看Android RxJava使用介绍（四） RxJava的操作符。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：5_错误处理之1_2_onErrorResumeNext]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A5_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B9%8B1_2_onErrorResumeNext.html</url>
    <content type="text"><![CDATA[一、描述让Observable在遇到错误时开始发射第二个Observable的数据序列。 onErrorResumeNext方法返回一个镜像原有Observable行为的新Observable，后者会忽略前者的onError调用，不会将错误传递给观察者，作为替代，它会开始镜像另一个，备用的Observable。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; if (subscriber.isUnsubscribed()) &#123; return; &#125; for (int i = 0; i &lt; 7; i++) &#123; if (i == 4) &#123; subscriber.onError(new Exception("Integer is 4!")); &#125; else &#123; subscriber.onNext(i); &#125; &#125; subscriber.onCompleted(); &#125;&#125;) .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends Integer&gt;&gt;() &#123; @Override public Observable&lt;? extends Integer&gt; call(Throwable throwable) &#123; return Observable.just(166, 167, 168); &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12345678onNext: 0onNext: 1onNext: 2onNext: 3onNext: 166onNext: 167onNext: 168onCompleted. onErrorResumeNext操作符跟onErrorReturn类似，只不过onErrorReturn只能在错误或异常发生时只返回一个和源Observable相同类型的结果，而onErrorResumeNext操作符是在错误或异常发生时返回一个Observable，也就是说可以返回多个和源Observable相同类型的结果。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：5_错误处理之1_1_onErrorReturn]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A5_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B9%8B1_1_onErrorReturn.html</url>
    <content type="text"><![CDATA[一、描述让Observable遇到错误时发射一个特殊的项并且正常终止。 onErrorReturn方法返回一个镜像原有Observable行为的新Observable，后者会忽略前者的onError调用，不会将错误传递给观察者，作为替代，它会发发射一个特殊的项并调用观察者的onCompleted方法。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; if (subscriber.isUnsubscribed()) &#123; return; &#125; for (int i = 0; i &lt; 7; i++) &#123; if (i == 4) &#123; subscriber.onError(new Exception("Integer is 4!")); &#125; else &#123; subscriber.onNext(i); &#125; &#125; subscriber.onCompleted(); &#125;&#125;) .onErrorReturn(new Func1&lt;Throwable, Integer&gt;() &#123; @Override public Integer call(Throwable throwable) &#123; return 166; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果123456onNext: 0onNext: 1onNext: 2onNext: 3onNext: 166onCompleted. onErrorReturn操作符是在Observable发生错误或异常的时候（即将回调oError方法时），拦截错误并执行指定的逻辑，返回一个跟源Observable相同类型的结果，最后回调订阅者的onComplete方法。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：4_结合操作之7_switch]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A4_%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B7_switch.html</url>
    <content type="text"><![CDATA[一、描述将一个发射多个Observables的Observable转换成另一个单独的Observable，后者发射那些Observables最近发射的数据项。 Switch订阅一个发射多个Observables的Observable。它每次观察那些Observables中的一个，Switch返回的这个Observable取消订阅前一个发射数据的Observable，开始发射最近的Observable发射的数据。注意：当原始Observable发射了一个新的Observable时（不是这个新的Observable发射了一条数据时），它将取消订阅之前的那个Observable。这意味着，在后来那个Observable产生之后到它开始发射数据之前的这段时间里，前一个Observable发射的数据将被丢弃（就像图例上的那个黄色圆圈一样）。 switch操作符在RxJava上的实现为switchOnNext,用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。 需要注意的就是，如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新的小Observable所发射的数据。可以看示意图中的黄色圆圈就被丢弃了。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Observable&lt;String&gt; createObserver(final int index) &#123; return Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; for (int i = 1; i &lt; 5; i++) &#123; subscriber.onNext(index + "-" + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).subscribeOn(Schedulers.newThread());&#125;@Overrideprotected void runSampleCode() &#123; Observable.switchOnNext(Observable.create( new Observable.OnSubscribe&lt;Observable&lt;String&gt;&gt;() &#123; @Override public void call(Subscriber&lt;? super Observable&lt;String&gt;&gt; subscriber) &#123; for (int i = 1; i &lt; 3; i++) &#123; subscriber.onNext(createObserver(i)); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; )) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext: " + s); &#125; &#125;);&#125; 四、运行结果123456onNext: 1-1onNext: 1-2onNext: 2-1onNext: 2-2onNext: 2-3onNext: 2-4 可以看到使用siwtch的时候，第一个小Observable只发射出了两个数据，第二个小Observable就被源Observable发射出来了，所以其接下来的两个数据被丢弃。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：4_结合操作之6_join]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A4_%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B6_join.html</url>
    <content type="text"><![CDATA[一、描述任何时候，只要在另一个Observable发射的数据定义的时间窗口内，这个Observable发射了一条数据，就结合两个Observable发射的数据。 Join操作符结合两个Observable发射的数据，基于时间窗口（你定义的针对每条数据特定的原则）选择待集合的数据项。你将这些时间窗口实现为一些Observables，它们的生命周期从任何一条Observable发射的每一条数据开始。当这个定义时间窗口的Observable发射了一条数据或者完成时，与这条数据关联的窗口也会关闭。只要这条数据的窗口是打开的，它将继续结合其它Observable发射的任何数据项。你定义一个用于结合数据的函数。 join默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Observable create1 = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; for (int i = 0; i &lt; 6; i++) &#123; subscriber.onNext(i); try &#123; Thread.sleep(600); &#125; catch (InterruptedException e) &#123; subscriber.onError(e); &#125; &#125; &#125;&#125;).subscribeOn(Schedulers.newThread());Observable create2 = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; for (int i = 0; i &lt; 4; i++) &#123; subscriber.onNext(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; subscriber.onError(e); &#125; &#125; &#125;&#125;).subscribeOn(Schedulers.newThread());create1.join(create2, new Func1&lt;Integer, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Integer integer) &#123; return Observable.timer(1000, TimeUnit.MILLISECONDS); &#125; &#125;, new Func1&lt;Integer, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Integer integer) &#123; return Observable.timer(1000, TimeUnit.MILLISECONDS); &#125; &#125;, new Func2&lt;Integer, Integer, String&gt;() &#123; @Override public String call(Integer integer1, Integer integer2) &#123; return integer1 + "-" + integer2; &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext: " + s); &#125; &#125;); 四、运行结果12345678910onNext: 0-0onNext: 1-0onNext: 1-1onNext: 2-1onNext: 3-1onNext: 3-2onNext: 2-2onNext: 4-2onNext: 4-3onNext: 5-3 注意点：join()方法有4个参数： Observable right：目标Observable，也可以称为右Observable；与之相对应的是源Observable，也可以称为左Observable。 rx.functions.Func1]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：4_结合操作之5_combineLatest]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A4_%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B5_combineLatest.html</url>
    <content type="text"><![CDATA[一、描述当两个Observables中的任何一个发射了数据时，使用一个函数结合每个Observable发射的最近数据项，并且基于这个函数的结果发射数据。 CombineLatest操作符行为类似于zip，但是只有当原始的Observable中的每一个都发射了一条数据时zip才发射数据。CombineLatest则在原始的Observable中任意一个发射了数据时发射一条数据。当原始Observables的任何一个发射了一条数据时，CombineLatest使用一个函数结合它们最近发射的数据，然后发射这个函数的返回值。 RxJava将这个操作符实现为combineLatest，它接受二到九个Observable作为参数，或者单个Observables列表作为参数。它默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Observable create1 = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; for (int i = 0; i &lt; 3; i++) &#123; subscriber.onNext(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; subscriber.onError(e); &#125; &#125; &#125;&#125;).subscribeOn(Schedulers.newThread());Observable create2 = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; for (int i = 0; i &lt; 3; i++) &#123; subscriber.onNext(i); try &#123; Thread.sleep(600); &#125; catch (InterruptedException e) &#123; subscriber.onError(e); &#125; &#125; &#125;&#125;).subscribeOn(Schedulers.newThread());subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext: " + s); &#125;&#125;;Observable.combineLatest(create1, create2, new Func2&lt;Integer, Integer, String&gt;() &#123; @Override public String call(Integer integer1, Integer integer2) &#123; return integer1 + "-" + integer2; &#125;&#125;).subscribe(subscriber); 四、运行结果123456onNext: 0-0onNext: 0-1onNext: 1-1onNext: 1-2onNext: 2-2onCompleted. 注意点：create操作符生成数据，需在新的线程上执行，否则会出现先发射完第一个create的数据，再发射第二个create的数据。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多combineLatest操作符还有以下变体： combineLatest(List,FuncN) combineLatest(Observable,Observable,Func2) 跟combineLatest相关的操作符还有： withLatestFrom 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：4_结合操作之4_andThenWhen]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A4_%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B4_andThenWhen.html</url>
    <content type="text"><![CDATA[一、描述使用Pattern和Plan作为中介，将两个或多个Observable发射的数据集合并到一起。 And/Then/When操作符组合的行为类似于zip，但是它们使用一个中间数据结构。接受两个或多个Observable，一次一个将它们的发射物合并到Pattern对象，然后操作那个Pattern对象，变换为一个Plan。随后将这些Plan变换为Observable的发射物。 它们属于rxjava-joins模块，不是核心RxJava包的一部分。 二、示意图 三、示例代码由于start操作符是属于可选的rxjava-joins模块的，所以需要加入下面的依赖： 1compile 'io.reactivex:rxjava-joins:0.22.0' 1234567891011121314151617181920212223242526272829Observable just1 = Observable.just("A", "B");Observable just2 = Observable.just(1, 2, 3);Pattern2&lt;String, Integer&gt; pattern = JoinObservable.from(just1).and(just2);Plan0 plan = pattern.then(new Func2&lt;String, Integer, String&gt;() &#123; @Override public String call(String s, Integer integer) &#123; return s + integer; &#125;&#125;);JoinObservable.when(plan) .toObservable() .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext: " + s); &#125; &#125;); 四、运行结果123onNext: A1onNext: B2onCompleted. and/then/when操作符实现的效果跟zip一样。相较之下，zip会更简单易用，但是如果是一些zip满足不了的场景，一些比较复杂的架构，就需要用and/then/when操作符来实现了。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：4_结合操作之3_zip]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A4_%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B3_zip.html</url>
    <content type="text"><![CDATA[一、描述通过一个函数将多个Observables的发射物结合到一起，基于这个函数的结果为每个结合体发射单个数据项。 Zip操作符返回一个Obversable，它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。 RxJava将这个操作符实现为zip和zipWith。 zip的最后一个参数接受每个Observable发射的一项数据，返回被压缩后的数据，它可以接受一到九个参数：一个Observable序列，或者一些发射Observable的Observables。 二、示意图 三、示例代码12345678910111213141516171819202122232425Observable just11 = Observable.just("A", "B");Observable just21 = Observable.just(1, 2, 3);Observable.zip(just11, just21, new Func2&lt;String, Integer, String&gt;() &#123; @Override public String call(String string, Integer integer) &#123; return string + integer; &#125;&#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext: " + s); &#125; &#125;); 四、运行结果123onNext: A1onNext: B2onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多zip操作符还有以下变体： zip(Iterable,FuncN) zip(Observable,FuncN) zip(Observable,Observable,Func2)(最多可以有九个Observables参数) 跟zip相关的操作符还有： zipWith(Observable,Func2) zipWith(Iterable,Func2) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：4_结合操作之2_merge]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A4_%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B2_merge.html</url>
    <content type="text"><![CDATA[一、描述合并多个Observables的发射物。 使用Merge操作符你可以将多个Observables的输出合并，就好像它们是一个单个的Observable一样。 Merge可能会让合并的Observables发射的数据交错（有一个类似的操作符Concat不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。 正如图例上展示的，任何一个原始Observable的onError通知会被立即传递给观察者，而且会终止合并后的Observable。 在很多ReactiveX实现中还有一个叫MergeDelayError的操作符，它的行为有一点不同，它会保留onError通知直到合并后的Observable所有的数据发射完成，在那时它才会把onError传递给观察者。 RxJava将它实现为merge, mergeWith和mergeDelayError。 除了传递多个Observable给merge，你还可以传递一个Observable列表List，数组，甚至是一个发射Observable序列的Observable，merge将合并它们的输出作为单个Observable的输出。 如果你传递一个发射Observables序列的Observable，你可以指定merge应该同时订阅的Observable’的最大数量。一旦达到订阅数的限制，它将不再订阅原始Observable发射的任何其它Observable，直到某个已经订阅的Observable发射了onCompleted通知。 merge是静态方法，mergeWith是对象方法，举个例子，Observable.merge(odds,evens)等价于odds.mergeWith(evens)。 如果传递给merge的任何一个的Observable发射了onError通知终止了，merge操作符生成的Observable也会立即以onError通知终止。如果你想让它继续发射数据，在最后才报告错误，可以使用mergeDelayError。 二、示意图 三、示例代码1234567891011121314151617181920Observable just1 = Observable.just(1, 2);Observable just2 = Observable.just(6, 7, 8);Observable.merge(just1, just2) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果123456onNext: 1onNext: 2onNext: 6onNext: 7onNext: 8onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多merge操作符还有以下变体： merge(Iterable) merge(Iterable,int) merge(Observable[]) merge(Observable,Observable) merge(Observable) merge(Observable,int) 跟merge相关的操作符还有： mergeDelayError(Observable) mergeDelayError(Observable,Observable) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：4_结合操作之1_startWith]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A4_%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E4%B9%8B1_startWith.html</url>
    <content type="text"><![CDATA[一、描述在数据序列的开头插入一条指定的项。 如果你想要一个Observable在发射数据之前先发射一个指定的数据序列，可以使用StartWith操作符。（如果你想一个Observable发射的数据末尾追加一个数据序列可以使用Concat操作符。） 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3) .startWith(9, 8) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError:" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext:" + integer); &#125; &#125;); 四、运行结果123456onNext: 9onNext: 8onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之12_ignoreElements]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B12_ignoreElements.html</url>
    <content type="text"><![CDATA[一、描述不发射任何数据，只发射Observable的终止通知。 IgnoreElements操作符抑制原始Observable发射的所有数据，只允许它的终止通知（onError或onCompleted）通过。 如果你不关心一个Observable发射的数据，但是希望在它完成时或遇到错误终止时收到通知，你可以对Observable使用ignoreElements操作符，它会确保永远不会调用观察者的onNext()方法。 ignoreElements默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .ignoreElements() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError:" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext:" + integer); &#125; &#125;); 四、运行结果1onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之11_distinct]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B11_distinct.html</url>
    <content type="text"><![CDATA[一、描述抑制（过滤掉）重复的数据项。 Distinct的过滤规则是：只允许还没有发射过的数据项通过。 在某些实现中，有一些变体允许你调整判定两个数据不同(distinct)的标准。还有一些实现只比较一项数据和它的直接前驱，因此只会从序列中过滤掉连续重复的数据。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 1, 1, 2, 3) .distinct() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError:" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext:" + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多distinct操作符还有以下变体： distinct(Func1) 跟distinct相关的操作符还有： distinctUntilChanged distinctUntilChanged(Func1) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之10_debounce]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B10_debounce.html</url>
    <content type="text"><![CDATA[一、描述仅在过了一段指定的时间还没发射数据时才发射一个数据。 Debounce操作符会过滤掉发射速率过快的数据项。 RxJava将这个操作符实现为throttleWithTimeout和debounce。 注意：这个操作符会会接着最后一项数据发射原始Observable的onCompleted通知，即使这个通知发生在你指定的时间窗口内（从最后一项数据的发射算起）。也就是说，onCompleted通知不会触发限流。 二、示意图 三、示例代码12345678910111213141516171819202122232425262728293031323334Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; if(subscriber.isUnsubscribed()) return; try &#123; //产生结果的间隔时间分别为100、200、300...900毫秒 for (int i = 1; i &lt; 10; i++) &#123; subscriber.onNext(i); Thread.sleep(i * 100); &#125; subscriber.onCompleted(); &#125;catch(Exception e)&#123; subscriber.onError(e); &#125; &#125;&#125;) .subscribeOn(Schedulers.newThread()) .debounce(400, TimeUnit.MILLISECONDS) //超时时间为400毫秒 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError:" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext:" + integer); &#125; &#125;); 由于1-4这四个数值，间隔时间（分别为100ms，200ms，300ms，400ms）均不大于debounce限制的值（400ms），所以均被过滤掉，只有后面发射的时间间隔大于400ms的（分别为500ms-900ms），才会正常发射。 四、运行结果123456onNext: 5onNext: 6onNext: 7onNext: 8onNext: 9onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟debounce相关的操作符还有： throttleWithTimeout(long,TimeUnit) 和 debounce(long,TimeUnit) throttleWithTimeout(long,TimeUnit,Scheduler) 和 debounce(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之9_sample]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B9_sample.html</url>
    <content type="text"><![CDATA[一、描述定期发射Observable最近发射的数据项。 Sample操作符定时查看一个Observable，然后发射自上次采样以来它最近发射的数据。 在某些实现中，有一个ThrottleFirst操作符的功能类似，但不是发射采样期间的最近的数据，而是发射在那段时间内的第一项数据。 RxJava将这个操作符实现为sample和throttleLast。 注意：如果自上次采样以来，原始Observable没有发射任何数据，这个操作返回的Observable在那段时间内也不会发射任何数据。 sample(别名throttleLast)的一个变体按照你参数中指定的时间间隔定时采样（TimeUnit指定时间单位）。 sample的这个变体默认在computation调度器上执行，但是你可以使用第三个参数指定其它的调度器。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233protected void runSampleCode() &#123; Observable observable = Observable.interval(1000, TimeUnit.MILLISECONDS) .sample(2200, TimeUnit.MILLISECONDS); subscriber = new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); &#125; &#125;; observable.subscribe(subscriber);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (subscriber != null &amp;&amp; !subscriber.isUnsubscribed()) &#123; subscriber.unsubscribe(); &#125;&#125; 四、运行结果1234567onNext: 1onNext: 3onNext: 5onNext: 7onNext: 9onNext: 12(...) 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多sample操作符还有以下变体： sample(long,TimeUnit) 和 throttleLast(long,TimeUnit) sample(long,TimeUnit,Scheduler) 和 throttleLast(long,TimeUnit,Scheduler) sample(Observable) 跟sample相关的操作符还有： throttleFirst(long,TimeUnit) throttleFirst(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之8_elementAt]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B8_elementAt.html</url>
    <content type="text"><![CDATA[一、描述只发射第N项数据。 ElementAt操作符获取原始Observable发射的数据序列指定索引位置的数据项，然后当做自己的唯一数据发射。 RxJava将这个操作符实现为elementAt，给它传递一个基于0的索引值，它会发射原始Observable数据序列对应索引位置的值，如果你传递给elementAt的值为5，那么它会发射第六项的数据。 如果你传递的是一个负数，或者原始Observable的数据项数小于index+1，将会抛出一个IndexOutOfBoundsException异常。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .elementAt(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 4onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟elementAt相关的操作符还有： elementAtOrDefault(int,T) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之7_first]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B7_first.html</url>
    <content type="text"><![CDATA[一、描述只发射第一项（或者满足某个条件的第一项）数据。 如果你只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，你可以使用First操作符。 在某些实现中，First没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用Take(1)或者ElementAt(0)。 在一些实现中还有一个Single操作符。它的行为与First类似，但为了确保只发射单个值，它会等待原始Observable终止（否则，不是发射那个值，而是以一个错误通知终止）。你可以使用它从原始Observable获取第一项数据，而且也确保只发射一项数据。 在RxJava中，这个操作符被实现为first，firstOrDefault和takeFirst。 可能容易混淆，BlockingObservable也有名叫first和firstOrDefault的操作符，它们会阻塞并返回值，不是立即返回一个Observable。 还有几个其它的操作符执行类似的功能。 只发射第一个数据，使用没有参数的first操作符。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .first() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 1onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多first操作符还有以下变体： first(Func1) 跟first相关的操作符还有： firstOrDefault(T) firstOrDefault(T, Func1) takeFirst(Func1) single() single(Func1) singleOrDefault(T) singleOrDefault(Func1,T) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之6_take]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B6_take.html</url>
    <content type="text"><![CDATA[一、描述只发射前面的N项数据。 使用Take操作符让你可以修改Observable的行为，只返回前面的N项数据，然后发射完成通知，忽略剩余的数据。 如果你对一个Observable使用take(n)（或它的同义词limit(n)）操作符，而那个Observable发射的数据少于N项，那么take操作生成的Observable不会抛异常或发射onError通知，在完成前它只会发射相同的少量数据。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .take(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多take操作符还有以下变体： take(long,TimeUnit) take(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之5_skipLast]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B5_skipLast.html</url>
    <content type="text"><![CDATA[一、描述抑制Observable发射的后N项数据。 使用SkipLast操作符修改原始Observable，你可以忽略Observable发射的后N项数据，只保留前面的数据。 使用SkipLast操作符，你可以忽略原始Observable发射的后N项数据，只保留之前的数据。注意：这个机制是这样实现的：延迟原始Observable发射的任何数据项，直到它发射了N项数据。 skipLast的这个变体默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .skipLast(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多skipLast操作符还有以下变体： skipLast(long,TimeUnit) skipLast(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之4_skip]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B4_skip.html</url>
    <content type="text"><![CDATA[一、描述抑制Observable发射的前N项数据。 使用Skip操作符，你可以忽略Observable发射的前N项数据，只保留之后的数据。 skip的这个变体默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .skip(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234onNext: 4onNext: 5onNext: 6onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多skip操作符还有以下变体： skip(long,TimeUnit) skip(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之3_last]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B3_last.html</url>
    <content type="text"><![CDATA[一、描述只发射最后一项（或者满足某个条件的最后一项）数据。 如果你只对Observable发射的最后一项数据，或者满足某个条件的最后一项数据感兴趣，你可以使用Last操作符。 在某些实现中，Last没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用TakeLast(1)。 在RxJava中的实现是last和lastOrDefault。 可能容易混淆，BlockingObservable也有名叫last和lastOrDefault的操作符，它们会阻塞并返回值，不是立即返回一个Observable。 只发射最后一项数据，使用没有参数的last操作符。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .last() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12onNext: 6onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多last操作符还有以下变体： last(Func1) 跟last相关的操作符还有： lastOrDefault(T) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之2_takeLast]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B2_takeLast.html</url>
    <content type="text"><![CDATA[一、描述发射Observable发射的最后N项数据。 使用TakeLast操作符修改原始Observable，你可以只发射Observable发射的后N项数据，忽略前面的数据。 使用takeLast操作符，你可以只发射原始Observable发射的后N项数据，忽略之前的数据。注意：这会延迟原始Observable发射的任何数据项，直到它全部完成。 takeLast的这个变体默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .takeLast(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234onNext: 4onNext: 5onNext: 6onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多本操作符还有以下变体： takeLast(int, long, TimeUnit) 相关的操作符还有： takeLastBuffer 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：3_过滤操作之1_filter]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A3_%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E4%B9%8B1_filter.html</url>
    <content type="text"><![CDATA[一、描述只发射通过了谓词测试的数据项。 Filter操作符使用你指定的一个谓词函数测试数据项，只有通过测试的数据才会被发射。 filter默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4, 5) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer &lt; 4; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟filter相关的操作符还有： ofType 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：2_变换操作之6_window]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A2_%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B6_window.html</url>
    <content type="text"><![CDATA[一、描述定期将来自原始Observable的数据分解为一个Observable窗口，发射这些窗口，而不是每次发射一项数据。 Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。 和Buffer一样，Window有很多变体，每一种都以自己的方式将原始Observable分解为多个作为结果的Observable，每一个都包含一个映射原始数据的window。用Window操作符的术语描述就是，当一个窗口打开(when a window “opens”)意味着一个新的Observable已经发射（产生）了，而且这个Observable开始发射来自原始Observable的数据；当一个窗口关闭(when a window “closes”)意味着发射(产生)的Observable停止发射原始Observable的数据，并且发射终止通知onCompleted给它的观察者们。 二、示意图 三、示例代码window操作符与buffer操作符类似，区别在于buffer操作符产生的结果是一个List缓存，而window操作符产生的结果是一个Observable,订阅者可以对这个结果Observable重新进行订阅处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 完整流程版Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .window(3) .subscribe(new Subscriber&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Observable&lt;Integer&gt; integerObservable) &#123; integerObservable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted(inner)."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError(inner): " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); &#125; &#125;);// 简化版Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .window(3) .subscribe(new Action1&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public void call(Observable&lt;Integer&gt; integerObservable) &#123; System.out.println("start"); integerObservable.subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); &#125; &#125;); 四、运行结果1234567891011121314151617181920212223242526(完整流程版)onNext: 1onNext: 2onNext: 3onCompleted(inner).onNext: 4onNext: 5onNext: 6onCompleted(inner).onNext: 7onNext: 8onCompleted(inner).onCompleted.(简化版)startonNext: 1onNext: 2onNext: 3startonNext: 4onNext: 5onNext: 6startonNext: 7onNext: 8 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多在RxJava中有许多window的变体： window(closingSelector) window(windowOpenings, closingSelector) window(count) window(count, skip) window(timespan, unit[, scheduler]) window(timespan, unit, count[, scheduler]) window(timespan, timeshift, unit[, scheduler]) window-backpressure 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：2_变换操作之5_buffer]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A2_%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B5_buffer.html</url>
    <content type="text"><![CDATA[一、描述定期收集Observable的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。 Buffer操作符将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合。Buffer操作符在很多语言特定的实现中有很多种变体，它们在如何缓存这个问题上存在区别。 注意：如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。 Window操作符与Buffer类似，但是它在发射之前把收集到的数据放进单独的Observable，而不是放进一个数据结构。 二、示意图 三、示例代码buffer操作符有两个参数，分别为count和skip，count参数指定buffer操作符的大小，skip参数用来指定每次发射一个集合需要跳过几个数。 123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .buffer(3, 2) .subscribe(new Subscriber&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; System.out.println("onNext: " + integers); &#125; &#125;); 四、运行结果12345onNext: [1, 2, 3]onNext: [3, 4, 5]onNext: [5, 6, 7]onNext: [7, 8]onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多在RxJava中有许多Buffer的变体： buffer(count) buffer(count, skip) buffer(bufferClosingSelector) buffer(boundary) buffer(bufferOpenings, bufferClosingSelector) buffer(timespan, unit[, scheduler]) buffer(timespan, unit, count[, scheduler]) buffer(timespan, timeshift, unit[, scheduler]) buffer-backpressure 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 http://www.jianshu.com/p/8b9e987e6789 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：2_变换操作之4_groupBy]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A2_%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B4_groupBy.html</url>
    <content type="text"><![CDATA[一、描述将一个Observable分拆为一些Observables集合，它们中的每一个发射原始Observable的一个子序列。 GroupBy操作符将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。 RxJava实现了groupBy操作符。它返回Observable的一个特殊子类GroupedObservable，实现了GroupedObservable接口的对象有一个额外的方法getKey，这个Key用于将数据分组到指定的Observable。 有一个版本的groupBy允许你传递一个变换函数，这样它可以在发射结果GroupedObservable之前改变数据项。 注意：groupBy将原始Observable分解为一个发射多个GroupedObservable的Observable，一旦有订阅，每个GroupedObservable就开始缓存数据。因此，如果你忽略这些GroupedObservable中的任何一个，这个缓存可能形成一个潜在的内存泄露。因此，如果你不想观察，也不要忽略GroupedObservable。你应该使用像take(0)这样会丢弃自己的缓存的操作符。 如果你取消订阅一个GroupedObservable，那个Observable将会终止。如果之后原始的Observable又发射了一个与这个Observable的Key匹配的数据，groupBy将会为这个Key创建一个新的GroupedObservable。 groupBy默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 完整流程版Observable.just(1, 2, 3, 4, 5) .groupBy(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; return integer % 3; &#125; &#125;) .subscribe(new Subscriber&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(final GroupedObservable&lt;Integer, Integer&gt; result) &#123; result.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted(inner)."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError(inner): " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: Key=" + result.getKey() + ", Value=" + integer); &#125; &#125;); &#125; &#125;);// 简化版Observable.just(1, 2, 3, 4, 5) .groupBy(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; return integer % 3; &#125; &#125;) .subscribe(new Action1&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123; @Override public void call(final GroupedObservable&lt;Integer, Integer&gt; result) &#123; result.subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; System.out.println("Key=" + result.getKey() + ", Value=" + integer); &#125; &#125;); &#125; &#125;); 四、运行结果1234567891011121314151617(完整流程版)onNext: Key=1, Value=1onNext: Key=2, Value=2onNext: Key=0, Value=3onNext: Key=1, Value=4onNext: Key=2, Value=5onCompleted(inner).onCompleted(inner).onCompleted(inner).onCompleted.(简化版)Key=1, Value=1Key=2, Value=2Key=0, Value=3Key=1, Value=4Key=2, Value=5 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多groupBy操作符共有以下几个变体： groupBy(Func1) groupBy(Func1,Func1) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：2_变换操作之3_scan]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A2_%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B3_scan.html</url>
    <content type="text"><![CDATA[一、描述连续地对数据序列的每一项应用一个函数，然后连续发射结果。 Scan操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。这个操作符在某些情况下被叫做accumulator。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4, 5) .scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer call(Integer sum, Integer item) &#123; return sum + item; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果123456onNext: 1onNext: 2onNext: 6onNext: 10onNext: 15onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多scan操作符共有以下几个变体： scan(Func2) scan(R,Func2) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：2_变换操作之2_flatMap]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A2_%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B2_flatMap.html</url>
    <content type="text"><![CDATA[一、描述FlatMap将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable。 FlatMap操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后FlatMap合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。 这个方法是很有用的，例如，当你有一个这样的Observable：它发射一个数据序列，这些数据本身包含Observable成员或者可以变换为Observable，因此你可以创建一个新的Observable发射这些次级Observable发射的数据的完整集合。 注意：FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。 在许多语言特定的实现中，还有一个操作符不会让变换后的Observables发射的数据交错，它按照严格的顺序发射这些数据，这个操作符通常被叫作ConcatMap或者类似的名字。 注意：如果任何一个通过这个flatMap操作产生的单独的Observable调用onError异常终止了，这个Observable自身会立即调用onError并终止。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Course &#123; private String name; public Course(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;class Student &#123; private List&lt;Course&gt; courses; public Student(List&lt;Course&gt; courses) &#123; this.courses = courses; &#125; public List&lt;Course&gt; getCourses() &#123; return courses; &#125;&#125;/* Student1 */Course course11 = new Course("C#");Course course12 = new Course("Java");Course course13 = new Course("Python");List&lt;Course&gt; courses1 = new ArrayList&lt;Course&gt;();courses1.add(course11);courses1.add(course12);courses1.add(course13);Student student1 = new Student(courses1);/* Student2 */Course course21 = new Course("OC");Course course22 = new Course("Ruby");List&lt;Course&gt; courses2 = new ArrayList&lt;Course&gt;();courses2.add(course21);courses2.add(course22);Student student2 = new Student(courses2);Observable.just(student1, student2) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(new Subscriber&lt;Course&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Course course) &#123; System.out.println("onNext: " + course.getName()); &#125; &#125;); 四、运行结果123456onNext: C#onNext: JavaonNext: PythononNext: OConNext: RubyonCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多flatMap操作符共有以下几个变体： flatMap(Func1) flatMap(Func1,int) flatMap(Func1,Func1,Func0) flatMap(Func1,Func1,Func0,int) flatMap(Func1,Func2) flatMap(Func1,Func2,int) 跟flatMap相关的操作符还有： flatMapIterable concatMap switchMap split 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：2_变换操作之1_map]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A2_%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E4%B9%8B1_map.html</url>
    <content type="text"><![CDATA[一、描述对Observable发射的每一项数据应用一个函数，执行变换操作。 Map操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。 这个操作符默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839class Student &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;Student student1 = new Student("ZhangSan");Student student2 = new Student("LiSi");Student student3 = new Student("WangWu");Observable.just(student1, student2, student3) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123; return student.getName(); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println("onNext: " + s); &#125; &#125;); 四、运行结果1234onNext: ZhangSanonNext: LiSionNext: WangWuonCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟map相关的操作符还有： cast encode byLine 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之10_timer]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B10_timer.html</url>
    <content type="text"><![CDATA[一、描述创建一个Observable，它在一个给定的延迟后发射一个特殊的值。 Timer操作符创建一个在给定的时间段之后返回一个特殊值的Observable。 timer返回一个Observable，它在延迟一段给定的时间后发射一个简单的数字0。 timer操作符默认在computation调度器上执行。有一个变体可以通过可选参数指定Scheduler。 二、示意图 三、示例代码1234567891011121314151617Observable.timer(3, TimeUnit.SECONDS) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); &#125; &#125;); 四、运行结果延时3秒后，打印出如下信息： 12onNext: 0onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之9_start]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B9_start.html</url>
    <content type="text"><![CDATA[一、描述返回一个Observable，它发射一个类似于函数声明的值。 编程语言有很多种方法可以从运算结果中获取值，它们的名字一般叫functions, futures, actions, callables, runnables等等。在Start目录下的这组操作符可以让它们表现得像Observable，因此它们可以在Observables调用链中与其它Observable搭配使用。 Start操作符的多种RxJava实现都属于可选的rxjava-async模块。 rxjava-async模块包含start操作符，它接受一个函数作为参数，调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable。 注意：这个函数只会被执行一次，即使多个观察者订阅这个返回的Observable。 二、示意图 三、示例代码由于start操作符是属于可选的rxjava-async模块的，所以需要加入下面的依赖： 1compile 'io.reactivex:rxjava-async-util:0.21.0' 123456789101112131415161718192021222324252627Async.start(new Func0&lt;Integer&gt;() &#123; @Override public Integer call() &#123; try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 16; &#125;&#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125;&#125;); 四、运行结果延时5秒后，打印出如下信息： 12onNext: 16onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟start相关的操作符还有： toAsync startFuture deferFuture fromAction fromCallable fromRunnable forEachFuture runAsync 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之8_repeat]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B8_repeat.html</url>
    <content type="text"><![CDATA[一、描述创建一个发射特定数据重复多次的Observable。 Repeat重复地发射数据。某些实现允许你重复的发射某个数据序列，还有一些允许你限制重复的次数。 RxJava将这个操作符实现为repeat方法。它不是创建一个Observable，而是重复发射原始Observable的数据序列，这个序列或者是无限的，或者通过repeat(n)指定重复次数。 repeat操作符默认在trampoline调度器上执行。有一个变体可以通过可选参数指定Scheduler。 二、示意图 三、示例代码123456789101112131415161718Observable.range(2, 3) .repeat(2) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果1234567onNext: 2onNext: 3onNext: 4onNext: 2onNext: 3onNext: 4onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟repeat相关的操作符还有： repeatWhen doWhile whileDo 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之7_range]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B7_range.html</url>
    <content type="text"><![CDATA[一、描述创建一个发射特定整数序列的Observable。 Range操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。 RxJava将这个操作符实现为range函数，它接受两个参数，一个是范围的起始值，一个是范围的数据的数目。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。 range默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。 二、示意图 三、示例代码1234567891011121314151617Observable.range(2, 4) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12345onNext: 2onNext: 3onNext: 4onNext: 5onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之6_just]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B6_just.html</url>
    <content type="text"><![CDATA[一、描述创建一个发射指定值的Observable。 Just将单个数据转换为发射那个数据的Observable。 Just类似于From，但是From会将数组或Iterable的数据取出然后逐个发射，而Just只是简单的原样发射，将数组或Iterable当做单个数据。 注意：如果你传递null给Just，它会返回一个发射null值的Observable。不要误认为它会返回一个空Observable（完全不发射任何数据的Observable），如果需要空Observable你应该使用Empty操作符。 RxJava将这个操作符实现为just函数，它接受一至九个参数，返回一个按参数列表顺序发射这些数据的Observable。 二、示意图 三、示例代码1234567891011121314151617Observable.just(1, 2, 3, 4) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125; &#125;); 四、运行结果12345onNext: 1onNext: 2onNext: 3onNext: 4onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之5_interval]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B5_interval.html</url>
    <content type="text"><![CDATA[一、描述创建一个按固定时间间隔发射整数序列的Observable。 Interval操作符返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。 还有一个版本的interval返回一个Observable，它在指定延迟之后先发射一个零值，然后再按照指定的时间间隔发射递增的数字。这个版本的interval在RxJava 1.0.0中叫做timer，但是那个方法已经不建议使用了，因为一个名叫interval的操作符有同样的功能。 interval默认在computation调度器上执行。你也可以传递一个可选的Scheduler参数来指定调度器。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132protected void runSampleCode() &#123; Observable observable = Observable.interval(1000, TimeUnit.MILLISECONDS); subscriber = new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println("onNext: " + aLong); &#125; &#125;; observable.subscribe(subscriber);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (subscriber!= null &amp;&amp; !subscriber.isUnsubscribed()) &#123; subscriber.unsubscribe(); &#125;&#125; 四、运行结果1234567onNext: 0onNext: 1onNext: 2onNext: 3onNext: 4onNext: 5(...) 注意点： 这个对象是运行在computation Scheduler，所以如果需要在view中显示结果，要在主线程中订阅。 由于这个操作会无限进行下去，所以需要手动取消掉这个subscription。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之4_from]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B4_from.html</url>
    <content type="text"><![CDATA[一、描述将其它种类的对象和数据类型转换为Observable。 当你使用Observable时，如果你要处理的数据都可以转换成展现为Observables，而不是需要混合使用Observables和其它类型的数据，会非常方便。这让你在数据流的整个生命周期中，可以使用一组统一的操作符来管理它们。 例如，Iterable可以看成是同步的Observable；Future，可以看成是总是只发射单个数据的Observable。通过显式地将那些数据转换为Observables，你可以像使用Observable一样与它们交互。 因此，大部分ReactiveX实现都提供了将语言特定的对象和数据结构转换为Observables的方法。 在RxJava中，from操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据。 对于Future，它会发射Future.get()方法返回的单个数据。from方法有一个可接受两个可选参数的版本，分别指定超时时长和时间单位。如果过了指定的时长Future还没有返回一个值，这个Observable会发射错误通知并终止。 from默认不在任何特定的调度器上执行。然而你可以将Scheduler作为可选的第二个参数传递给Observable，它会在那个调度器上管理这个Future。 二、示意图 三、示例代码12345678910111213141516171819Integer[] items = &#123; 0, 1, 2, 3, 4, 5 &#125;;Observable.from(items) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println("onNext: " + o); &#125; &#125;); 四、运行结果1234567onNext: 0onNext: 1onNext: 2onNext: 3onNext: 4onNext: 5onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多from操作符共有以下几个变体： 12345from(array)from(Iterable)from(Future)from(Future,Scheduler)from(Future,timout,timeUnit) 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之3.3_throw]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B3_3_throw.html</url>
    <content type="text"><![CDATA[一、描述创建一个不发射数据以一个错误终止的Observable。 二、示意图 三、示例代码1234567891011121314151617Observable.error(new Throwable("something must be wrong!")) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println("onNext: " + o); &#125; &#125;); 四、运行结果1onError: something must be wrong! 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之3.2_never]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B3_2_never.html</url>
    <content type="text"><![CDATA[一、描述创建一个不发射数据也不终止的Observable。 二、示意图 三、示例代码1234567891011121314151617Observable.never() .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println("onNext: " + o); &#125; &#125;); 四、运行结果 (什么结果也没有！) 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之3.1_empty]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B3_1_empty.html</url>
    <content type="text"><![CDATA[一、描述创建一个不发射任何数据但是正常终止的Observable。 empty操作符一般会跟其它操作符配合使用。 二、示意图 三、示例代码1234567891011121314151617Observable.empty() .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println("onNext: " + o); &#125; &#125;); 四、运行结果1onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之2_defer]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B2_defer.html</url>
    <content type="text"><![CDATA[一、描述Defer操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。 在某些情况下，等待直到最后一分钟（就是知道订阅发生时）才生成Observable可以确保Observable包含最新的数据。 RxJava将这个操作符实现为 defer 方法。这个操作符接受一个你选择的Observable工厂函数作为单个参数。这个函数没有参数，返回一个Observable。 defer方法默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435number = 1;Observable justObservable = Observable.just(number);number = 2;Observable deferObservable = Observable.defer(new Func0&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call() &#123; return Observable.just(number); &#125;&#125;);number = 3;justObservable.subscribe(new Action1() &#123; @Override public void call(Object o) &#123; System.out.println("just result: " + o.toString()); &#125;&#125;);deferObservable.subscribe(new Action1() &#123; @Override public void call(Object o) &#123; System.out.println("defer1 result: " + o.toString()); &#125;&#125;);number = 4;deferObservable.subscribe(new Action1() &#123; @Override public void call(Object o) &#123; System.out.println("defer2 result: " + o.toString()); &#125;&#125;); 四、运行结果123just result: 1defer1 result: 3defer2 result: 4 由运行结果可以看出： just操作符是在创建Observable就进行了赋值操作，而defer是在订阅者订阅时才创建Observable，此时才进行真正的赋值操作，保证Observable的状态是最新的。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符实践：1_创建操作之1_create]]></title>
    <url>%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E8%B7%B5%EF%BC%9A1_%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E4%B9%8B1_create.html</url>
    <content type="text"><![CDATA[一、描述你可以使用 Create 操作符从头开始创建一个Observable，给这个操作符传递一个接受观察者作为参数的函数，编写这个函数让它的行为表现为一个Observable–恰当的调用观察者的onNext，onError和onCompleted方法。 一个形式正确的有限Observable必须尝试调用观察者的onCompleted正好一次或者它的onError正好一次，而且此后不能再调用观察者的任何其它方法。 RxJava将这个操作符实现为create方法。 建议你在传递给create方法的函数中检查观察者的isUnsubscribed状态，以便在没有观察者的时候，让你的Observable停止发射数据或者做昂贵的运算。 create方法默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; observer) &#123; try &#123; if (!observer.isUnsubscribed()) &#123; for (int i = 0; i &lt; 4; i++) &#123; observer.onNext(i); &#125; observer.onCompleted(); &#125; &#125; catch (Exception e) &#123; observer.onError(e); &#125; &#125;&#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted."); &#125; @Override public void onError(Throwable e) &#123; System.out.println("onError: " + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println("onNext: " + integer); &#125;&#125;); 四、运行结果12345onNext: 0onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android WebView 图片适配解决方案]]></title>
    <url>%2FAndroidWebView%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[WebView的各种坑，今天又让我发现一个。 一、懵逼最近公司项目中新闻模块需要用WebView来加载，而且服务端返回的是String类型的html代码，包含各种标签，各种转义符，一开始直接用loadDataWithBaseURL()加载的时候，出现各种&amp;lt;、&amp;gt;，直接懵逼了，后面一查，只是因为转义符的关系，那直接用String类的replace()方法替换成对应的&lt;、&gt;，就搞定了。 但是当新闻里面的图片大于屏幕宽度时，会出现横向滚动条，图片也只显示部分，向右滚动屏幕才能看到剩余的图片内容，这样极不方便，也不美观。 网上搜索了一番，有种解决方案是直接把整个WebView的绽放比例变小，适配屏幕，这样出来的图片是适配屏幕了，但是文字就变得非常小，完全就是把PC端网页塞进手机的感觉了。 二、转机突然看到泡在网上的日子大哥的一篇文章WebView加载图片超过屏幕大小的问题，说的是让PC端在img标签里面配置一下最大宽度就可以解决了： 12345678&lt;style&gt;img&#123; max-width:80%; height:auto;&#125;&lt;/style&gt; 三、再次懵逼赶紧联系服务端人员，结果被告知，这是使用某个框架做出来的效果，没办法修改里面的样式，这不又再次懵逼了吗… 四、柳暗花明又一村程序员都是打不死的蟑螂，只要有一线希望，就要努力去实现自己的价值，不，保住自己的饭碗。 上面泡网大哥的方法，其实就是给img设置样式。那服务端搞不定，就只能我们客户端这边来做了，能不能我们直接给每个img标签都加上最大宽度的限制呢？既然我们能把转义符替换掉，那是不是也能用同样的方法来加样式呢？ 五、解决方案答案是肯定的，在我们获取到的String类型的html代码里面，我们已经把转义符replace成我们实际需要的字符，这时候我们就能取到img的标签了(&lt;img&gt;)，那只要加上如下的代码，就可以了： 1htmlData = htmlData.replace("&lt;img", "&lt;img style='max-width:90%;height:auto;'"); 原理就是上面分析的，在每个img标签里面，加上最大宽度和高度的控制，最大宽度比例可以根据需要自由设置。经过测试，暂时没发现问题，如果大家有发现问题，或者有其它的解决方案，欢迎随时给我留言。 PS：欢迎关注 SherlockShi 个人博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Animations 4：Circular Reveal Animations]]></title>
    <url>%2FMaterialAnimations4_CircularRevealAnimations.html</url>
    <content type="text"><![CDATA[一、前言Circular Reveal Animations，官方称之为循环揭露动画效果，是一种用来显示/隐藏一组UI界面元素的动画效果，它是在API 21引入的，对应的类是ViewAnimationUtils。 循环揭露动画效果可以和共享元素变换动画组合，用来创造一些有意义的动画效果，自然地告诉用户这个app有些什么东西，将会产生怎样的效果。 二、效果图 三、实现在上面的例子中，依次发生了： 橘色的圆是一个共享元素，从MainActivity变换到CircularRevealActivity； 在CircularRevealActivity中有一个监听器(listener)，用来监听共享元素转换动画的结束，当动画结束时，做了这么两件事： 为Toolbar执行了一个循环揭露动画 为CircularRevealActivity中的视图(Views)执行了一个放大动画，使用的是以前的ViewPropertyAnimator类 监听共享元素进入动画的结束 12345678910Transition transition = TransitionInflater.from(this).inflateTransition(R.transition.changebounds_with_arcmotion);getWindow().setSharedElementEnterTransition(transition);transition.addListener(new Transition.TransitionListener() &#123; @Override public void onTransitionEnd(Transition transition) &#123; animateRevealShow(mToolbar); animateButtonsIn(); &#125; ...&#125;); animateRevealShow(mToolbar) 1234567891011private void animateRevealShow(View viewRoot) &#123; int centerX = (viewRoot.getLeft() + viewRoot.getRight()) / 2; int centerY = (viewRoot.getTop() + viewRoot.getBottom()) / 2; int endRadius = Math.max(viewRoot.getWidth(), viewRoot.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(viewRoot, centerX, centerY, 0, endRadius); viewRoot.setVisibility(View.VISIBLE); animator.setDuration(1000); animator.setInterpolator(new AccelerateInterpolator()); animator.start();&#125; 上述方法的重点是createCircularReveal (View view, int centerX, int centerY, float startRadius, float endRadius)：view：要执行循环揭露动画的ViewcenterX：循环揭露动画中心位置的X坐标centerY：循环揭露动画中心位置的Y坐标startRadius：循环揭露动画的起始半径endRadius：循环揭露动画的结束半径 animateButtonsIn() 1234567891011private void animateButtonsIn() &#123; for (int i = 0; i &lt; bgViewGroup.getChildCount(); i++) &#123; View child = bgViewGroup.getChildAt(i); child.animate() .setStartDelay(100 + i*DELAY) .setInterpolator(interpolator) .alpha(1) .scaleX(1) .scaleY(1); &#125;&#125; 上述方法为底部的4个圆执行了一个放大动画，使用ViewPropertyAnimator类。 四、更多还有一些不同的方式来创建循环揭露动画，关键是使用动画效果让用户更好地理解这个app有些什么东西，将会产生怎样的效果。 1. 从目标视图的中心创建循环揭露动画 1234567891011public void revealGreenAtMiddle(View view) &#123; int centerX = (bgViewGroup.getLeft() + bgViewGroup.getRight()) / 2; int centerY = (bgViewGroup.getTop() + bgViewGroup.getBottom()) / 2; int endRadius = (int) Math.hypot(bgViewGroup.getWidth()/2, bgViewGroup.getHeight()/2); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.green); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start();&#125; 2. 从目标视图的顶部创建循环揭露动画+底部按钮动画 1234567891011121314151617181920public void revealBlueAtTop(View view) &#123; animateButtonsOut(); int centerX = (bgViewGroup.getLeft() + bgViewGroup.getRight()) / 2; int centerY = 0; int endRadius = (int) Math.hypot(bgViewGroup.getWidth()/2, bgViewGroup.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.blue); animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationEnd(Animator animation) &#123; animateButtonsIn(); &#125; ... &#125;); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start();&#125; 此处动画效果经历了以下3个步骤： 隐藏底部按钮（通过控制按钮的透明度、缩放比例） 从顶部执行循环揭露动画 监听器监听到揭露动画执行完后，显示底部按钮（还是通过控制按钮的透明度、缩放比例） 3. 在点击位置创建循环揭露动画 首先，给橘色圆添加触摸监听事件，获取点击到的橘色圆的位置坐标： 123456789findViewById(R.id.iv_square_orange).setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (v.getId() == R.id.iv_square_orange) &#123; revealOrangeAtPoint(event.getRawX(), event.getRawY()); &#125; return false; &#125;&#125;); 接着，就跟前面一样了，根据获取到的坐标位置创建循环揭露动画： 1234567891011private void revealOrangeAtPoint(float rawX, float rawY) &#123; int centerX = (int) rawX; int centerY = (int) rawY; int endRadius = (int) Math.hypot(bgViewGroup.getWidth(), bgViewGroup.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.orange); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start();&#125; 4. 属性变化动画+循环揭露动画 这个会难那么一丢丢，毕竟是两个动画效果的组合技，但是只要抓住上一篇讲的属性变化动画和上面讲的循环揭露动画这两个点，就不难理解了。 123456789101112131415161718192021222324252627private void revealRedAtCenter() &#123; final ViewGroup.LayoutParams originalParams = ivSquareRed.getLayoutParams(); Transition transition = TransitionInflater.from(this).inflateTransition(R.transition.changebounds_with_arcmotion); transition.addListener(new Transition.TransitionListener() &#123; @Override public void onTransitionEnd(Transition transition) &#123; int centerX = (bgViewGroup.getLeft() + bgViewGroup.getRight()) / 2; int centerY = (bgViewGroup.getTop() + bgViewGroup.getBottom()) / 2; int endRadius = (int) Math.hypot(bgViewGroup.getWidth(), bgViewGroup.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.red); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start(); ivSquareRed.setLayoutParams(originalParams); &#125; ... &#125;); TransitionManager.beginDelayedTransition(bgViewGroup, transition); RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT); params.addRule(RelativeLayout.CENTER_IN_PARENT); ivSquareRed.setLayoutParams(params);&#125; 五、总结本篇的重点就1个内容：createCircularReveal (View view, int centerX, int centerY, float startRadius, float endRadius) 只要抓住这两条主线，其它的内容都可以按主线来抽丝拨茧，一切难题都可以迎刃而解。 项目代码已分享到Github：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 六、参考资料Material Animations PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Animations 3：View Animations]]></title>
    <url>%2FMaterialAnimations3_ViewAnimations.html</url>
    <content type="text"><![CDATA[项目地址：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 一、前言 Transition框架可以用来给一个View的布局属性变化增加动画效果。你要做的事，就是改变你想改变的属性，然后Transition框架就会自动为你展示必要的动画效果。 Transition框架也可以用来给当前界面布局(current activity layout)里面的元素变化增加动画效果。Transition发生在各个场景(Scenes)中，一个场景只是我们UI布局中的一个常见的静态布局而已。只要从一个场景切换到另一个，Transition框架就会自动为场景的切换增加动画效果。 属性变化指的是某一个View，比如一个ImageView，它的宽度、高度、位置等参数的变化；元素变化指的是整个布局、场景里面的元素位置等参数的变化。它们的区别主要在于面向的对象不同，一个是针对View，一个是针对Layout。 二、效果图 属性变化 元素变化 三、属性变化1. 调用beginDelayedTransition()方法调用这行代码，就相当我们告诉Transition框架，“大哥，界面要变化了，你准备下，帮忙给点动效撒～” 1TransitionManager.beginDelayedTransition(llytRoot); 2. 改变View的属性然后只要改变View的某一个或多个属性。 123ViewGroup.LayoutParams params = ivSquareGreen.getLayoutParams();params.width = 200;ivSquareGreen.setLayoutParams(params); 改变View的宽度属性，会触发layoutMeasure，Transition框架就会记录下起始值和结束值，然后展示从起始值到结束值的动画效果。 四、元素变化1. 调用getSceneForLayout()方法这个方法会根据每一个布局文件，创建出一个个的场景(Scene)。 1234scene1 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene1, this);scene2 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene2, this);scene3 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene3, this);scene4 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene4, this); 2. 调用go()方法调用这个方法，会跳转到下一个场景，并基于当前场景和目标场景展示指定的动画效果。 1TransitionManager.go(scene1, new ChangeBounds()); 五、参考资料Material Animations PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design风格常用控件的使用与定制]]></title>
    <url>%2FMaterial%20Design%E9%A3%8E%E6%A0%BC%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9A%E5%88%B6.html</url>
    <content type="text"><![CDATA[项目地址：https://github.com/SherlockShi/MaterialWidgetPractise 一、前言你是否还在使用selector来定制Button普通状态、按下状态的变化呢？ 你是否也想自己的Button有Material Design的阴影效果呢？ 你是否也想让各种控件轻松变换各种颜色风格呢？ 那么看完这篇分享，你就会有答案了。 二、4种风格的Button系统默认有4种风格的Button效果，分别是 1234567Widget.AppCompat.ButtonWidget.AppCompat.Button.ColoredWidget.AppCompat.Button.BorderlessWidget.AppCompat.Button.Borderless.Colored 效果如下（1-4）： 按命名、并结合效果图可以看出，这4种风格对应两个属性：字体颜色、边框颜色（或称背景颜色）; 4种风格可完整描述为默认边框默认字体、彩色边框默认字体、无边框默认字体、无边框彩色字体，使用方法也很简单，只需在普通Button的xml布局文件中，加上style属性即可： 123456789101112131415&lt;Button ... style="@style/Widget.AppCompat.Button" /&gt;&lt;Button ... style="@style/Widget.AppCompat.Button.Colored" /&gt;&lt;Button ... style="@style/Widget.AppCompat.Button.Borderless" /&gt;&lt;Button ... style="@style/Widget.AppCompat.Button.Borderless.Colored" /&gt; 从上图也可以看到，不加style属性的话，默认是使用Widget.AppCompat.Button风格的。 后面两种无边框Button，只需要改变textColor属性来设置效果，没什么好说的；主要是前面两种，其实就是同一种效果：有边框颜色的Button，如何定制请看下一节内容。 三、各种颜色的Button你是否还在用selector文件来定制各种颜色、各种不同状态下的Button呢？如果一个应用中需要10个不同的Button，你是否需要定义10*4个xml文件呢？(normal状态+pressed状态+disabled状态+selector选择器) 其实使用系统的Button控件就可以轻松实现，只需要配置一定的属性。 首先，确保主题使用Material风格主题需要使用Theme.AppCompat或Theme.Design类的子主题（建议使用Theme.AppCompat子类主题，兼容Android 5.0以下版本），如Theme.AppCompat.Light。 其次，在style文件中设置Button颜色在styles.xml文件中设置colorButtonNormal属性： values/styles.xml 123&lt;style name="RedButton"&gt; &lt;item name="colorButtonNormal"&gt;#F44336&lt;/item&gt;&lt;/style&gt; 好了，一起来见证奇迹在布局文件中定义Button，增加theme属性(注意，是theme，不是style)： 123&lt;Button ... android:theme="@style/RedButton" /&gt; 效果如下： 现在，就可以看到Button变成了你想要的颜色，而且点击后Button颜色也加深了，完全跟使用selector定制出来的一模一样。并且如果使用Android 5.0以上的手机，还会默认带有水纹波和阴影的炫酷效果。 四、其它各种常用控件 其余控件像CheckBox、RadioButton，可以用colorControlNormal、colorControlActivated（或colorAccent）来控制正常状态和按下状态的背景颜色； 而像Switch、EditText等控件，可以用colorControlActivated（或colorAccent）来控制背景颜色。 五、总结其实本篇主要只有两部分内容： 4种Button风格： 1234Widget.AppCompat.ButtonWidget.AppCompat.Button.ColoredWidget.AppCompat.Button.BorderlessWidget.AppCompat.Button.Borderless.Colored 4个控件属性 1234colorButtonNormal: Button正常状态颜色colorControlNormal: 控件正常状态颜色colorControlActivated: 选中或者点击获得焦点后的颜色colorAccent: 选中或者点击获得焦点后的颜色 现在，你是否对本篇开头的几个问题有了答案了呢？ PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为CardView添加点击后的抬升效果]]></title>
    <url>%2F%E4%B8%BACardView%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E5%90%8E%E7%9A%84%E6%8A%AC%E5%8D%87%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[一、效果图在真机上阴影效果很好，录屏效果差一点。 二、实现方法1. 创建一个TranslationZ的变换动画 res/animator/touch_raise.xml 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_enabled="true" android:state_pressed="true"&gt; &lt;objectAnimator android:duration="@android:integer/config_shortAnimTime" android:propertyName="translationZ" android:valueTo="8dp" android:valueType="floatType" /&gt; &lt;/item&gt; &lt;item&gt; &lt;objectAnimator android:duration="@android:integer/config_shortAnimTime" android:propertyName="translationZ" android:valueTo="0dp" android:valueType="floatType" /&gt; &lt;/item&gt;&lt;/selector&gt; 2. 为CardView加上属性CardView布局中加入属性android:stateListAnimator=&quot;@animator/touch_raise&quot;。 这样，你的卡片按住时就会有浮起的效果了（或称抬升、阴影加深）。 三、参考资料关于使用 CardView 开发过程中要注意的细节-泡在网上的日子 PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Animations 2：Shared Element Transition]]></title>
    <url>%2FMaterialAnimations2_SharedElements.html</url>
    <content type="text"><![CDATA[项目地址：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 一、前言元素共享变换（shared element transition）决定了共享的view元素从一个Activity/Fragment 到另一个Activity/Fragment的切换中是如何动画变化的。 请记住，共享元素变换并不是真正实现了两个Activity或者Fragment之间元素的共享，界面还是两个不同界面，只不过Framework采用了不同的方法来达到相同的视觉效果。 二、效果图 三、实现方法1. 在主题中启用窗口内容转换 values-v21/styles.xml 1234&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="android:windowContentTransitions"&gt;true&lt;/item&gt;&lt;/style&gt; 2. 在styles.xml文件中指定一个共享元素转换 values-v21/styles.xml 12345678&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="android:windowSharedElementExitTransition"&gt;@transition/def_transition&lt;/item&gt; &lt;item name="android:windowSharedElementReenterTransition"&gt;@transition/def_transition&lt;/item&gt; &lt;item name="android:windowSharedElementEnterTransition"&gt;@transition/def_transition&lt;/item&gt; &lt;item name="android:windowSharedElementReturnTransition"&gt;@transition/def_transition&lt;/item&gt;&lt;/style&gt; 此处也可以直接使用系统默认自带的转换效果，如果这么做，则下一步将转换效果定义为XML资源可省略 12345678&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="android:windowSharedElementExitTransition"&gt;@android:transition/move&lt;/item&gt; &lt;item name="android:windowSharedElementReenterTransition"&gt;@android:transition/move&lt;/item&gt; &lt;item name="android:windowSharedElementEnterTransition"&gt;@android:transition/move&lt;/item&gt; &lt;item name="android:windowSharedElementReturnTransition"&gt;@android:transition/move&lt;/item&gt;&lt;/style&gt; 3. 将转换效果定义为XML资源（可选） transition-v21/def_transition.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;transitionSet xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;changeBounds/&gt; &lt;changeTransform/&gt; &lt;changeClipBounds/&gt; &lt;changeImageTransform/&gt;&lt;/transitionSet&gt; changeBounds - 为目标视图的布局边界的变化添加动画。 changeClipBounds - 为目标视图的裁剪边界的变化添加动画。 changeTransform - 为目标视图的缩放与旋转变化添加动画。 changeImageTransform - 为目标图像的大小与缩放变化添加动画。 详细文档可参考Transition类或具体某一属性的API文档。 4. 为共享元素指定transitionName利用android:transitionName属性对两个布局中的共享元素指定一个通用名称： layout/activity_main.xml 12345678910111213&lt;ImageView android:id="@+id/iv_square_blue" android:layout_width="48dp" android:layout_height="48dp" android:src="@drawable/circle_blue" android:transitionName="@string/transition_name_square_blue"/&gt;&lt;TextView android:id="@+id/tv_element_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/activity_main_shared_elements" android:transitionName="@string/transition_name_element_title"/&gt; activity_shared_elements.xml 1234567891011&lt;ImageView android:layout_width="120dp" android:layout_height="120dp" android:src="@drawable/circle_blue" android:transitionName="@string/transition_name_square_blue"/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/activity_main_shared_elements" android:transitionName="@string/transition_name_element_title"/&gt; 要点：共享元素尽量设置固定值或wrap_content，否则在界面过渡的开始、结束位置容易出现闪屏。分析原因可能为：由于元素的居中等显示属性的不同导致，如设置文本居中显示，则元素从起始位置开始移动，到达结束位置时，先移动到结束时的居中位置，然后瞬间变到结束位置，如果这时候两个位置不一致，会造成闪屏。 5. 使用 makeSceneTransitionAnimation() 方法 MainActivity.java 1234567View ivSquareBlue = findViewById(R.id.iv_square_blue);String squareBlueTransitionName = getString(R.string.transition_name_square_blue);// only one shared elementsActivityOptionsCompat activityOptionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(this, ivSquareBlue, squareBlueTransitionName);startActivity(intent, activityOptionsCompat.toBundle()); 如果有多个共享元素，则使用以下方法： 123456789101112View ivSquareBlue = findViewById(R.id.iv_square_blue);String squareBlueTransitionName = getString(R.string.transition_name_square_blue);View tvElementTitle = findViewById(R.id.tv_element_title);String elementTitleTransitionName = getString(R.string.transition_name_element_title);// multiple shared elementsActivityOptionsCompat activityOptionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(this, Pair.create(ivSquareBlue, squareBlueTransitionName), Pair.create(tvElementTitle, elementTitleTransitionName));startActivity(intent, activityOptionsCompat.toBundle()); 四、参考资料Material Animations定义定制动画-Android开发文档 PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Animations 1：Content Transitions]]></title>
    <url>%2FMaterialAnimations1_ContentTransitions.html</url>
    <content type="text"><![CDATA[项目地址：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 一、前言 同overridePendingTransition()方法执行效果类似 Content Transition也称为Transitions between Activities，或Enter/Exit Transition，包括下图4个部分（本图截取自Udacity）： 1. Exit A: 离开A界面时的转换动画 2. Enter B: 进入B界面时的转换动画 3. Return B: 从B界面返回时的转换动画；可不设置，默认执行Enter B的逆过程 4. Reenter A: 重新进入A界面时的转换动画；可不设置，默认执行Exit A的逆过程 二、效果图 三、实现方法1. 编码实现 ActivityA.java 1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_a); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Slide slide = new Slide(); slide.setDuration(500); slide.setSlideEdge(Gravity.LEFT); getWindow().setExitTransition(slide);// getWindow().setReenterTransition(slide);&#125; ActivityB.java 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_b); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Fade fade = new Fade(); fade.setDuration(500); getWindow().setEnterTransition(fade);// getWindow().setReturnTransition(slide);&#125; 由于大部分相关API只支持API 19以上版本，甚至只支持API 21以上版本，因此需要添加如下判断： 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; ...&#125; 2. XML &amp; Code实例化实现定义XML res/transition-v21/fade.xml 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;fade xmlns:android="http://schemas.android.com/apk/res/" android:duration="500"/&gt; res/transition-v21/slide.xml 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;slide xmlns:android="http://schemas.android.com/apk/res/" android:duration="500"/&gt; Code实例化 ActivityA.java 1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_a); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Slide slide = TransitionInflater.from(this).inflateTransition(R.transition.slide); getWindow().setExitTransition(slide);&#125; ActivityB.java 1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_b); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Fade fade = TransitionInflater.from(this).inflateTransition(R.transition.fade); getWindow().setEnterTransition(fade);&#125; 3. XML &amp; Style声明式实现（强烈推荐）定义XML 如果没有其它属性要求，本步骤可跳过，直接在下一步使用系统定义好的XML 同XML &amp; Code实例化实现一样，声明XML文件 res/transition-v21/fade.xml 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;fade xmlns:android="http://schemas.android.com/apk/res/" android:duration="500"/&gt; res/transition-v21/slide.xml 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;slide xmlns:android="http://schemas.android.com/apk/res/" android:duration="500"/&gt; Style文件声明 res/values-v21/styles.xml 12345678&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="android:windowExitTransition"&gt;@transition/slide&lt;/item&gt; &lt;item name="android:windowReenterTransition"&gt;@transition/slide&lt;/item&gt; &lt;item name="android:windowEnterTransition"&gt;@transition/slide&lt;/item&gt; &lt;item name="android:windowReturnTransition"&gt;@transition/slide&lt;/item&gt;&lt;/style&gt; 也可以直接使用系统提供的过渡效果： 12345678&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="android:windowExitTransition"&gt;@android:transition/slide_left&lt;/item&gt; &lt;item name="android:windowReenterTransition"&gt;@android:transition/slide_left&lt;/item&gt; &lt;item name="android:windowEnterTransition"&gt;@android:transition/slide_right&lt;/item&gt; &lt;item name="android:windowReturnTransition"&gt;@android:transition/slide_right&lt;/item&gt;&lt;/style&gt; 声明打开Content Transitions（非必须） 如果上一个步骤继承的父主题不是AppCompt相关主题，还需要在styles.xml文件中声明: 1&lt;item name="android:windowContentTransitions"&gt;true&lt;/item&gt; 四、跳转12startActivity(new Intent(ActivityA.this, ActivityB.class), ActivityOptionsCompat.makeSceneTransitionAnimation(ActivityA.this).toBundle()); 五、返回1finishAfterTransition(); 六、参考资料https://github.com/lgvalle/Material-Animations PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeppt常用功能]]></title>
    <url>%2Fnodeppt%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[更多功能请参考nodeppt官方文档 一、 启动1nodeppt start 二、导出html导出全部，包括nodeppt的js、img和css文件夹默认导出在publish文件夹1nodeppt generate filepath -a 三、导出ppt使用url?print=1访问页面，然后选择chrome的系统打印即可：打印 -&gt; 使用系统对话框进行打印 -&gt; (左下角)存储为PDF... 注意url中不能包含“#1”等具体页码信息，否则打印时会只打印一页]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>PPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android程序员简历模板]]></title>
    <url>%2FAndroid%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[其他程序员简历模板可参考ResumeSample Android程序员简历模板本简历模板由国内首家互联网人才拍卖网站「 JobDeer.com 」提供。 （括号里的是我们的顾问编写的说明，建议在简历书写完成后统一删除） 先讲讲怎样才是一份好的技术简历首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。 Feature：是什么 Advantage：比别人好在哪些地方 Benefit：如果雇佣你，招聘方会得到什么好处 其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。 举个例子，下边内容是虚构的： 2006年，我参与了手机XX网发布系统WAPCMS的开发（这部分是大家都会写的）。作为核心程序员，我不但完成了网站界面、调度队列的开发工作，更提出了高效的组件级缓存系统，通过碎片化缓冲有效的提升了系统的渲染效率。（这部分是很多同学忘掉的，要写出你在这个项目中具体负责的部分，以及你贡献出来的价值。）在该系统上线后，Web前端性能从10QPS提升到200QPS，服务器由10台减少到3台（通过量化的数字来增强可信度）。2008年我升任WAPCMS项目负责人，带领一个3人小组支持着每天超过2亿的PV（这就是Benefit。你能带给前雇主的价值，也就是你能带给新雇主的价值。）。 有同学问，如果我在项目里边没有那么显赫的成绩可以说怎么办？讲不出成绩时，就讲你的成长。因为学习能力也是每家公司都看中的东西。你可以写你在这个项目里边遇到了一个什么样的问题，别人怎么解决的，你怎么解决的，你的方案好在什么地方，最终这个方案的效果如何。 具体、量化、有说服力，是技术简历特别需要注重的地方。 （以上内容在写完简历后，对每一段进行评估，完成后再删除） 联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机：135** （如果是外地手机，可注明。如经常关机，要写上最优联系时间） Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G） QQ/微信号：6*（提供一个通过网络可以联系到你的方式） 个人信息 胶布帝/男/1990 本科/萌鹿大学计算机系 工作年限：3年 微博：@JobDeer （如果没有技术相关内容，也可以不放） 技术博客：http://blog.github.io ( 使用GitHub Host的Big较高 ) GitHub: http://github.com/geekcompany ( 有原创repo的GitHub帐号会极大的提升你的个人品牌 ) 期望职位：Android高级程序员，应用架构师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目（对于程序员来讲，没有什么比Show me the code能有说服力了） STU : 项目的简要说明，Star和Fork数多的可以注明 WXYZ : 项目的简要说明，Star和Fork数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自HeroKu的HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014架构师大会演讲：如何通过Docker优化内部开发 9月公司内部分享：云计算的前生今世 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 参考技能关键字本技能关键字列表是从最近招聘Android的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。 android(1830) java(386) ui(180) app(178) http(149) sdk(135) tcp(95) socket(93) api(60) xml(48) framework(48) eclipse(41) linux(38) json(28) ndk(27) ios(27) sqlite(26) andriod(25) 2%的HR把android给写错了 T_T html5(25) web(23) github(21) jni(20) svn(15) gui(14) git(13) wifi(10) 3g(10) j2me(10) mysql(10) oracle(9) html(9) sql(8) tv(8) mvc(8) lbs(8) code review(7) im(7) mobile(6) view(6) stackoverflow(6) xmpp(6) o2o(5) ue(5) objective(5) js(5) blog(5) andorid(5) rom(5) launcher(5) restful(5) webservice(4) apk(4) androidsdk(4) oo(4) javascript(4) j2ee(4) opengl(4) uml(4) sms(3) windows(3) market(3) audio(3) httptps(3) udp(3) store(3) php(3) unity3d(3) native(3) webview(3) 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一、启动服务预览1hexo s hexo s = hexo server 二、快捷部署1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g == hexo generate #生成静态网页hexo d == hexo deploy #开始部署]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宽高比可配置的ImageView-AspectRatioImageView]]></title>
    <url>%2F%E5%AE%BD%E9%AB%98%E6%AF%94%E5%8F%AF%E9%85%8D%E7%BD%AE%E7%9A%84ImageView-AspectRatioImageView.html</url>
    <content type="text"><![CDATA[Github项目地址：https://github.com/SherlockShi/AspectRatioImageView 一、前言在项目开发过程中，经常会有这样的情况：美工MM切好一张图，个人信息界面顶部的背景，美美的，但是要求宽高比例一定要5：3，不然图片会变形。好，说干就干。 width肯定是要match_parent了，图片宽度才能与屏幕宽度一致，但是高度呢？wrap_content？那肯定不行，图片肯定变形了。某个固定的高度值呢？那也不行。 如此，便有了这个方便的自定义View - AspectRatioImageView，简单得只需要像普通的ImageView一样使用，再配置一定的宽度比例值、高度比例值，就可轻松实现上面的需求了。 二、一言不合就上图 三、使用方法依赖使用Gradle依赖:1234dependencies &#123; ... compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1'&#125; 或使用Maven依赖:123456&lt;dependency&gt; &lt;groupId&gt;com.sherlockshi.widget&lt;/groupId&gt; &lt;artifactId&gt;aspectratioimageview&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 用法像使用ImageView一样，在XML文件中使用:1234567&lt;com.sherlockshi.widget.AspectRatioImageView android:layout_width="match_parent" android:layout_height="0dp" android:scaleType="centerCrop" app:width_ratio="4" app:height_ratio="2" android:src="..."/&gt; 属性AspectRatioImageView有以下两个属性:width_ratio: 宽度比例值，类型为integerheight_ratio: 高度比例值，类型为integer 以上两个属性，只要有一个属性未设置，就会使用默认比例3:2. 以上，你就可以和美工MM愉快地出去喝一杯了，不不，你就可以轻松实现项目需求了。 PS：欢迎关注SherlockShi博客]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Android Studio把自己的Android library分发到JCenter]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Android%20Studio%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84Android%20library%E5%88%86%E5%8F%91%E5%88%B0jCenter.html</url>
    <content type="text"><![CDATA[前言如果你想在Android Studio中引入一个library到你的项目，你只需添加如下的一行代码到模块的build.gradle文件中: 1compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1' 就是如此简单的一行代码，你就可以使用这个library了。 酷呆了。不过你可能很好奇Android Studio是从哪里得到这个library的。这篇文章将详细讲解这是怎么回事，包括如何把你的库发布出去分享给世界各地的其他开发者，这样不仅可以让世界更美好，还可以耍一次酷。 一、Android studio 是从哪里得到库的？先从这个简单的问题开始，我相信不是每个人都完全明白Android studio 是从哪里得到这些library的。莫非就是Android studio 从google搜索然后下载了一个合适的给我们？ 呵呵，没那么复杂。Android Studio是从build.gradle里面定义的Maven 仓库服务器上下载library的。Apache Maven是Apache开发的一个工具，提供了用于贡献library的文件服务器。总的来说，只有两个标准的Android library文件服务器：JCenter 和 Maven Central。 1. JCenterJCenter是一个由bintray.com维护的Maven仓库 。你可以在这里看到整个仓库的内容。我们在项目的build.gradle 文件中如下定义仓库，就能使用JCenter了： 12345allprojects &#123; repositories &#123; jcenter() &#125;&#125; 2. Maven CentralMaven Central 则是由sonatype.org维护的Maven仓库。你可以在这里看到整个仓库。 注：不管是JCenter还是Maven Central ，两者都是Maven仓库 我们在项目的build.gradle 文件中如下定义仓库，就能使用Maven Central了： 12345allprojects &#123; repositories &#123; mavenCentral() &#125;&#125; 注意，虽然JCenter和Maven Central 都是标准的 android library仓库，但是它们维护在完全不同的服务器上，由不同的人提供内容，两者之间毫无关系。在JCenter上有的可能 Maven Central 上没有，反之亦然。 除了两个标准的服务器之外，如果我们使用的library的作者是把该library放在自己的服务器上，我们还可以自己定义特有的Maven仓库服务器。Twitter的Fabric.io 就是这种情况，它们在 https://maven.fabric.io/public 上维护了一个自己的Maven仓库。如果你想使用Fabric.io的library，你必须自己如下定义仓库的url。 123repositories &#123; maven &#123; url 'https://maven.fabric.io/public' &#125;&#125; 然后在里面使用相同的方法获取一个library: 1compile 'com.crashlytics.sdk.android:crashlytics:2.2.4@aar' 但是将library上传到标准的服务器与自建服务器，哪种方法更好呢？当然是前者。如果将我们的library公开，其他开发者除了一行定义依赖名的代码之外不需要定义任何东西。因此这篇文章中，我们将只关注对开发者更友好的JCenter 和 Maven Central 。 实际上可以在Android Studio上使用的除了Maven 仓库之外还有另外一种仓库：Ivy 仓库 。但是根据我的经验来看，我还没看到任何人用过它，包括我，因此本文就直接忽略了。 二、理解JCenter和Maven Central为何有两个标准的仓库？ 事实上两个仓库都具有相同的使命：提供Java或者Android library服务。上传到哪个（或者都上传）取决于开发者。 起初，Android Studio 选择Maven Central作为默认仓库。如果你使用老版本的Android Studio创建一个新项目，mavenCentral()会自动的定义在build.gradle中。 但是Maven Central的最大问题是对开发者不够友好。上传library异常困难。上传上去的开发者都是某种程度的极客。同时还因为诸如安全方面的其他原因，Android Studio团队决定把默认的仓库替换成JCenter。正如你看到的，一旦使用最新版本的Android Studio创建一个项目，JCenter()自动被定义，而不是mavenCentral()。 有许多将Maven Central替换成JCenter的理由，下面是几个主要的原因。 JCenter通过CDN发送library，开发者可以享受到更快的下载体验。 JCenter是全世界最大的Java仓库，因此在Maven Central 上有的，在JCenter上也极有可能有。换句话说JCenter是Maven Central的超集。 上传library到仓库很简单，不需要像在Maven Central上做很多复杂的事情。 友好的用户界面 如果你想把library上传到Maven Central ，你可以在bintray网站上直接点击一个按钮就能实现。 基于上面的原因以及我自己的经验，可以说替换到JCenter是明智之举。 所以我们这篇文章将把重心放在JCenter，反正如果你能成功把library放在JCenter，转到 Maven Central 是非常容易的事情。 三、gradle是如何从仓库上获取一个library的？在讨论如何上传library到JCenter之前，我们先看看gradle是如何从仓库获取library的。比如我们在 build.gradle输入如下代码的时候，这些库是如果奇迹般下载到我们的项目中的。 1compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1' 一般来说，我们需要知道library的字符串形式，包含3部分 1GROUP_ID:ARTIFACT_ID:VERSION 上面的例子中，GROUP_ID是com.sherlockshi.widget，ARTIFACT_ID是aspectratioimageview，VERSION是1.0.1。 GROUP_ID定义了library的group。有可能在同样的上下文中存在多个不同功能的library。如果library具有相同的group，那么它们将共享一个GROUP_ID。通常我们以开发者包名紧跟着library的group名称来命名，比如com.squareup.picasso。然后ARTIFACT_ID中是library的真实名称。至于VERSION，就是版本号而已，虽然可以是任意文字，但是我建议设置为x.y.z的形式，如果喜欢还可以加上beta这样的后缀。 下面是Square library的一个例子。你可以看到每个都可以很容易的分辨出library和开发者的名称。 123456dependencies &#123; compile 'com.squareup:otto:1.3.7' compile 'com.squareup.picasso:picasso:2.5.2' compile 'com.squareup.okhttp:okhttp:2.4.0' compile 'com.squareup.retrofit:retrofit:1.9.0'&#125; 那么在添加了上面的依赖之后会发生什么呢？简单。Gradle会询问Maven仓库服务器这个library是否存在，如果是，gradle会获得请求library的路径，一般这个路径都是这样的形式：GROUP_ID/ARTIFACT_ID/VERSION_ID。比如可以在http://jcenter.bintray.com/com/squareup/otto/1.3.7 和 https://oss.sonatype.org/content/repositories/releases/com/squareup/otto/1.3.7/下获得com.squareup:otto:1.3.7的library文件。 然后Android Studio 将下载这些文件到我们的电脑上，与我们的项目一起编译。整个过程就是这么简单，一点都不复杂。 我相信你应该清楚的知道从仓库上下载的library只是存储在仓库服务器上的jar 或者aar文件而已。有点类似于自己去下载这些文件，拷贝然后和项目一起编译。但是使用gradle依赖管理的最大好处是你除了添加几行文字之外啥也不做。library一下子就可以在项目中使用了。 四、了解aar文件等等，我刚才说了仓库中存储的有两种类型的library：jar 和 aar。jar文件大家都知道，但是什么是aar文件呢？ aar文件时在jar文件之上开发的。之所以有它是因为有些Android Library需要植入一些安卓特有的文件，比如AndroidManifest.xml，资源文件，Assets或者JNI。这些都不是jar文件的标准。 因此aar文件就时发明出来包含所有这些东西的。总的来说它和jar一样只是普通的zip文件，不过具有不同的文件结构。jar文件以classes.jar的名字被嵌入到aar文件中。其余的文件罗列如下：– /AndroidManifest.xml (mandatory)– /classes.jar (mandatory)– /res/ (mandatory)– /R.txt (mandatory)– /assets/ (optional)– /libs/.jar (optional)– /jni//.so (optional)– /proguard.txt (optional)– /lint.jar (optional)可以看到.aar文件是专门为安卓设计的。因此这篇文章将教你如何创建与上传一个aar形式的library。 五、如何上传library到JCenter我相信你已经知道了仓库系统的大体工作原理。现在我们来开始最重要的部分：上传。这个任务和如何上传library文件到http://jcenter.bintray.com 一样简单。如果做到，这个library就算发布了。好吧，有两个需要考虑：如何创建aar文件以及如何上传构建的文件到仓库。 虽然需要若干步骤，但是我还是想强调这事并不复杂，因为已经准备好了所有事情。整个过程如下图： 因为细节比较多，我分为以下几个部分，一步一步的详细解释清楚。 1. 在bintray上创建package第一步 在bintray.com上注册一个账号。（注册过程很简单，自己完成，也可以直接使用Github账号） 第二步 完成注册之后，登录网站，然后点击+号 第三步 输入Repository相关信息，创建一个Repository 第四步 点击打开刚才创建好的Repository 第五步 点击Add New Package，为我们的library创建一个新的package 第六步 按页面要求填写相关信息 完工！现在你有了自己在Bintray上的Maven仓库，可以准备上传library到上面了。 2. 准备一个Android Studio项目很多情况下，我们需要同时上传一个以上的library到仓库，也可能不需要上传东西。因此我建议最好将每部分分成一个Module。最好分成两个module，一个Application Module一个Library Module。Application Module用于展示库的用法，Library Module是library的源代码。如果你的项目有一个以上的library，尽量创建另外的module：1个 module对应1 个library。我相信大家知道如何创建一个新的module，因此就不会深入讲解这个问题了。其实很简单，基本就是选择 File -&gt; New -&gt; Module，选择Android Library，然后就完了。 添加bintray插件 我们需要修改项目的build.gradle文件中的依赖部分，如下： 12345dependencies &#123; ... classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1'&#125; 配置Bintray账号以及开发者信息 接下来我们将修改local.properties。在里面定义api key的用户名以及被创建key的密码，用于bintray的认证。之所以要把这些东西放在这个文件是因为这些信息时比较敏感的，不应该到处分享，包括版本控制里面。幸运的是在创建项目的时候local.properties文件就已经被添加到.gitignore了。因此这些敏感数据不会被误传到git服务器。 下面是要添加的代码： 12345678#bintraybintray.user=******bintray.apikey=******#developerdeveloper.id=******developer.name=******developer.email=****** bintray.user：你的Bintray的用户名 bintray.apikey：你的的Bintray的API Key,可以在Edit Profile页面的 API Key 选项卡中找到 developer.id：通常是你在开源社区的昵称 developer.name：你的姓名 developer.email：你的邮箱 配置项目信息 在library module目录下新建project.properties文件，输入以下内容： 1234567891011#projectproject.name=AspectRatioImageViewproject.bintrayRepo=android-widgetsproject.groupId=com.sherlockshi.widgetproject.artifactId=aspectratioimageviewproject.packaging=aarproject.siteUrl=https://github.com/SherlockShi/AspectRatioImageViewproject.gitUrl=https://github.com/SherlockShi/AspectRatioImageView.git#javadocjavadoc.name=AspectRatioImageView project.name：项目名称 project.groupId：项目组ID project.artifactId：项目ID project.packaging：包类型，Android库是aar project.siteUrl：项目官方网站的地址，没有的话就用Github上的地址 project.gitUrl：项目的Git地址 javadoc.name：生成的javadoc打开后主页显示的名称，通常跟项目名称一样即可 配置bintrayUpload.gradle 本步骤也可以直接使用别人打包好的脚本引入即可，但本文主要介绍原理，有需要的可以自己搜索。 首先在library module目录下新建bintrayUpload.gradle文件，直接粘贴以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'// load propertiesProperties properties = new Properties()File localPropertiesFile = project.file("../local.properties");if(localPropertiesFile.exists())&#123; properties.load(localPropertiesFile.newDataInputStream())&#125;File projectPropertiesFile = project.file("project.properties");if(projectPropertiesFile.exists())&#123; properties.load(projectPropertiesFile.newDataInputStream())&#125;// read propertiesdef projectName = properties.getProperty("project.name")def projectBintrayRepo = properties.getProperty("project.bintrayRepo")def projectGroupId = properties.getProperty("project.groupId")def projectArtifactId = properties.getProperty("project.artifactId")def projectVersionName = android.defaultConfig.versionNamedef projectPackaging = properties.getProperty("project.packaging")def projectSiteUrl = properties.getProperty("project.siteUrl")def projectGitUrl = properties.getProperty("project.gitUrl")def developerId = properties.getProperty("developer.id")def developerName = properties.getProperty("developer.name")def developerEmail = properties.getProperty("developer.email")def bintrayUser = properties.getProperty("bintray.user")def bintrayApikey = properties.getProperty("bintray.apikey")def javadocName = properties.getProperty("javadoc.name")group = projectGroupId// This generates POM.xml with proper parametersinstall &#123; repositories.mavenInstaller &#123; pom &#123; project &#123; name projectName groupId projectGroupId artifactId projectArtifactId version projectVersionName packaging projectPackaging url projectSiteUrl licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; id developerId name developerName email developerEmail &#125; &#125; scm &#123; connection projectGitUrl developerConnection projectGitUrl url projectSiteUrl &#125; &#125; &#125;.writeTo("$buildDir/poms/pom-default.xml").writeTo("pom.xml") &#125;&#125;// This generates sources.jartask sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;// This generates javadoc.jartask javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;// javadoc configurationjavadoc &#123; options&#123; encoding "UTF-8" charSet 'UTF-8' author true version projectVersionName links "http://docs.oracle.com/javase/7/docs/api" title javadocName &#125;&#125;// bintray configurationbintray &#123; user = bintrayUser key = bintrayApikey configurations = ['archives'] pkg &#123; repo = projectBintrayRepo name = projectName websiteUrl = projectSiteUrl vcsUrl = projectGitUrl licenses = ["Apache-2.0"] publish = true &#125;&#125; 然后修改你的library module的build.gradle文件，在最后加上： 1apply from: "bintrayUpload.gradle" 3. 把library上传到你的bintray空间打开终端进入项目目录下，执行gradlew bintrayUpload命令即可 另外，如果你的本地已经配置了Gradle了，那么执行gradle bintrayUpload命令也可以。gradlew是Gradle的一层封装，如果你本地没有安装Gradle, gradlew就会自动下载Gradle。 在bintray的网页上检查一下你的package。你会发现在版本区域的变化。 点击进去，进入Files选项卡，你会看见那里有我们所上传的library文件。 恭喜，你的library终于放在了互联网上，任何人都可以使用了！ 不过也别高兴过头，library现在仍然只是在你自己的Maven仓库，而不是在JCenter上。如果有人想使用你的library，他必须定义仓库的url，如下： 1234567891011repositories &#123; maven &#123; url 'https://dl.bintray.com/sherlockshi/android-widgets/' &#125;&#125;...dependencies &#123; compile 'com.sherlockshi.widgets:aspectratioimageview:1.0.1'&#125; 你可以在bintray的web界面找到自己Maven仓库的url，或者直接吧nuuneoi替换成你的bintray用户名（因为前面部分其实都是一样的）。我还建议你直接访问那个链接，看看里面到底是什么。 但是，就如我们前面所讲的那样，让开发者去定义url这种复杂的事情并不是分享library的最佳方式。想象一下，使用10个library不得添加10个url？所以为了更好的体验，我们把library从自己的仓库传到JCenter上。 4. 同步bintray用户仓库到JCenter把library同步到JCenter非常容易，只需访问网页在package界面Linked To区域点击右下角的Add to JCenter，什么也不用填，直接点击Send。 现在我们所能做的就是等待bintray团队审核我们的请求，大概4-5个小时。一旦同步的请求审核通过，你会收到一封确认此更改的邮件。现在我们去网页上确认，你会在 Linked To 部分看到已链接到JCenter仓库。 5. 用法从此之后，任何开发者都可以使用JCenter() repository 外加一行gradle脚本来使用我们的library了 1compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1' 想检查一下自己的library在JCenter上是否存在？你可以直接访问http://jcenter.bintray.com ，然后进入和你library的group id 以及artifact id匹配的目录。在本例中就是com -&gt; sherlockshi -&gt; widget -&gt; aspectratioimageview -&gt; 1.0.1。 请注意链接到JCenter是一个只需做一次的操作。如果你对你的package做了任何修改，比如上传了一个新版本的binary，删除了旧版本的binary等等，这些改变也会影响到JCenter。不过毕竟你自己的仓库和JCenter在不同的地方，所以需要等待2－3分钟让JCenter同步这些修改。 同时注意，如果你决定删除整个package，放在JCenter仓库上的library不会被删除。它们会像僵尸一样的存在，没有人再能删除它了。因此我建议，如果你想删除整个package，请在移除package之前先在网页上删除每一个版本。 恭喜！虽然需要许多步骤，但是每一步都很简单。而且大部分操作都是一劳永逸的。 期待能在上面看到你的library大作！ 六、踩坑经历1. 编译上传时，提示jar包未找到12:aspectratioimageview:bintrayUpload: file /Users/sherlock/work/workspace/AndroidStudio/AspectRatioImageView/aspectratioimageview/build/libs/aspectratioimageview-1.0.1-javadoc.jar could not be found.:aspectratioimageview:bintrayUpload: file /Users/sherlock/work/workspace/AndroidStudio/AspectRatioImageView/aspectratioimageview/build/libs/aspectratioimageview-1.0.1-sources.jar could not be found. 解决方法：先执行gradlew install，再执行gradlew bintrayUpload 2. Javadoc generation failed1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071:sherlockspinner:javadoc/path/.../xxx.java:7: 错误: 程序包android.support.annotation不存在import android.support.annotation.ColorInt; ^/path/.../xxx.java:8: 错误: 程序包android.support.annotation不存在import android.support.annotation.ColorRes; ^/path/.../xxx.java:9: 错误: 程序包android.support.annotation不存在import android.support.annotation.DrawableRes; ^/path/.../xxx.java:10: 错误: 程序包android.support.v4.content不存在import android.support.v4.content.ContextCompat; ^/path/.../xxx.java:11: 错误: 程序包android.support.v4.view不存在import android.support.v4.view.ViewCompat; ^/path/.../xxx.java:12: 错误: 程序包android.support.v7.widget不存在import android.support.v7.widget.AppCompatEditText; ^/path/.../xxx.java:13: 错误: 程序包android.support.v7.widget不存在import android.support.v7.widget.ListPopupWindow; ^/path/.../xxx.java:27: 错误: 找不到符号public class SherlockSpinner extends AppCompatEditText &#123; ^ 符号: 类 AppCompatEditText/path/.../xxx.java:35: 错误: 找不到符号 private ListPopupWindow mListPopupWindow; ^ 符号: 类 ListPopupWindow 位置: 类 SherlockSpinner/path/.../xxx.java:140: 错误: 找不到符号 public void setLineColorResource(@ColorRes int resId) &#123; ^ 符号: 类 ColorRes 位置: 类 SherlockSpinner/path/.../xxx.java:149: 错误: 找不到符号 public void setLineColor(@ColorInt int color) &#123; ^ 符号: 类 ColorInt 位置: 类 SherlockSpinner/path/.../xxx.java:208: 错误: 找不到符号 public void setDropdownIcon(@DrawableRes int resId) &#123; ^ 符号: 类 DrawableRes 位置: 类 SherlockSpinner/path/.../xxx.java:138: 警告: @param 没有说明 * @param resId ^/path/.../xxx.java:147: 警告: @param 没有说明 * @param color ^/path/.../xxx.java:170: 错误: 找不到引用 * @see #setClickable(boolean) ^/path/.../xxx.java:172: 警告 - 标记@see: 在com.sherlockshi.widget.SherlockSpinner中找不到setClickable(boolean)/path/.../xxx.java:206: 警告: @param 没有说明 * @param resId ^javadoc: 警告 - 找不到类ColorRes。javadoc: 警告 - 找不到类ColorInt。javadoc: 警告 - 找不到类DrawableRes。1 个错误19 个警告:sherlockspinner:javadoc FAILEDFAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':sherlockspinner:javadoc'.&gt; Javadoc generation failed. Generated Javadoc options file (useful for troubleshooting): '/Users/sherlock/work/workspace/AndroidStudio/SherlockSpinner/sherlockspinner/build/tmp/javadoc/javadoc.options' 解决方法： 错误: 编码GBK的不可映射字符 ——注释不要用中文，或者修改项目的字符编码 错误: 找不到符号——删除javadoc里所有的html标签 删除@see #setClickable(boolean)这一行代码注释。 七、参考如何使用Android Studio把自己的Android library分发到JCenter和Maven Central 5分钟发布Android Library项目到JCenter 使用JitPack发布Android开源库]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用natapp进行微信本地开发调试]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8natapp%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95.html</url>
    <content type="text"><![CDATA[一、在本地部署微信公众平台服务器在eclipse中使用tomcat部署微信公众平台程序 二、注册natapp 参考使用natapp超简单minecraft (我的世界) 映射开服,公网联机 1. 购买一条tcp型隧道,免费 付费均可. 2. 在后台-&gt;我的隧道 找到刚才那条购买的隧道,点击配置,输入如下配置 因tomcat默认使用的端口号是8080，所以此处的本地端口可用8080 配置好后,点击修改. 3. 下载natapp在natapp.cn下载相应版本的natapp.cn，并解压 4. 运行natapp1natapp -authtoken=ee3e7xxxxx 在Linux/Mac 下 需要先给执行权限 1chmod a+x natapp 然后再运行 1./natapp -authtoken=ee3e7xxxxx 运行成功,界面如下: 三、配置微信公众平台在微信公众平台注册公众号后，在基本配置界面，填写URL(格式为：上一步映射出来的外网IP/工程名/入口方法名)： 1tcp://ngrok.natapp.cn:33460/wechatsino/CoreServlet 点击保存即可（其余配置请参考微信公众平台进行配置） 四、调试此时，只要关注公众号后，发送消息或进行其它操作，微信公众平台就会把消息转发到上一步配置的URL对应的服务器，此处即为本地的工程，即可进行本地调试。]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio配置应用签名]]></title>
    <url>%2FAndroid%20Studio%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D.html</url>
    <content type="text"><![CDATA[本文主要参考：在gradle中为release版本配置签名 任何一个Android APK 发布之前都会进行签名，没有签名的APK是无法在Android device上进行安装和使用的，而且对于发布到Google Play上的同一个应用，自始至终必须使用同一个签名文件，所以必须保存好签名文件。本文介绍如何在build.gradle中为release版本配置签名文件，这样在打包release版本时可以自动进行签名。 明文配置一般来说，我们直接在Android Studio中配置签名文件，是使用明文配置的，如： 1234567891011121314151617android &#123; signingConfigs &#123; release &#123; storeFile file("/Users/xxx/release_key.jks") storePassword "123456789" keyAlias "release_key_alias" keyPassword "987654321" &#125; &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125; &#125;&#125; 注：此处的storeFile，如果是在Windows系统下，会是以下格式 1storeFile file("C\:\\Users\\xxx\\release_key.jks") 这样在打包release版本时就会自动签名了。 隐藏密码配置如果你的代码不会开源，或者是公司项目，公司会保护的很好，那么直接用上面的方式就可以了。但如果是开源项目，那么上面的写法就不太可取了 ，因为这样直接配置会暴露密码啊。接下来介绍如果隐藏密码进行配置： 利用property，将密码和签名文件路径信息保存在项目根目录的local.properties文件里，因为这个文件一般都在.gitignore里自动配置了，所以不会上传出去。 在根目录的local.properties文件中配置以下内容： 1234keystore.path=/Users/xxx/release_key.jkskeystore.password=123456789keystore.alias=release_key_aliaskeystore.alias_password=987654321 然后在你的app目录的build.gradle文件中增加以下代码： 123456789101112131415161718192021222324252627282930313233343536373839// =====配置keystore start=====def keystoreFilePath = ''def keystorePSW = ''def keystoreAlias = ''def keystoreAliasPSW = ''// default keystore file, PLZ config file path in local.propertiesdef keyfile = file('s.keystore.temp')Properties properties = new Properties()// local.properties file in the root directorproperties.load(project.rootProject.file('local.properties').newDataInputStream())keystoreFilePath = properties.getProperty("keystore.path")if (keystoreFilePath) &#123; keystorePSW = properties.getProperty("keystore.password") keystoreAlias = properties.getProperty("keystore.alias") keystoreAliasPSW = properties.getProperty("keystore.alias_password") keyfile = file(keystoreFilePath)&#125;// =====配置keystore end=====android &#123; signingConfigs &#123; release &#123; storeFile keyfile storePassword keystorePSW keyAlias keystoreAlias keyPassword keystoreAliasPSW &#125; &#125; buildTypes &#123; release &#123; if (keyfile.exists()) &#123; signingConfig signingConfigs.release &#125; &#125; &#125;&#125; 这样就达到了隐藏的目的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ScrollView无法match_parent的问题]]></title>
    <url>%2FAndroid%20ScrollView%E6%97%A0%E6%B3%95match_parent%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[一、问题Android ScrollView无法match_parent的问题 二、解决办法在ScrollView的属性里加上： 1234&lt;ScrollView ... android:fillViewport="true" &gt;&lt;/ScrollView&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio常见问题]]></title>
    <url>%2FAndroid%20Studio%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[Android Studio使用建议：将SDK Manager里面的相关工具提前下载下来，并定期更新 Tools目录：全部下载（包括SDK Tools、SDK Platform-tools、SDK Build-tools） 各个版本的Android SDK：按需下载，一般下载SDK Platform、Documentation、APIs、Sources Extras目录：Android Support Repository、Android Support Library、Google Repository 1. Gradle版本问题12345678910111213Error:A problem occurred configuring root project 'XylqPda'.&gt; Could not resolve all dependencies for configuration ':classpath'. &gt; Could not resolve com.android.tools.build:gradle:2.0.0. Required by: :XylqPda:unspecified &gt; Could not resolve com.android.tools.build:gradle:2.0.0. &gt; Could not get resource 'https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; Could not GET 'https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; peer not authenticated &gt; Could not resolve com.android.tools.build:gradle:2.0.0. &gt; Could not get resource 'https://jcenter.bintray.com/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; Could not GET 'https://jcenter.bintray.com/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; peer not authenticated 原因分析 一般为Android Studio版本号和Gradle版本号不一致导致。 解决方法 将项目根目录下的build.gradle中dependencies内的 1classpath 'com.android.tools.build:gradle:2.1.2' 版本号设为跟Android Studio版本号一致。 2. 下载Build-tools失败12Error:failed to find Build Tools revision 24.0.1Install Build Tools 24.0.1 and sync project http://blog.csdn.net/barryhappy/article/details/44813951 3. 更新 Gradle 错误停止在Refreshing Gradle Project ,有时新建项目的时候报 Gradle Project Compile Error 等等相关的问题http://www.cnblogs.com/neozhu/p/3525404.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle基础]]></title>
    <url>%2FGradle%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[一、什么是Gradle？Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的领域专用（DSL）语言。 二、安装Gradle在Android Studio中新建项目成功后会下载Gradle，貌似这个过程不翻墙也是可以下载，但是访问特别慢，建议翻墙下载。那么下载的Gradle到什么地方呢？ Mac上会默认下载到 /Users/&lt;用户名&gt;/.gradle/wrapper/dists 目录Win平台会默认下载到 C:\Users\&lt;用户名&gt;\.gradle\wrapper\dists 目录 你会看到这个目录下有个 gradle-x.xx-all 的文件夹, 如果下载实在太慢，但是又不想翻墙的话，可以自己手动到Gradle官网、或者jcenter里下载对应的版本，然后将下载的.zip文件复制到上述的gradle-x.xx-all 文件夹下，不过还是建议让它直接下载的好。 三、项目中的 Gradle 相关目录和文件1. app/build.gradle这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 声明是Android程序apply plugin: 'com.android.application'android &#123; // 编译SDK的版本 compileSdkVersion 21 // build tools的版本 buildToolsVersion "21.1.1" defaultConfig &#123; // 应用的包名 applicationId "me.storm.ninegag" minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName "1.0.0" &#125; // java版本 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 &#125; buildTypes &#123; debug &#123; // debug模式 &#125; release &#123; // 是否进行混淆 minifyEnabled false // 混淆文件的位置 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125; // 移除lint检查的error lintOptions &#123; abortOnError false &#125;&#125;dependencies &#123; // 编译libs目录下的所有jar包 compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:support-v4:21.0.2' compile 'com.etsy.android.grid:library:1.0.5' compile 'com.alexvasilkov:foldable-layout:1.0.1' // 编译extras目录下的ShimmerAndroid模块 compile project(':extras:ShimmerAndroid')&#125; 2. gradle/这个目录下有个 wrapper 文件夹，里面可以看到有两个文件，我们主要看下 gradle-wrapper.properties 这个文件的内容： 123456#Mon Dec 28 10:00:20 PST 2015distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip 可以看到里面声明了gradle的目录与下载路径以及当前项目使用的gradle版本，这些默认的路径我们一般不会更改的，这个文件里指明的gradle版本不对也是很多导包不成功的原因之一。 3. build.gradle这个文件是整个项目的gradle基础配置文件 12345678910111213141516// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.0.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 内容主要包含了两个方面： 一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。 另一个是声明了android gradle plugin的版本，android studio 1.0正式版必须要求支持gradle plugin 1.0的版本。 4. settings.gradle这个文件是全局的项目配置文件，里面主要声明一些需要加入gradle的module 1include ':app' 四、Android Studio中几个关于Gradle的不同概念1. Gradle、Gradle Plugin：Gradle 是新一代的自动化构建工具，它是一个独立的项目，跟 AS、Android 无关，但是 Gradle 官方还是很看重 Android 开发的，Google 在推出 AS 的时候选中了 Gradle 作为构建工具，为了支持 Gradle 能在 AS 上使用，Google 做了个 AS 的插件叫 Android Gradle Plugin ，所以我们能在 AS 上使用 Gradle 完全是因为这个插件的原因。在项目的根目录有个 build.gradle 文件，里面有这么一句代码： 1classpath 'com.android.tools.build:gradle:2.1.2' 这个就是依赖 gradle 插件的代码，后面的版本号代表的是 android gradle plugin 的版本，而不是 Gradle 的版本，这个是 Google 定的，跟 Gradle 官方没关系。 2. Gradle Wrapper字面意思是Gradle的包装器，主要是这样的应用场景：假设我们本地有多个项目，一个是比较老的项目，还用着 Gradle 1.0 的版本，一个是比较新的项目用了 Gradle 2.0 的版本，但是你两个项目肯定都想要同时运行的，如果你只装了 Gradle 1.0 的话那肯定不行，所以为了解决这个问题，Google 推出了 Gradle Wrapper 的概念，就是他在你每个项目都配置了一个指定版本的 Gradle ，你可以理解为每个 Android 项目本地都有一个小型的 Gradle ，通过这个每个项目你可以支持用不同的 Gradle 版本来构建项目。 五、推荐阅读给 Android 初学者的 Gradle 知识普及Android 开发你需要了解的 Gradle 配置]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码混淆问题汇总]]></title>
    <url>%2FAndroid%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[一、问题1Android studio打包中遇到了这样的问题： 1Warning:Exception while processing task java.io.IOException: The same input jar […….jar] is specified twice. 解决办法打开proguard-rules.pro，注释掉所有的-libraryjars行，或者直接删除，如： 1#-libraryjars xxxx.jar 原因分析build.gradle文件配置了 123dependencies &#123; compile fileTree(include: '*.jar', dir: 'libs')&#125; 里面已经添加过jar包，sdk 通过 proguard 混淆代码时默认已经将 lib目录中的 jar 都已经添加到打包脚本中，所以不需要再次手动添加。 二、问题2123456789Warning:okio.DeflaterSink: can't find referenced class org.codehaus.mojo.animal_sniffer.IgnoreJRERequirementWarning:okio.Okio: can't find referenced class java.nio.file.FilesWarning:okio.Okio: can't find referenced class java.nio.file.PathWarning:okio.Okio: can't find referenced class java.nio.file.OpenOptionWarning:Exception while processing task java.io.IOException: Please correct the above warnings first.:app:transformClassesAndResourcesWithProguardForRelease FAILEDError:Execution failed for task ':app:transformClassesAndResourcesWithProguardForRelease'.&gt; java.io.IOException: Please correct the above warnings first. 解决办法123# okio-dontwarn okio.**-keep class okio.** &#123;*;&#125; 三、问题31234567891011121314151617181920212223242526272829Warning:library class android.content.res.XmlResourceParser extends or implements program class org.xmlpull.v1.XmlPullParserNote: android.support.v4.text.ICUCompatApi23: can't find dynamically referenced class libcore.icu.ICUNote: android.support.v4.text.ICUCompatIcs: can't find dynamically referenced class libcore.icu.ICUNote: android.support.v7.internal.widget.DrawableUtils: can't find dynamically referenced class android.graphics.InsetsNote: com.loc.ce: can't find dynamically referenced class android.telephony.MSimTelephonyManagerNote: com.loc.ce: can't find dynamically referenced class android.telephony.TelephonyManager2Note: com.spd.sinoss.zxing.camera.FlashlightManager: can't find dynamically referenced class android.os.ServiceManagerNote: com.spd.sinoss.zxing.camera.FlashlightManager: can't find dynamically referenced class android.os.IHardwareService$StubNote: org.kobjects.util.ChainedRuntimeException: can't find dynamically referenced class org.kobjects.util.ChainedRuntimeExceptionSENote: u.aly.ab: can't find dynamically referenced class com.ut.device.UTDeviceNote: u.aly.ac: can't find dynamically referenced class android.os.SystemPropertiesWarning:library class android.content.Intent depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.content.IntentFilter depends on program class org.xmlpull.v1.XmlSerializerWarning:library class android.content.IntentFilter depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.content.res.ColorStateList depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.AnimationDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.BitmapDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.ClipDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.ColorDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.Drawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.GradientDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.InsetDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.LayerDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.NinePatchDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.graphics.drawable.ShapeDrawable depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.util.Xml depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.util.Xml depends on program class org.xmlpull.v1.XmlSerializerWarning:library class android.util.Xml depends on program class org.xmlpull.v1.XmlPullParserWarning:library class android.view.LayoutInflater depends on program class org.xmlpull.v1.XmlPullParser 解决办法删除ksoap jar里面的xmlpull相关类： 请确认项目中没有使用到【ksoap2-android-assembly-2.6.4-jar-with-dependencies.jar】包里面的xmlpull； 若未使用，可直接用zip软件打开jar包，然后删除xmlpull文件夹。 重新打包混淆即可正常使用。 原因分析：项目中引用的【ksoap2-android-assembly-2.6.4-jar-with-dependencies.jar】包，此jar包里面的xmlpull与Android本身自带的类重复了，导致混淆打包报错。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio入门教程]]></title>
    <url>%2FAndroid%20Studio%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、前言在Android Studio出现之前，开发Android应用主要是使用Eclipse ADT，也就是说，虽然那时候Android系统已经安装在9亿台设备上，但是没有一个专门的开发环境供Android开发者来开发Android应用。直到2013年的Google I/O大会，Google发布了Android Studio 0.1版本，我们才有了像iOS开发者的XCode一样的官方IDE。 2013年5月发布早期预览版本，版本号为0.1。2014年6月发布0.8版本，至此进入beta阶段。第一个稳定版本1.0于2014年12月8日发布，之后还有好多版本，比较稳定有的1.5正式版，2.0正式版，以及现在最新的2.1版本。 早期版本的Android Studio非常的难用，内存消耗非常严重，各种Bug，只有后面的1.5版本以后的版本才比较好，现在的2.0版本已经很好了。 二、下载、安装Android开发者官方网站(需翻墙)Android开发工具网站(需翻墙)中文社区 配置建议：内存8G+JDK8 三、配置 JDK 环境变量：JAVA_HOME、PATH、CLASSPATH Windows系统设置方法 Mac系统设置方法 测试是否安装成功： java，javac，java -version 四、项目介绍在新建一个项目之前，这里先普及Android Studio和eclipse在某些概念不同的地方。 Android Studio 中，有一些概念是和 eclipse 不同的，从 eclipse 迁移至 Android Studio 会有很多上手不顺的情况发生，当然在明确了概念的不同之后，还是容易可以切换过来。 对比 eclipse Android Studio 工作区 workspace project 项目 project module 引用 preference module dependency 简单的来说，Android Stduio把一个项目比喻成一个工程的一个个模块，外部的依赖也是一个个模块，这样一个项目的结构就很清晰明了。当然也有一个缺点，就是一个窗口只能打开一个project，不能像eclipse那样一次一个窗口打开多个项目。 1. 新建项目两个方式： Android Studio欢迎界面时： start a new Android Studio project Android Studio已有打开的项目时： File -&gt; New -&gt; New Project... 2. 模拟器＝＝＝＝＝＝＝＝建议使用真机＝＝＝＝＝＝＝＝ 自带的Genymotion3. 目录结构目录展现模式：Project、Android app/ libs/： 右击jar包，Add as library main src/ res/ AndroidManifest.xml proguard-rules.pro：混淆文件 这里还有一些关于Gradle的配置文件还没有介绍，统一在下一节进行介绍。 五、Gradle介绍详见Gradle基础 六、插件 gson format android-butterknife-zelezny Android Postfix Completion ECTranslation .gitignore Android开发工具 七、常用快捷键Preferences -&gt; KeymapHelp -&gt; Default Keymap Reference 1. 常用 Action Mac OSX Win/Linux Search everywhere Double Shift Double Shift 注释代码(//) Cmd + / Ctrl + / 注释代码(/**/) Cmd + Option + / Ctrl + Shift + / 格式化代码 Cmd + Option + L Ctrl + Alt + L 清除无效包引用 Option + Control + O Alt + Ctrl + O 查找 Cmd + F Ctrl + F 查找+替换 Cmd + R Ctrl + R 上下移动代码 Option + Shift + Up/Down Alt + Shift + Up/Down 删除行 Cmd + Delete Ctrl + Y 复制行 Cmd + D Ctrl + D 重命名 Shift+F6 Shift+F6 重构 Cmd + Option + M Shift+F6 扩大缩小选中范围 Option + Up/Down Ctrl + W/Ctrl + Shift + W 快捷生成结构体 Cmd + Option + T Ctrl + Alt + T 快捷覆写方法 Cmd + O Ctrl + O 快捷定位到行首/尾 Cmd + Left/Right Ctrl + Left/Right 折叠展开代码块 Cmd + Plus,Minus Ctrl + Plus/Minus 折叠展开全部代码块 Cmd + Shift + Plus,Minus Ctrl + Shift + Plus,Minus 文件方法结构 Cmd + F12 Ctrl + F12 查找调用的位置 Ctrl + Option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U 2. 自动导包我们只有每次引用一些类的时候必须要导包，而Android Studio可以通过设置自动导包，简直太实用了. 到 Preferences -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Java 把以下选项勾上就OK了 八、常见问题详见Android Studio常见问题 九、学习资料stormzhang的Android Studio详细教程汇总Gradle中文教程Android Studio视频教程Gradle教程 十、翻墙软件1. 免费XX-Net蓝灯 2. 付费Shadowsocks云梯VPN]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andrdoid代码混淆]]></title>
    <url>%2FAndrdoid%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86.html</url>
    <content type="text"><![CDATA[本文主要参考5分钟搞定android混淆 一、前言 二、上模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#-------------------------------------------定制化区域----------------------------------------------#---------------------------------1.实体类、自定义控件------------------------keep class com.sherlockshi.core.model.entity.** &#123; *; &#125; #实体类不参与混淆-keep class com.sherlockshi.core.ui.custom.** &#123; *; &#125; #自定义控件不参与混淆#-------------------------------------------------------------------------#---------------------------------2.第三方包-------------------------------# Bugly-dontwarn com.tencent.bugly.**-keep public class com.tencent.bugly.**&#123;*;&#125;#-------------------------------------------------------------------------#---------------------------------3.与js互相调用的类------------------------#-------------------------------------------------------------------------#---------------------------------4.反射相关的类和方法-----------------------#----------------------------------------------------------------------------#---------------------------------------------------------------------------------------------------#-------------------------------------------基本不用动区域--------------------------------------------############################################### 对于一些基本指令的添加############################################### 代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5# 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames# 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses# 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose# 指定不去忽略非公共库的类成员-dontskipnonpubliclibraryclassmembers# 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify# 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses# 避免混淆泛型-keepattributes Signature# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable# 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/*#生成日志数据，gradle build时在本项目根目录输出-dump class_files.txt #apk包内所有class的内部结构-printseeds seeds.txt #未混淆的类和成员-printusage unused.txt #打印未被使用的代码-printmapping mapping.txt #混淆前后的映射#----------------------------------------------------------------------------#---------------------------------默认保留区---------------------------------############################################### Android开发中一些需要保留的公共部分############################################### 保留我们使用的四大组件，自定义的Application等等这些类不被混淆# 因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService# 保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125;# 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.**# 保留R下面的资源-keep class **.R$* &#123;*;&#125;# 保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# 保留在Activity中的方法参数是view的方法，# 这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;# 保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;# 保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;# 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;# 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event); void *(**On*Listener);&#125;# 保持自定义控件类不被混淆-keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;#----------------------------------------------------------------------------#---------------------------------webview------------------------------------# webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;#----------------------------------------------------------------------------#--------------------------------------------------------------------------------------------------- 三、分析1. 实体类、自定义控件实体类由于涉及到与服务端的交互，各种gson的交互如此等等，是要保留的，自定义控件也是一样。将你项目中实体类都拎出来，用以下语法进行保留。 12-keep class 你的实体类所在的包.** &#123; *; &#125;-keep class 你的自定义控件所在的包.** &#123; *; &#125; 如我的项目下类User的完整路径为：com.demo.login.bean.User, 那我的混淆如下 123456#---------------------------------1.实体类、自定义控件------------------------keep class com.demo.login.bean.** &#123; *; &#125; #实体类不参与混淆-keep class com.demo.android.view.** &#123; *; &#125; #自定义控件不参与混淆#------------------------------------------------------------------------- 当然你的实体类、自定义控件肯定不止这一个，请用上边的方式一一添加，如果你的实体类、自定义控件都在一个包下，那你就幸福了。 2. 第三方包打开你app下的build.gradle文件，查看你用了哪些第三方的包。 1234dependencies &#123; compile 'com.github.bumptech.glide:glide:3.7.0' compile 'org.greenrobot:eventbus:3.0.0'&#125; 我这里用了glide，eventbus。我去他们的官网把已经写好的混淆copy下来。 1234567891011121314151617181920#---------------------------------2.第三方包-------------------------------#eventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;#glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;#------------------------------------------------------------------------- 一般官网都是有混淆的，没有的话就google，也没有的话自己按照上面的写法自己写，还不会的话。。。。。只能换个包。。。。。如果你是直接包含的jar包的话，你这样写 12345678#---------------------------------2.第三方包-------------------------------#log4j-libraryjars log4j-1.2.17.jar-dontwarn org.apache.log4j.**-keep class org.apache.log4j.** &#123; *;&#125;#------------------------------------------------------------------------- 大致意思就是不混淆，不报warn。如果gradle报错的话，可以考虑注释掉-libraryjars log4j-1.2.17.jar这句。 3. 与js互相调用的类工程中没有直接跳过，一般你可以这样写 1-keep class 你的类所在的包.** &#123; *; &#125; 如果是内部类的话，你可以这样1-keepclasseswithmembers class 你的类所在的包.父类$子类 &#123; &lt;methods&gt;; &#125; 例如123-keepclasseswithmembers class com.demo.login.bean.ui.MainActivity$JSInterface &#123; &lt;methods&gt;;&#125; 4. 反射相关的类和方法工程中没有直接跳过，类的话直接这样1-keep class 你的类所在的包.** &#123; *; &#125; 四、深入了解先逐条介绍下基本指令区指令的含义 代码混淆的压缩比例，值在0-7之间：1-optimizationpasses 5 混淆后类名都为小写：1-dontusemixedcaseclassnames 指定不去忽略非公共的库的类：1-dontskipnonpubliclibraryclasses 指定不去忽略非公共的库的类的成员：1-dontskipnonpubliclibraryclassmembers 不做预校验的操作：1-dontpreverify 生成原类名和混淆后的类名的映射文件：12-verbose-printmapping proguardMapping.txt 指定混淆是采用的算法：1-optimizations !code/simplification/cast,!field/*,!class/merging/* 不混淆Annotation：1-keepattributes *Annotation*,InnerClasses 不混淆泛型：1-keepattributes Signature 抛出异常时保留代码行号：1-keepattributes SourceFile,LineNumberTable 基本指令区基本介绍完了，说下2条用的最多的指令： 保留类名不变，也就是类名不混淆，而类中的成员名不保证。当然也可以是继承XXX类的所有类名不混淆，具体代码不贴了，重在理解。 1-keep class XXXX 保留类名和成员名。当然也可以是类中特定方法，代码不贴了，理由同上。 1-keepclasseswithmembers class XXXX 五、附：完整的混淆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#-------------------------------------------定制化区域----------------------------------------------#---------------------------------1.实体类----------------------------------keep class com.demo.login.bean.** &#123; *; &#125;-keep class com.demo.main.bean.** &#123; *; &#125;#-------------------------------------------------------------------------#---------------------------------2.第三方包-------------------------------#eventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;#glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;#log4j-libraryjars log4j-1.2.17.jar-dontwarn org.apache.log4j.**-keep class org.apache.log4j.** &#123; *;&#125;#-------------------------------------------------------------------------#---------------------------------3.与js互相调用的类-------------------------keepclasseswithmembers class com.demo.login.bean.ui.MainActivity$JSInterface &#123; &lt;methods&gt;;&#125;#-------------------------------------------------------------------------#---------------------------------4.反射相关的类和方法-----------------------#TODO 我的工程里没有。。。#----------------------------------------------------------------------------#---------------------------------------------------------------------------------------------------#-------------------------------------------基本不用动区域--------------------------------------------#---------------------------------基本指令区-----------------------------------optimizationpasses 5-dontusemixedcaseclassnames-dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers-dontpreverify-verbose-printmapping proguardMapping.txt-optimizations !code/simplification/cast,!field/*,!class/merging/*-keepattributes *Annotation*,InnerClasses-keepattributes Signature-keepattributes SourceFile,LineNumberTable#----------------------------------------------------------------------------#---------------------------------默认保留区----------------------------------keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService-keep class android.support.** &#123;*;&#125;-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;-keep class **.R$* &#123; *;&#125;-keepclassmembers class * &#123; void *(**On*Event);&#125;#----------------------------------------------------------------------------#---------------------------------webview-------------------------------------keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;#----------------------------------------------------------------------------#--------------------------------------------------------------------------------------------------- 六、后言将app下的build.gradle中minifyEnabled设置为true打个包试试吧 1234release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android里Button只显示大写字母的问题]]></title>
    <url>%2FAndroid%E9%87%8CButton%E5%8F%AA%E6%98%BE%E7%A4%BA%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[一、问题在XML布局文件里面直接给Button设置英文text时，会出现text内容全部变成大写，如设置text为Take(Small)Picture，但实际显示为TAKE(SMALL)PICTURE 二、解决办法在Button的属性里加上： 123&lt;Button ... android:textAllCaps="false" /&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android官方相机教程：简单的相机应用和自定义相机]]></title>
    <url>%2FAndroid%E5%AE%98%E6%96%B9%E7%9B%B8%E6%9C%BA%E6%95%99%E7%A8%8B%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA.html</url>
    <content type="text"><![CDATA[本文基于Android相机官方教程及极客学院Wiki整理 轻松拍摄照片这节课将讲解如何使用已有的相机应用拍摄照片。 1. 请求使用相机权限如果拍照是应用的必要功能，那么应该令它在Google Play中仅对有相机的设备可见。为了让用户知道我们的应用需要依赖相机，在Manifest清单文件中添加标签: 12345&lt;manifest ... &gt; &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt; ...&lt;/manifest&gt; 如果我们的应用使用相机，但相机并不是应用的正常运行所必不可少的组件，可以将android:required设置为”false”。这样的话，Google Play 也会允许没有相机的设备下载该应用。当然我们有必要在使用相机之前通过调用hasSystemFeature(PackageManager.FEATURE_CAMERA)方法来检查设备上是否有相机。如果没有，我们应该禁用和相机相关的功能！ 2. 使用相机应用程序进行拍照利用一个描述了执行目的Intent对象，Android可以将某些执行任务委托给其他应用。整个过程包含三部分： Intent 本身，一个函数调用来启动外部的 Activity，当焦点返回到我们的Activity时，处理返回图像数据的代码。 下面的函数通过发送一个Intent来捕获照片： 12345678910static final int REQUEST_IMAGE_CAPTURE = 1;private void dispatchTakePictureIntent() &#123; if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)) &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE); &#125; &#125;&#125; 注意在调用startActivityForResult()方法之前，先调用resolveActivity()，这个方法会返回能处理该Intent的第一个Activity（译注：即检查有没有能处理这个Intent的Activity）。执行这个检查非常重要，因为如果在调用startActivityForResult()时，没有应用能处理你的Intent，应用将会崩溃。所以只要返回结果不为null，使用该Intent就是安全的。 3. 获取缩略图拍摄照片并不是应用的最终目的，我们还想要从相机应用那里取回拍摄的照片，并对它执行某些操作。 Android的相机应用会把拍好的照片编码为缩小的Bitmap，使用extra value的方式添加到返回的Intent当中，并传送给onActivityResult()，对应的Key为”data”。下面的代码展示的是如何获取这一图片并显示在ImageView上。 12345678@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get("data"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; Note: 这张从”data”中取出的缩略图适用于作为图标，但其他作用会比较有限。而处理一张全尺寸图片需要做更多的工作。 4. 保存全尺寸照片如果我们提供了一个File对象给Android的相机程序，它会保存这张全尺寸照片到给定的路径下。另外，我们必须提供存储图片所需要的含有后缀名形式的文件名。 一般而言，用户使用设备相机所拍摄的任何照片都应该被存放在设备的公共外部存储中，这样它们就能被所有的应用访问。将DIRECTORY_PICTURES作为参数，传递给getExternalStoragePublicDirectory()方法，可以返回适用于存储公共图片的目录。由于该方法提供的目录被所有应用共享，因此对该目录进行读写操作分别需要READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限。另外，因为写权限隐含了读权限，所以如果需要外部存储的写权限，那么仅仅需要请求一项权限就可以了： 1234&lt;manifest ...&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; ...&lt;/manifest&gt; 然而，如果希望照片对我们的应用而言是私有的，那么可以使用getExternalFilesDir()提供的目录。在Android 4.3及以下版本的系统中，写这个目录需要WRITE_EXTERNAL_STORAGE权限。从Android 4.4开始，该目录将无法被其他应用访问，所以该权限就不再需要了，你可以通过添加maxSdkVersion属性，声明只在低版本的Android设备上请求这个权限。 12345&lt;manifest ...&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="18" /&gt; ...&lt;/manifest&gt; 所有存储在getExternalFilesDir()提供的目录中的文件会在用户卸载你的app后被删除。 一旦选定了存储文件的目录，我们还需要设计一个保证文件名不会冲突的命名规则。当然我们还可以将路径存储在一个成员变量里以备在将来使用。下面的例子使用日期时间戳作为新照片的文件名： 123456789101112131415161718String mCurrentPhotoPath;private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); String imageFileName = "JPEG_" + timeStamp + "_"; File storageDir = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, /* prefix */ ".jpg", /* suffix */ storageDir /* directory */ ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = "file:" + image.getAbsolutePath(); return image;&#125; 有了上面的方法，我们就可以给新照片创建文件对象了，现在我们可以像这样创建并触发一个Intent： 12345678910111213141516171819202122static final int REQUEST_TAKE_PHOTO = 1;private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // Ensure that there's a camera activity to handle the intent if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File ... &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(photoFile)); startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO); &#125; &#125;&#125; 5. 将照片添加到相册中由于我们通过Intent创建了一张照片，因此图片的存储位置我们是知道的。对其他人来说，也许查看我们的照片最简单的方式是通过系统的Media Provider。 Note: 如果将图片存储在getExternalFilesDir()提供的目录中，Media Scanner将无法访问到我们的文件，因为它们隶属于应用的私有数据。 下面的例子演示了如何触发系统的Media Scanner，将我们的照片添加到Media Provider的数据库中，这样就可以使得Android相册程序与其他程序能够读取到这些照片。 1234567private void galleryAddPic() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); this.sendBroadcast(mediaScanIntent);&#125; 6. 解码一幅缩放图片在有限的内存下，管理许多全尺寸的图片会很棘手。如果发现应用在展示了少量图片后消耗了所有内存，我们可以通过缩放图片到目标视图尺寸，之后再载入到内存中的方法，来显著降低内存的使用，下面的例子演示了这个技术： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void setPic() &#123; // Get the dimensions of the View int targetW = mImageView.getWidth(); int targetH = mImageView.getHeight(); // Get the dimensions of the bitmap BitmapFactory.Options bmOptions = new BitmapFactory.Options(); bmOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); int photoW = bmOptions.outWidth; int photoH = bmOptions.outHeight; // Decode the image file into a Bitmap sized to fill the View bmOptions.inJustDecodeBounds = false; bmOptions.inSampleSize = calculateInSampleSize(bmOptions, targetW, targetH); bmOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); mImageView.setImageBitmap(bitmap);&#125;public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; // Calculate ratios of height and width to requested height and // width final int heightRatio = Math.round((float) height / (float) reqHeight); final int widthRatio = Math.round((float) width / (float) reqWidth); // Choose the smallest ratio as inSampleSize value, this will // guarantee // a final image with both dimensions larger than or equal to the // requested height and width. inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio; &#125; return inSampleSize;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客过程的各种问题]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[一、问题1Q: hexo server后访问浏览器 http://0.0.0.0:4000/ 出现 cannot get A: 依次执行如下命令就行： 123456789npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --savenpm install hexo-cli -ghexo init blogcd blognpm installhexo server 二、问题2Q: npm install时报错： A: 执行如下命令： 1sudo npm install 三、问题3Q: 社会化评论多说duoshuo_shortname在哪看？ A: 到多说官网创建站点(站点为xxx.github.io)，之后就会得到short_name。 四、问题4Q: 如何设置分类和标签？ A: 在文章的开始位置进行如下设置： 12345678---title: 使用Hexo搭建个人博客过程的各种问题categories: - Hexotags: - Hexo - 问题--- 五、问题5Q: 首页的文章目录，怎么设置显示部分摘要和read more? A: 在文章中加一行如下的标记，在这个标记之前的就是摘要 1&lt;!--more--&gt; 六、问题6Q: 运行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d命令后报错：1ERROR Deployer not found: git A: 执行以下命令，安装hexo-deployer-git自动部署发布工具：1npm install hexo-deployer-git --save]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语言常用语法]]></title>
    <url>%2FMarkdown%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[本文主要记录Markdown语言的常用语法，做为备忘，本文内容主要参考：https://segmentfault.com/markdown 一、代码1. 行内代码用法 把代码用反引号 ` (键盘上Esc键下面的键)包起，如： `toString()`方法 效果 toString()方法 2. 代码块用法1 用 3个`(Esc下面的键)包裹一段代码，并指定一种语言，如： 12345```java public class BookViewHolder extends RecyclerView.ViewHolder &#123; public TextView tvBook; &#125; ``` 用法2 也可以在代码块的每一行使用 4 空格缩进，实现相同的的效果，此处不再举例，可自己尝试。 效果 123public class BookViewHolder extends RecyclerView.ViewHolder &#123; public TextView tvBook;&#125; 支持的语言：actionscript, apache, bash, clojure, cmake, coffeescript, cpp, cs, css, d, delphi, django, erlang, go, haskell, html, http, ini, java, javascript, json, lisp, lua, markdown, matlab, nginx, objectivec, perl, php, python, r, ruby, scala, smalltalk, sql, tex, vbscript, xml 二、标题用法 使用1-6个#号连接内容，如： # 一级标题 ## 二级标题 ### 三级标题 效果 一级标题二级标题三级标题三、粗体、斜体、删除线用法 正常字前后不加*号，1个*为斜体，2个*为粗体，3个*为粗斜体，如： 这是正常的字 *这是斜体的字* **这是加粗的字** ***这是粗斜体的字*** ~~这是删除线~~ 效果 这是正常的字这是斜体的字这是加粗的字这是粗斜体的字这是删除线 四、链接1. 常用链接方法用法 文字链接： [百度](http://www.baidu.com) 网址链接： &lt;http://www.baidu.com&gt; 效果 文字链接： 百度网址链接： http://www.baidu.com 2. 高级链接技巧用法 这个链接用 1 作为网址变量 [Google][1]. 这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. 然后在文档的结尾为变量赋值（网址）: [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 效果 这个链接用 1 作为网址变量 Google.这个链接用 yahoo 作为网址变量 Yahoo!. 五、图片1. 用法1跟链接的方法区别在于前面加了个感叹号!，这样是不是觉得好记多了呢？ 用法 ![图片名称](http://图片网址)，如： ![奇犽](http://7xlpfl.com1.z0.glb.clouddn.com/16-10-1/61240869.jpg) 效果 2. 用法2当然，你也可以像网址那样对图片网址使用变量： 这个链接用 1 作为网址变量 [Google][1]. 然后在文档的结尾位变量赋值（网址） [1]: http://www.google.com/logo.png 3. 用法3也可以使用 HTML 的图片语法来自定义图片的宽高大小： &lt;img src=&quot;htt://example.com/sample.png&quot; width=&quot;250&quot; height=&quot;250&quot; alt=&quot;奇犽&quot;&gt; 4. 用法4如果使用七牛进行存储的图片，还可以在URL后面添加参数，控制加载的图片大小： ?imageView2/2/w/100/ ?imageView2/2/w/150/ ?imageView2/2/w/200/ 具体参数可参考七牛图片处理接口文档 六、列表1. 普通无序列表用法 - 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 效果 列表文本前使用 [减号+空格] 列表文本前使用 [加号+空格] 列表文本前使用 [星号+空格] 2. 普通有序列表用法 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 效果 列表前使用 [数字+空格] 我们会自动帮你添加数字 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 3. 列表嵌套用法 1. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格 2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格 4. 列表里代码段： 效果 列出所有元素： 无序列表元素 A 元素 A 的有序子列表 前面加四个空格 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 列表里引用： 前面空一行仍然需要在 &gt; 前面加四个空格 列表里代码段：待补充。 七、引用1. 普通引用用法 &gt; 引用文本前使用 [大于号+空格] &gt; 折行可以不加，新起一行都要加上哦 效果 引用文本前使用 [大于号+空格]折行可以不加，新起一行都要加上哦 2. 引用里嵌套引用用法 &gt; 最外层引用 &gt; &gt; 多一个 &gt; 嵌套一层引用 &gt; &gt; &gt; 可以嵌套很多层 效果 最外层引用 多一个 &gt; 嵌套一层引用 可以嵌套很多层 3. 引用里嵌套列表用法 &gt; - 这是引用里嵌套的一个列表 &gt; - 还可以有子列表 &gt; * 子列表需要从 - 之后延后四个空格开始 效果 这是引用里嵌套的一个列表 还可以有子列表 子列表需要从 - 之后延后四个空格开始 4. 引用里嵌套代码块用法 &gt; 同样的，在前面加四个空格形成代码块 效果 同样的，在前面加四个空格形成代码块 八、换行如果另起一行，只需在当前行结尾加 2 个空格 在当前行的结尾加 2 个空格 这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 九、分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行： 前面的段落 --- 后面的段落 十、符号转义如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠\进行避免。 用法 \_不想这里的文本变斜体\_ \*\*不想这里的文本被加粗\*\* 效果 _不想这里的文本变斜体_**不想这里的文本被加粗** 十一、表格用法 abc | def | kdka --- | --- | --- ld | dk | dk ld | dk | dk 效果 abc def kdka ld dk dk ld dk dk 十二、复杂表格1. 在Excel中填写表格在 Excel 中正常填写你的表格内容，之后在标题行下插入一行，要居中的填入:-:，要右对齐的填-:，其它全部填上-。 2. 生成表格复制、粘贴表格：选中表格，复制，然后粘贴到 Markdown 编辑器中。 用|替换tab：复制出来的 Excel 默认以tab作为单元格分隔符，而 Markdown 则以|为分隔符。顺理成章，当我们使用 | 对原tab分隔符进行替换后，即可生成 Markdown 化的表格： -|左对齐|居中对齐|右对齐 :-:|-|:-:|-: 1|Left|Center|Right 2|Left|Center|Right 3|Left|Center|Right 效果 - 左对齐 居中对齐 右对齐 1 Left Center Right 2 Left Center Right 3 Left Center Right 3. 在线生成Markdown表格http://www.tablesgenerator.com/markdown_tables 4. 复杂表格生成办法 我们仍然建议使用其他的方式替代复杂的表格，甚至尽量少用表格。 在你本地或者远程的HTML编辑器上生成复杂表格，然后粘贴表格的HTML代码到编辑区即可。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView学习笔记1_入门]]></title>
    <url>%2FRecyclerView%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01_%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[一、 前言RecyclerView是谷歌V7包下新增的控件,用来替代ListView、GridView的使用. 要点 LayoutManager：布局管理器,目前SDK中提供了三种自带的LayoutManager: 123LinearLayoutManager-----类似ListViewGridLayoutManager-----类似GridViewStaggeredGridLayoutManager-----瀑布流 ItemDecoration：Item间的分割线样式 ItemAnimator：Item增加、删除的动画 点击、长按事件：比较麻烦 二、开发环境 IDE: Android Studio 2.0 Beta 6 SDK: Android 23 三、使用1. 配置 app/build.gradle 1234dependencies &#123; ... compile 'com.android.support:recyclerview-v7:23.1.1'&#125; 2. 主布局文件 activity_main.xml 1234567891011121314151617&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.sh.recyclerviewstudy1.MainActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_book" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/RelativeLayout&gt; 3. 子布局文件 rv_item_book.xml 123456789101112&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="@dimen/activity_horizontal_margin" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv_book" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="16sp"/&gt;&lt;/LinearLayout&gt; 4. ViewHolder文件 BookViewHolder.java 123456789public class BookViewHolder extends RecyclerView.ViewHolder &#123; public TextView tvBook; public BookViewHolder(View view) &#123; super(view); tvBook = (TextView) view.findViewById(R.id.tv_book); &#125;&#125; 5. 适配器 BookRecyclerViewAdapter.java 123456789101112131415161718192021222324252627282930313233public class BookRecyclerViewAdapter extends RecyclerView.Adapter&lt;BookViewHolder&gt; &#123; private LayoutInflater mLayoutInflater; private Context mContext; private String[] mBooks; public BookRecyclerViewAdapter(Context context, String[] mBooks) &#123; this.mBooks = mBooks; this.mContext = context; mLayoutInflater = LayoutInflater.from(context); &#125; @Override public BookViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; // 创建一个View View view = mLayoutInflater.inflate(R.layout.rv_item_book, parent, false); // 创建一个ViewHolder BookViewHolder bookViewHolder = new BookViewHolder(view); return bookViewHolder; &#125; @Override public void onBindViewHolder(BookViewHolder holder, int position) &#123; // 绑定数据到ViewHolder上 holder.tvBook.setText(mBooks[position]); &#125; @Override public int getItemCount() &#123; // item数量 return mBooks.length; &#125;&#125; 6. 主界面 MainActivity.java 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; private RecyclerView rvBook; private String[] mBooks = &#123;"认知盈余", "和喜欢的一切在一起", "从0到1", "从你的全世界路过", "打工旅行", "番茄工作法图解"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rvBook = (RecyclerView) findViewById(R.id.rv_book); // 1\. 这里用线性显示,类似于ListView rvBook.setLayoutManager(new LinearLayoutManager(this)); // 2\. 这里用线性宫格显示,类似于GridView// rvBook.setLayoutManager(new GridLayoutManager(this, 2)); // 3\. 这里用线性宫格显示,类似于瀑布流// rvBook.setLayoutManager(new StaggeredGridLayoutManager(2, OrientationHelper.VERTICAL)); rvBook.setAdapter(new BookRecyclerViewAdapter(MainActivity.this, mBooks)); &#125;&#125; 四、总结RecyclerView的另一个特点是标准化了 ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo入门]]></title>
    <url>%2FHexo%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
