[{"title":"RxJava操作符实践：3_过滤操作之11_distinct","date":"2016-10-16T01:56:00.000Z","path":"2016/10/16/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之11_distinct/","text":"一、描述抑制（过滤掉）重复的数据项。 Distinct的过滤规则是：只允许还没有发射过的数据项通过。 在某些实现中，有一些变体允许你调整判定两个数据不同(distinct)的标准。还有一些实现只比较一项数据和它的直接前驱，因此只会从序列中过滤掉连续重复的数据。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 1, 1, 2, 3) .distinct() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError:\" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext:\" + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多distinct操作符还有以下变体： distinct(Func1) 跟distinct相关的操作符还有： distinctUntilChanged distinctUntilChanged(Func1) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"distinct","slug":"distinct","permalink":"http://sherlockshi.github.io/tags/distinct/"}]},{"title":"RxJava操作符实践：3_过滤操作之12_ignoreElements","date":"2016-10-16T01:56:00.000Z","path":"2016/10/16/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之12_ignoreElements/","text":"一、描述不发射任何数据，只发射Observable的终止通知。 IgnoreElements操作符抑制原始Observable发射的所有数据，只允许它的终止通知（onError或onCompleted）通过。 如果你不关心一个Observable发射的数据，但是希望在它完成时或遇到错误终止时收到通知，你可以对Observable使用ignoreElements操作符，它会确保永远不会调用观察者的onNext()方法。 ignoreElements默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .ignoreElements() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError:\" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext:\" + integer); &#125; &#125;); 四、运行结果1onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"ignoreElements","slug":"ignoreElements","permalink":"http://sherlockshi.github.io/tags/ignoreElements/"}]},{"title":"RxJava操作符实践：3_过滤操作之10_debounce","date":"2016-10-16T01:32:00.000Z","path":"2016/10/16/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之10_debounce/","text":"一、描述仅在过了一段指定的时间还没发射数据时才发射一个数据。 Debounce操作符会过滤掉发射速率过快的数据项。 RxJava将这个操作符实现为throttleWithTimeout和debounce。 注意：这个操作符会会接着最后一项数据发射原始Observable的onCompleted通知，即使这个通知发生在你指定的时间窗口内（从最后一项数据的发射算起）。也就是说，onCompleted通知不会触发限流。 二、示意图 三、示例代码12345678910111213141516171819202122232425262728293031323334Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; if(subscriber.isUnsubscribed()) return; try &#123; //产生结果的间隔时间分别为100、200、300...900毫秒 for (int i = 1; i &lt; 10; i++) &#123; subscriber.onNext(i); Thread.sleep(i * 100); &#125; subscriber.onCompleted(); &#125;catch(Exception e)&#123; subscriber.onError(e); &#125; &#125;&#125;) .subscribeOn(Schedulers.newThread()) .debounce(400, TimeUnit.MILLISECONDS) //超时时间为400毫秒 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError:\" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext:\" + integer); &#125; &#125;); 由于1-4这四个数值，间隔时间（分别为100ms，200ms，300ms，400ms）均不大于debounce限制的值（400ms），所以均被过滤掉，只有后面发射的时间间隔大于400ms的（分别为500ms-900ms），才会正常发射。 四、运行结果123456onNext: 5onNext: 6onNext: 7onNext: 8onNext: 9onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟debounce相关的操作符还有： throttleWithTimeout(long,TimeUnit) 和 debounce(long,TimeUnit) throttleWithTimeout(long,TimeUnit,Scheduler) 和 debounce(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"debounce","slug":"debounce","permalink":"http://sherlockshi.github.io/tags/debounce/"}]},{"title":"RxJava操作符实践：3_过滤操作之9_sample","date":"2016-10-15T11:47:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之9_sample/","text":"一、描述定期发射Observable最近发射的数据项。 Sample操作符定时查看一个Observable，然后发射自上次采样以来它最近发射的数据。 在某些实现中，有一个ThrottleFirst操作符的功能类似，但不是发射采样期间的最近的数据，而是发射在那段时间内的第一项数据。 RxJava将这个操作符实现为sample和throttleLast。 注意：如果自上次采样以来，原始Observable没有发射任何数据，这个操作返回的Observable在那段时间内也不会发射任何数据。 sample(别名throttleLast)的一个变体按照你参数中指定的时间间隔定时采样（TimeUnit指定时间单位）。 sample的这个变体默认在computation调度器上执行，但是你可以使用第三个参数指定其它的调度器。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233protected void runSampleCode() &#123; Observable observable = Observable.interval(1000, TimeUnit.MILLISECONDS) .sample(2200, TimeUnit.MILLISECONDS); subscriber = new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println(\"onNext: \" + aLong); &#125; &#125;; observable.subscribe(subscriber);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (subscriber != null &amp;&amp; !subscriber.isUnsubscribed()) &#123; subscriber.unsubscribe(); &#125;&#125; 四、运行结果1234567onNext: 1onNext: 3onNext: 5onNext: 7onNext: 9onNext: 12(...) 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多sample操作符还有以下变体： sample(long,TimeUnit) 和 throttleLast(long,TimeUnit) sample(long,TimeUnit,Scheduler) 和 throttleLast(long,TimeUnit,Scheduler) sample(Observable) 跟sample相关的操作符还有： throttleFirst(long,TimeUnit) throttleFirst(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"sample","slug":"sample","permalink":"http://sherlockshi.github.io/tags/sample/"}]},{"title":"RxJava操作符实践：3_过滤操作之8_elementAt","date":"2016-10-15T11:20:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之8_elementAt/","text":"一、描述只发射第N项数据。 ElementAt操作符获取原始Observable发射的数据序列指定索引位置的数据项，然后当做自己的唯一数据发射。 RxJava将这个操作符实现为elementAt，给它传递一个基于0的索引值，它会发射原始Observable数据序列对应索引位置的值，如果你传递给elementAt的值为5，那么它会发射第六项的数据。 如果你传递的是一个负数，或者原始Observable的数据项数小于index+1，将会抛出一个IndexOutOfBoundsException异常。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .elementAt(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果12onNext: 4onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟elementAt相关的操作符还有： elementAtOrDefault(int,T) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"elementAt","slug":"elementAt","permalink":"http://sherlockshi.github.io/tags/elementAt/"}]},{"title":"RxJava操作符实践：3_过滤操作之7_first","date":"2016-10-15T11:08:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之7_first/","text":"一、描述只发射第一项（或者满足某个条件的第一项）数据。 如果你只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，你可以使用First操作符。 在某些实现中，First没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用Take(1)或者ElementAt(0)。 在一些实现中还有一个Single操作符。它的行为与First类似，但为了确保只发射单个值，它会等待原始Observable终止（否则，不是发射那个值，而是以一个错误通知终止）。你可以使用它从原始Observable获取第一项数据，而且也确保只发射一项数据。 在RxJava中，这个操作符被实现为first，firstOrDefault和takeFirst。 可能容易混淆，BlockingObservable也有名叫first和firstOrDefault的操作符，它们会阻塞并返回值，不是立即返回一个Observable。 还有几个其它的操作符执行类似的功能。 只发射第一个数据，使用没有参数的first操作符。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .first() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果12onNext: 1onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多first操作符还有以下变体： first(Func1) 跟first相关的操作符还有： firstOrDefault(T) firstOrDefault(T, Func1) takeFirst(Func1) single() single(Func1) singleOrDefault(T) singleOrDefault(Func1,T) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"first","slug":"first","permalink":"http://sherlockshi.github.io/tags/first/"}]},{"title":"RxJava操作符实践：3_过滤操作之6_take","date":"2016-10-15T03:30:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之6_take/","text":"一、描述只发射前面的N项数据。 使用Take操作符让你可以修改Observable的行为，只返回前面的N项数据，然后发射完成通知，忽略剩余的数据。 如果你对一个Observable使用take(n)（或它的同义词limit(n)）操作符，而那个Observable发射的数据少于N项，那么take操作生成的Observable不会抛异常或发射onError通知，在完成前它只会发射相同的少量数据。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .take(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多take操作符还有以下变体： take(long,TimeUnit) take(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"take","slug":"take","permalink":"http://sherlockshi.github.io/tags/take/"}]},{"title":"RxJava操作符实践：3_过滤操作之5_skipLast","date":"2016-10-15T03:25:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之5_skipLast/","text":"一、描述抑制Observable发射的后N项数据。 使用SkipLast操作符修改原始Observable，你可以忽略Observable发射的后N项数据，只保留前面的数据。 使用SkipLast操作符，你可以忽略原始Observable发射的后N项数据，只保留之前的数据。注意：这个机制是这样实现的：延迟原始Observable发射的任何数据项，直到它发射了N项数据。 skipLast的这个变体默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .skipLast(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多skipLast操作符还有以下变体： skipLast(long,TimeUnit) skipLast(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"skipLast","slug":"skipLast","permalink":"http://sherlockshi.github.io/tags/skipLast/"}]},{"title":"RxJava操作符实践：3_过滤操作之4_skip","date":"2016-10-15T03:16:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之4_skip/","text":"一、描述抑制Observable发射的前N项数据。 使用Skip操作符，你可以忽略Observable发射的前N项数据，只保留之后的数据。 skip的这个变体默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .skip(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果1234onNext: 4onNext: 5onNext: 6onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多skip操作符还有以下变体： skip(long,TimeUnit) skip(long,TimeUnit,Scheduler) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"skip","slug":"skip","permalink":"http://sherlockshi.github.io/tags/skip/"}]},{"title":"RxJava操作符实践：3_过滤操作之3_last","date":"2016-10-15T02:50:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之3_last/","text":"一、描述只发射最后一项（或者满足某个条件的最后一项）数据。 如果你只对Observable发射的最后一项数据，或者满足某个条件的最后一项数据感兴趣，你可以使用Last操作符。 在某些实现中，Last没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用TakeLast(1)。 在RxJava中的实现是last和lastOrDefault。 可能容易混淆，BlockingObservable也有名叫last和lastOrDefault的操作符，它们会阻塞并返回值，不是立即返回一个Observable。 只发射最后一项数据，使用没有参数的last操作符。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .last() .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果12onNext: 6onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多last操作符还有以下变体： last(Func1) 跟last相关的操作符还有： lastOrDefault(T) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"last","slug":"last","permalink":"http://sherlockshi.github.io/tags/last/"}]},{"title":"RxJava操作符实践：3_过滤操作之2_takeLast","date":"2016-10-15T02:38:00.000Z","path":"2016/10/15/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之2_takeLast/","text":"一、描述发射Observable发射的最后N项数据。 使用TakeLast操作符修改原始Observable，你可以只发射Observable发射的后N项数据，忽略前面的数据。 使用takeLast操作符，你可以只发射原始Observable发射的后N项数据，忽略之前的数据。注意：这会延迟原始Observable发射的任何数据项，直到它全部完成。 takeLast的这个变体默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6) .takeLast(3) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果1234onNext: 4onNext: 5onNext: 6onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多本操作符还有以下变体： takeLast(int, long, TimeUnit) 相关的操作符还有： takeLastBuffer 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"takeLast","slug":"takeLast","permalink":"http://sherlockshi.github.io/tags/takeLast/"}]},{"title":"RxJava操作符实践：3_过滤操作之1_filter","date":"2016-10-14T08:23:00.000Z","path":"2016/10/14/15_Android/1560_RxJava/RxJava操作符实践：3_过滤操作之1_filter/","text":"一、描述只发射通过了谓词测试的数据项。 Filter操作符使用你指定的一个谓词函数测试数据项，只有通过测试的数据才会被发射。 filter默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4, 5) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer &lt; 4; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果1234onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟filter相关的操作符还有： ofType 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"过滤操作","slug":"过滤操作","permalink":"http://sherlockshi.github.io/tags/过滤操作/"},{"name":"filter","slug":"filter","permalink":"http://sherlockshi.github.io/tags/filter/"}]},{"title":"RxJava操作符实践：2_变换操作之6_window","date":"2016-10-14T07:01:00.000Z","path":"2016/10/14/15_Android/1560_RxJava/RxJava操作符实践：2_变换操作之6_window/","text":"一、描述定期将来自原始Observable的数据分解为一个Observable窗口，发射这些窗口，而不是每次发射一项数据。 Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。 和Buffer一样，Window有很多变体，每一种都以自己的方式将原始Observable分解为多个作为结果的Observable，每一个都包含一个映射原始数据的window。用Window操作符的术语描述就是，当一个窗口打开(when a window “opens”)意味着一个新的Observable已经发射（产生）了，而且这个Observable开始发射来自原始Observable的数据；当一个窗口关闭(when a window “closes”)意味着发射(产生)的Observable停止发射原始Observable的数据，并且发射终止通知onCompleted给它的观察者们。 二、示意图 三、示例代码window操作符与buffer操作符类似，区别在于buffer操作符产生的结果是一个List缓存，而window操作符产生的结果是一个Observable,订阅者可以对这个结果Observable重新进行订阅处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 完整流程版Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .window(3) .subscribe(new Subscriber&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Observable&lt;Integer&gt; integerObservable) &#123; integerObservable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted(inner).\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError(inner): \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); &#125; &#125;);// 简化版Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .window(3) .subscribe(new Action1&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public void call(Observable&lt;Integer&gt; integerObservable) &#123; System.out.println(\"start\"); integerObservable.subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); &#125; &#125;); 四、运行结果1234567891011121314151617181920212223242526(完整流程版)onNext: 1onNext: 2onNext: 3onCompleted(inner).onNext: 4onNext: 5onNext: 6onCompleted(inner).onNext: 7onNext: 8onCompleted(inner).onCompleted.(简化版)startonNext: 1onNext: 2onNext: 3startonNext: 4onNext: 5onNext: 6startonNext: 7onNext: 8 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多在RxJava中有许多window的变体： window(closingSelector) window(windowOpenings, closingSelector) window(count) window(count, skip) window(timespan, unit[, scheduler]) window(timespan, unit, count[, scheduler]) window(timespan, timeshift, unit[, scheduler]) window-backpressure 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"变换操作","slug":"变换操作","permalink":"http://sherlockshi.github.io/tags/变换操作/"},{"name":"window","slug":"window","permalink":"http://sherlockshi.github.io/tags/window/"}]},{"title":"RxJava操作符实践：2_变换操作之5_buffer","date":"2016-10-14T06:43:00.000Z","path":"2016/10/14/15_Android/1560_RxJava/RxJava操作符实践：2_变换操作之5_buffer/","text":"一、描述定期收集Observable的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。 Buffer操作符将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合。Buffer操作符在很多语言特定的实现中有很多种变体，它们在如何缓存这个问题上存在区别。 注意：如果原来的Observable发射了一个onError通知，Buffer会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。 Window操作符与Buffer类似，但是它在发射之前把收集到的数据放进单独的Observable，而不是放进一个数据结构。 二、示意图 三、示例代码buffer操作符有两个参数，分别为count和skip，count参数指定buffer操作符的大小，skip参数用来指定每次发射一个集合需要跳过几个数。 123456789101112131415161718Observable.just(1, 2, 3, 4, 5, 6, 7, 8) .buffer(3, 2) .subscribe(new Subscriber&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(List&lt;Integer&gt; integers) &#123; System.out.println(\"onNext: \" + integers); &#125; &#125;); 四、运行结果12345onNext: [1, 2, 3]onNext: [3, 4, 5]onNext: [5, 6, 7]onNext: [7, 8]onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多在RxJava中有许多Buffer的变体： buffer(count) buffer(count, skip) buffer(bufferClosingSelector) buffer(boundary) buffer(bufferOpenings, bufferClosingSelector) buffer(timespan, unit[, scheduler]) buffer(timespan, unit, count[, scheduler]) buffer(timespan, timeshift, unit[, scheduler]) buffer-backpressure 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 http://www.jianshu.com/p/8b9e987e6789 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"变换操作","slug":"变换操作","permalink":"http://sherlockshi.github.io/tags/变换操作/"},{"name":"buffer","slug":"buffer","permalink":"http://sherlockshi.github.io/tags/buffer/"}]},{"title":"RxJava操作符实践：2_变换操作之4_groupBy","date":"2016-10-14T06:37:00.000Z","path":"2016/10/14/15_Android/1560_RxJava/RxJava操作符实践：2_变换操作之4_groupBy/","text":"一、描述将一个Observable分拆为一些Observables集合，它们中的每一个发射原始Observable的一个子序列。 GroupBy操作符将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。 RxJava实现了groupBy操作符。它返回Observable的一个特殊子类GroupedObservable，实现了GroupedObservable接口的对象有一个额外的方法getKey，这个Key用于将数据分组到指定的Observable。 有一个版本的groupBy允许你传递一个变换函数，这样它可以在发射结果GroupedObservable之前改变数据项。 注意：groupBy将原始Observable分解为一个发射多个GroupedObservable的Observable，一旦有订阅，每个GroupedObservable就开始缓存数据。因此，如果你忽略这些GroupedObservable中的任何一个，这个缓存可能形成一个潜在的内存泄露。因此，如果你不想观察，也不要忽略GroupedObservable。你应该使用像take(0)这样会丢弃自己的缓存的操作符。 如果你取消订阅一个GroupedObservable，那个Observable将会终止。如果之后原始的Observable又发射了一个与这个Observable的Key匹配的数据，groupBy将会为这个Key创建一个新的GroupedObservable。 groupBy默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 完整流程版Observable.just(1, 2, 3, 4, 5) .groupBy(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; return integer % 3; &#125; &#125;) .subscribe(new Subscriber&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(final GroupedObservable&lt;Integer, Integer&gt; result) &#123; result.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted(inner).\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError(inner): \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: Key=\" + result.getKey() + \", Value=\" + integer); &#125; &#125;); &#125; &#125;);// 简化版Observable.just(1, 2, 3, 4, 5) .groupBy(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; return integer % 3; &#125; &#125;) .subscribe(new Action1&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123; @Override public void call(final GroupedObservable&lt;Integer, Integer&gt; result) &#123; result.subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; System.out.println(\"Key=\" + result.getKey() + \", Value=\" + integer); &#125; &#125;); &#125; &#125;); 四、运行结果1234567891011121314151617(完整流程版)onNext: Key=1, Value=1onNext: Key=2, Value=2onNext: Key=0, Value=3onNext: Key=1, Value=4onNext: Key=2, Value=5onCompleted(inner).onCompleted(inner).onCompleted(inner).onCompleted.(简化版)Key=1, Value=1Key=2, Value=2Key=0, Value=3Key=1, Value=4Key=2, Value=5 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多groupBy操作符共有以下几个变体： groupBy(Func1) groupBy(Func1,Func1) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"变换操作","slug":"变换操作","permalink":"http://sherlockshi.github.io/tags/变换操作/"},{"name":"groupBy","slug":"groupBy","permalink":"http://sherlockshi.github.io/tags/groupBy/"}]},{"title":"RxJava操作符实践：2_变换操作之3_scan","date":"2016-10-14T06:22:00.000Z","path":"2016/10/14/15_Android/1560_RxJava/RxJava操作符实践：2_变换操作之3_scan/","text":"一、描述连续地对数据序列的每一项应用一个函数，然后连续发射结果。 Scan操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。这个操作符在某些情况下被叫做accumulator。 二、示意图 三、示例代码1234567891011121314151617181920212223Observable.just(1, 2, 3, 4, 5) .scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer call(Integer sum, Integer item) &#123; return sum + item; &#125; &#125;) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果123456onNext: 1onNext: 2onNext: 6onNext: 10onNext: 15onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多scan操作符共有以下几个变体： scan(Func2) scan(R,Func2) 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"变换操作","slug":"变换操作","permalink":"http://sherlockshi.github.io/tags/变换操作/"},{"name":"scan","slug":"scan","permalink":"http://sherlockshi.github.io/tags/scan/"}]},{"title":"RxJava操作符实践：2_变换操作之2_flatMap","date":"2016-10-14T05:50:00.000Z","path":"2016/10/14/15_Android/1560_RxJava/RxJava操作符实践：2_变换操作之2_flatMap/","text":"一、描述FlatMap将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable。 FlatMap操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后FlatMap合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。 这个方法是很有用的，例如，当你有一个这样的Observable：它发射一个数据序列，这些数据本身包含Observable成员或者可以变换为Observable，因此你可以创建一个新的Observable发射这些次级Observable发射的数据的完整集合。 注意：FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。 在许多语言特定的实现中，还有一个操作符不会让变换后的Observables发射的数据交错，它按照严格的顺序发射这些数据，这个操作符通常被叫作ConcatMap或者类似的名字。 注意：如果任何一个通过这个flatMap操作产生的单独的Observable调用onError异常终止了，这个Observable自身会立即调用onError并终止。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Course &#123; private String name; public Course(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;class Student &#123; private List&lt;Course&gt; courses; public Student(List&lt;Course&gt; courses) &#123; this.courses = courses; &#125; public List&lt;Course&gt; getCourses() &#123; return courses; &#125;&#125;/* Student1 */Course course11 = new Course(\"C#\");Course course12 = new Course(\"Java\");Course course13 = new Course(\"Python\");List&lt;Course&gt; courses1 = new ArrayList&lt;Course&gt;();courses1.add(course11);courses1.add(course12);courses1.add(course13);Student student1 = new Student(courses1);/* Student2 */Course course21 = new Course(\"OC\");Course course22 = new Course(\"Ruby\");List&lt;Course&gt; courses2 = new ArrayList&lt;Course&gt;();courses2.add(course21);courses2.add(course22);Student student2 = new Student(courses2);Observable.just(student1, student2) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(new Subscriber&lt;Course&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Course course) &#123; System.out.println(\"onNext: \" + course.getName()); &#125; &#125;); 四、运行结果123456onNext: C#onNext: JavaonNext: PythononNext: OConNext: RubyonCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多flatMap操作符共有以下几个变体： flatMap(Func1) flatMap(Func1,int) flatMap(Func1,Func1,Func0) flatMap(Func1,Func1,Func0,int) flatMap(Func1,Func2) flatMap(Func1,Func2,int) 跟flatMap相关的操作符还有： flatMapIterable concatMap switchMap split 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"变换操作","slug":"变换操作","permalink":"http://sherlockshi.github.io/tags/变换操作/"},{"name":"flatMap","slug":"flatMap","permalink":"http://sherlockshi.github.io/tags/flatMap/"}]},{"title":"RxJava操作符实践：2_变换操作之1_map","date":"2016-10-14T03:04:00.000Z","path":"2016/10/14/15_Android/1560_RxJava/RxJava操作符实践：2_变换操作之1_map/","text":"一、描述对Observable发射的每一项数据应用一个函数，执行变换操作。 Map操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。 这个操作符默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930313233343536373839class Student &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;Student student1 = new Student(\"ZhangSan\");Student student2 = new Student(\"LiSi\");Student student3 = new Student(\"WangWu\");Observable.just(student1, student2, student3) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123; return student.getName(); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(String s) &#123; System.out.println(\"onNext: \" + s); &#125; &#125;); 四、运行结果1234onNext: ZhangSanonNext: LiSionNext: WangWuonCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟map相关的操作符还有： cast encode byLine 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"变换操作","slug":"变换操作","permalink":"http://sherlockshi.github.io/tags/变换操作/"},{"name":"map","slug":"map","permalink":"http://sherlockshi.github.io/tags/map/"}]},{"title":"RxJava操作符实践：1_创建操作之10_timer","date":"2016-10-13T09:45:00.000Z","path":"2016/10/13/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之10_timer/","text":"一、描述创建一个Observable，它在一个给定的延迟后发射一个特殊的值。 Timer操作符创建一个在给定的时间段之后返回一个特殊值的Observable。 timer返回一个Observable，它在延迟一段给定的时间后发射一个简单的数字0。 timer操作符默认在computation调度器上执行。有一个变体可以通过可选参数指定Scheduler。 二、示意图 三、示例代码1234567891011121314151617Observable.timer(3, TimeUnit.SECONDS) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println(\"onNext: \" + aLong); &#125; &#125;); 四、运行结果延时3秒后，打印出如下信息： 12onNext: 0onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"timer","slug":"timer","permalink":"http://sherlockshi.github.io/tags/timer/"}]},{"title":"RxJava操作符实践：1_创建操作之9_start","date":"2016-10-13T07:11:00.000Z","path":"2016/10/13/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之9_start/","text":"一、描述返回一个Observable，它发射一个类似于函数声明的值。 编程语言有很多种方法可以从运算结果中获取值，它们的名字一般叫functions, futures, actions, callables, runnables等等。在Start目录下的这组操作符可以让它们表现得像Observable，因此它们可以在Observables调用链中与其它Observable搭配使用。 Start操作符的多种RxJava实现都属于可选的rxjava-async模块。 rxjava-async模块包含start操作符，它接受一个函数作为参数，调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable。 注意：这个函数只会被执行一次，即使多个观察者订阅这个返回的Observable。 二、示意图 三、示例代码123456789101112131415161718192021222324252627Async.start(new Func0&lt;Integer&gt;() &#123; @Override public Integer call() &#123; try &#123; Thread.sleep(5 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 16; &#125;&#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125;&#125;); 四、运行结果延时5秒后，打印出如下信息： 12onNext: 16onCompleted. 注意点： 由于start操作符是属于可选的rxjava-async模块的，所以需要加入下面的依赖： 1compile 'io.reactivex:rxjava-async-util:0.21.0' 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟start相关的操作符还有： toAsync startFuture deferFuture fromAction fromCallable fromRunnable forEachFuture runAsync 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"start","slug":"start","permalink":"http://sherlockshi.github.io/tags/start/"}]},{"title":"RxJava操作符实践：1_创建操作之8_repeat","date":"2016-10-13T06:51:00.000Z","path":"2016/10/13/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之8_repeat/","text":"一、描述创建一个发射特定数据重复多次的Observable。 Repeat重复地发射数据。某些实现允许你重复的发射某个数据序列，还有一些允许你限制重复的次数。 RxJava将这个操作符实现为repeat方法。它不是创建一个Observable，而是重复发射原始Observable的数据序列，这个序列或者是无限的，或者通过repeat(n)指定重复次数。 repeat操作符默认在trampoline调度器上执行。有一个变体可以通过可选参数指定Scheduler。 二、示意图 三、示例代码123456789101112131415161718Observable.range(2, 3) .repeat(2) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果1234567onNext: 2onNext: 3onNext: 4onNext: 2onNext: 3onNext: 4onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多跟repeat相关的操作符还有： repeatWhen doWhile whileDo 详情可查阅下面的参考资料。 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"repeat","slug":"repeat","permalink":"http://sherlockshi.github.io/tags/repeat/"}]},{"title":"RxJava操作符实践：1_创建操作之7_range","date":"2016-10-13T06:34:00.000Z","path":"2016/10/13/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之7_range/","text":"一、描述创建一个发射特定整数序列的Observable。 Range操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。 RxJava将这个操作符实现为range函数，它接受两个参数，一个是范围的起始值，一个是范围的数据的数目。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。 range默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。 二、示意图 三、示例代码1234567891011121314151617Observable.range(2, 4) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果12345onNext: 2onNext: 3onNext: 4onNext: 5onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"range","slug":"range","permalink":"http://sherlockshi.github.io/tags/range/"}]},{"title":"RxJava操作符实践：1_创建操作之6_just","date":"2016-10-13T02:37:00.000Z","path":"2016/10/13/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之6_just/","text":"一、描述创建一个发射指定值的Observable。 Just将单个数据转换为发射那个数据的Observable。 Just类似于From，但是From会将数组或Iterable的数据取出然后逐个发射，而Just只是简单的原样发射，将数组或Iterable当做单个数据。 注意：如果你传递null给Just，它会返回一个发射null值的Observable。不要误认为它会返回一个空Observable（完全不发射任何数据的Observable），如果需要空Observable你应该使用Empty操作符。 RxJava将这个操作符实现为just函数，它接受一至九个参数，返回一个按参数列表顺序发射这些数据的Observable。 二、示意图 三、示例代码1234567891011121314151617Observable.just(1, 2, 3, 4) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125; &#125;); 四、运行结果12345onNext: 1onNext: 2onNext: 3onNext: 4onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"just","slug":"just","permalink":"http://sherlockshi.github.io/tags/just/"}]},{"title":"RxJava操作符实践：1_创建操作之5_interval","date":"2016-10-13T01:26:00.000Z","path":"2016/10/13/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之5_interval/","text":"一、描述创建一个按固定时间间隔发射整数序列的Observable。 Interval操作符返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。 还有一个版本的interval返回一个Observable，它在指定延迟之后先发射一个零值，然后再按照指定的时间间隔发射递增的数字。这个版本的interval在RxJava 1.0.0中叫做timer，但是那个方法已经不建议使用了，因为一个名叫interval的操作符有同样的功能。 interval默认在computation调度器上执行。你也可以传递一个可选的Scheduler参数来指定调度器。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132protected void runSampleCode() &#123; Observable observable = Observable.interval(1000, TimeUnit.MILLISECONDS); subscriber = new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; System.out.println(\"onNext: \" + aLong); &#125; &#125;; observable.subscribe(subscriber);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (subscriber!= null &amp;&amp; !subscriber.isUnsubscribed()) &#123; subscriber.unsubscribe(); &#125;&#125; 四、运行结果1234567onNext: 0onNext: 1onNext: 2onNext: 3onNext: 4onNext: 5(...) 注意点： 这个对象是运行在computation Scheduler，所以如果需要在view中显示结果，要在主线程中订阅。 由于这个操作会无限进行下去，所以需要手动取消掉这个subscription。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"interval","slug":"interval","permalink":"http://sherlockshi.github.io/tags/interval/"}]},{"title":"RxJava操作符实践：1_创建操作之4_from","date":"2016-10-12T09:32:00.000Z","path":"2016/10/12/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之4_from/","text":"一、描述将其它种类的对象和数据类型转换为Observable。 当你使用Observable时，如果你要处理的数据都可以转换成展现为Observables，而不是需要混合使用Observables和其它类型的数据，会非常方便。这让你在数据流的整个生命周期中，可以使用一组统一的操作符来管理它们。 例如，Iterable可以看成是同步的Observable；Future，可以看成是总是只发射单个数据的Observable。通过显式地将那些数据转换为Observables，你可以像使用Observable一样与它们交互。 因此，大部分ReactiveX实现都提供了将语言特定的对象和数据结构转换为Observables的方法。 在RxJava中，from操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据。 对于Future，它会发射Future.get()方法返回的单个数据。from方法有一个可接受两个可选参数的版本，分别指定超时时长和时间单位。如果过了指定的时长Future还没有返回一个值，这个Observable会发射错误通知并终止。 from默认不在任何特定的调度器上执行。然而你可以将Scheduler作为可选的第二个参数传递给Observable，它会在那个调度器上管理这个Future。 二、示意图 三、示例代码12345678910111213141516171819Integer[] items = &#123; 0, 1, 2, 3, 4, 5 &#125;;Observable.from(items) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println(\"onNext: \" + o); &#125; &#125;); 四、运行结果1234567onNext: 0onNext: 1onNext: 2onNext: 3onNext: 4onNext: 5onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、更多from操作符共有以下几个变体： 12345from(array)from(Iterable)from(Future)from(Future,Scheduler)from(Future,timout,timeUnit) 六、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"from","slug":"from","permalink":"http://sherlockshi.github.io/tags/from/"}]},{"title":"RxJava操作符实践：1_创建操作之3.3_throw","date":"2016-10-12T09:05:00.000Z","path":"2016/10/12/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之3_3_throw/","text":"一、描述创建一个不发射数据以一个错误终止的Observable。 二、示意图 三、示例代码1234567891011121314151617Observable.error(new Throwable(\"something must be wrong!\")) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println(\"onNext: \" + o); &#125; &#125;); 四、运行结果1onError: something must be wrong! 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"throw","slug":"throw","permalink":"http://sherlockshi.github.io/tags/throw/"}]},{"title":"RxJava操作符实践：1_创建操作之3.2_never","date":"2016-10-12T08:18:00.000Z","path":"2016/10/12/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之3_2_never/","text":"一、描述创建一个不发射数据也不终止的Observable。 二、示意图 三、示例代码1234567891011121314151617Observable.never() .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println(\"onNext: \" + o); &#125; &#125;); 四、运行结果 (什么结果也没有！) 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"never","slug":"never","permalink":"http://sherlockshi.github.io/tags/never/"}]},{"title":"RxJava操作符实践：1_创建操作之3.1_empty","date":"2016-10-12T08:02:00.000Z","path":"2016/10/12/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之3_1_empty/","text":"一、描述创建一个不发射任何数据但是正常终止的Observable。 empty操作符一般会跟其它操作符配合使用。 二、示意图 三、示例代码1234567891011121314151617Observable.empty() .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; System.out.println(\"onNext: \" + o); &#125; &#125;); 四、运行结果1onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"empty","slug":"empty","permalink":"http://sherlockshi.github.io/tags/empty/"}]},{"title":"RxJava操作符实践：1_创建操作之2_defer","date":"2016-10-12T07:14:00.000Z","path":"2016/10/12/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之2_defer/","text":"一、描述Defer操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。 在某些情况下，等待直到最后一分钟（就是知道订阅发生时）才生成Observable可以确保Observable包含最新的数据。 RxJava将这个操作符实现为 defer 方法。这个操作符接受一个你选择的Observable工厂函数作为单个参数。这个函数没有参数，返回一个Observable。 defer方法默认不在任何特定的调度器上执行。 二、示意图 三、示例代码1234567891011121314151617181920212223242526272829303132333435number = 1;Observable justObservable = Observable.just(number);number = 2;Observable deferObservable = Observable.defer(new Func0&lt;Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call() &#123; return Observable.just(number); &#125;&#125;);number = 3;justObservable.subscribe(new Action1() &#123; @Override public void call(Object o) &#123; System.out.println(\"just result: \" + o.toString()); &#125;&#125;);deferObservable.subscribe(new Action1() &#123; @Override public void call(Object o) &#123; System.out.println(\"defer1 result: \" + o.toString()); &#125;&#125;);number = 4;deferObservable.subscribe(new Action1() &#123; @Override public void call(Object o) &#123; System.out.println(\"defer2 result: \" + o.toString()); &#125;&#125;); 四、运行结果123just result: 1defer1 result: 3defer2 result: 4 由运行结果可以看出： just操作符是在创建Observable就进行了赋值操作，而defer是在订阅者订阅时才创建Observable，此时才进行真正的赋值操作，保证Observable的状态是最新的。 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"defer","slug":"defer","permalink":"http://sherlockshi.github.io/tags/defer/"}]},{"title":"RxJava操作符实践：1_创建操作之1_create","date":"2016-10-12T06:51:00.000Z","path":"2016/10/12/15_Android/1560_RxJava/RxJava操作符实践：1_创建操作之1_create/","text":"一、描述你可以使用 Create 操作符从头开始创建一个Observable，给这个操作符传递一个接受观察者作为参数的函数，编写这个函数让它的行为表现为一个Observable–恰当的调用观察者的onNext，onError和onCompleted方法。 一个形式正确的有限Observable必须尝试调用观察者的onCompleted正好一次或者它的onError正好一次，而且此后不能再调用观察者的任何其它方法。 RxJava将这个操作符实现为create方法。 建议你在传递给create方法的函数中检查观察者的isUnsubscribed状态，以便在没有观察者的时候，让你的Observable停止发射数据或者做昂贵的运算。 create方法默认不在任何特定的调度器上执行。 二、示意图 三、示例代码123456789101112131415161718192021222324252627282930Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; observer) &#123; try &#123; if (!observer.isUnsubscribed()) &#123; for (int i = 0; i &lt; 4; i++) &#123; observer.onNext(i); &#125; observer.onCompleted(); &#125; &#125; catch (Exception e) &#123; observer.onError(e); &#125; &#125;&#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println(\"onCompleted.\"); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"onError: \" + e.getMessage()); &#125; @Override public void onNext(Integer integer) &#123; System.out.println(\"onNext: \" + integer); &#125;&#125;); 四、运行结果12345onNext: 0onNext: 1onNext: 2onNext: 3onCompleted. 项目代码已上传到Github：https://github.com/SherlockShi/RxJavaBestPractise 五、参考资料ReactiveX官方文档 ReactiveX文档中文翻译 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://sherlockshi.github.io/tags/RxJava/"},{"name":"操作符","slug":"操作符","permalink":"http://sherlockshi.github.io/tags/操作符/"},{"name":"创建操作","slug":"创建操作","permalink":"http://sherlockshi.github.io/tags/创建操作/"},{"name":"create","slug":"create","permalink":"http://sherlockshi.github.io/tags/create/"}]},{"title":"Android WebView图片适配解决方案","date":"2016-10-12T06:28:00.000Z","path":"2016/10/12/15_Android/1525_网络/AndroidWebView图片适配解决办法/","text":"WebView的各种坑，今天又让我发现一个。 一、懵逼最近公司项目中新闻模块需要用WebView来加载，而且服务端返回的是String类型的html代码，包含各种标签，各种转义符，一开始直接用loadDataWithBaseURL()加载的时候，出现各种&amp;lt;、&amp;gt;，直接懵逼了，后面一查，只是因为转义符的关系，那直接用String类的replace()方法替换成对应的&lt;、&gt;，就搞定了。 但是当新闻里面的图片大于屏幕宽度时，会出现横向滚动条，图片也只显示部分，向右滚动屏幕才能看到剩余的图片内容，这样极不方便，也不美观。 网上搜索了一番，有种解决方案是直接把整个WebView的绽放比例变小，适配屏幕，这样出来的图片是适配屏幕了，但是文字就变得非常小，完全就是把PC端网页塞进手机的感觉了。 二、转机突然看到泡在网上的日子大哥的一篇文章WebView加载图片超过屏幕大小的问题，说的是让PC端在img标签里面配置一下最大宽度就可以解决了： 12345678&lt;style&gt; img&#123; max-width:80%; height:auto;&#125; &lt;/style&gt; 三、再次懵逼赶紧联系服务端人员，结果被告知，这是使用某个框架做出来的效果，没办法修改里面的样式，这不又再次懵逼了吗… 四、柳暗花明又一村程序员都是打不死的蟑螂，只要有一线希望，就要努力去实现自己的价值，不，保住自己的饭碗。 上面泡网大哥的方法，其实就是给img设置样式。那服务端搞不定，就只能我们客户端这边来做了，能不能我们直接给每个img标签都加上最大宽度的限制呢？既然我们能把转义符替换掉，那是不是也能用同样的方法来加样式呢？ 五、解决方案答案是肯定的，在我们获取到的String类型的html代码里面，我们已经把转义符replace成我们实际需要的字符，这时候我们就能取到img的标签了(&lt;img&gt;)，那只要加上如下的代码，就可以了： 1htmlData = htmlData.replace(\"&lt;img\", \"&lt;img style='max-width:90%;height:auto;'\"); 原理就是上面分析的，在每个img标签里面，加上最大宽度和高度的控制，最大宽度比例可以根据需要自由设置。经过测试，暂时没发现问题，如果大家有发现问题，或者有其它的解决方案，欢迎随时给我留言。 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"网络","slug":"网络","permalink":"http://sherlockshi.github.io/tags/网络/"},{"name":"WebView","slug":"WebView","permalink":"http://sherlockshi.github.io/tags/WebView/"},{"name":"图片","slug":"图片","permalink":"http://sherlockshi.github.io/tags/图片/"}]},{"title":"Material Animations 4：Circular Reveal Animations","date":"2016-10-11T15:18:00.000Z","path":"2016/10/11/15_Android/1545_动画/MaterialAnimations4_CircularRevealAnimations/","text":"一、前言Circular Reveal Animations，官方称之为循环揭露动画效果，是一种用来显示/隐藏一组UI界面元素的动画效果，它是在API 21引入的，对应的类是ViewAnimationUtils。 循环揭露动画效果可以和共享元素变换动画组合，用来创造一些有意义的动画效果，自然地告诉用户这个app有些什么东西，将会产生怎样的效果。 二、效果图 三、实现在上面的例子中，依次发生了： 橘色的圆是一个共享元素，从MainActivity变换到CircularRevealActivity； 在CircularRevealActivity中有一个监听器(listener)，用来监听共享元素转换动画的结束，当动画结束时，做了这么两件事： 为Toolbar执行了一个循环揭露动画 为CircularRevealActivity中的视图(Views)执行了一个放大动画，使用的是以前的ViewPropertyAnimator类 监听共享元素进入动画的结束 12345678910Transition transition = TransitionInflater.from(this).inflateTransition(R.transition.changebounds_with_arcmotion);getWindow().setSharedElementEnterTransition(transition);transition.addListener(new Transition.TransitionListener() &#123; @Override public void onTransitionEnd(Transition transition) &#123; animateRevealShow(mToolbar); animateButtonsIn(); &#125; ...&#125;); animateRevealShow(mToolbar) 1234567891011private void animateRevealShow(View viewRoot) &#123; int centerX = (viewRoot.getLeft() + viewRoot.getRight()) / 2; int centerY = (viewRoot.getTop() + viewRoot.getBottom()) / 2; int endRadius = Math.max(viewRoot.getWidth(), viewRoot.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(viewRoot, centerX, centerY, 0, endRadius); viewRoot.setVisibility(View.VISIBLE); animator.setDuration(1000); animator.setInterpolator(new AccelerateInterpolator()); animator.start();&#125; 上述方法的重点是createCircularReveal (View view, int centerX, int centerY, float startRadius, float endRadius)：view：要执行循环揭露动画的ViewcenterX：循环揭露动画中心位置的X坐标centerY：循环揭露动画中心位置的Y坐标startRadius：循环揭露动画的起始半径endRadius：循环揭露动画的结束半径 animateButtonsIn() 1234567891011private void animateButtonsIn() &#123; for (int i = 0; i &lt; bgViewGroup.getChildCount(); i++) &#123; View child = bgViewGroup.getChildAt(i); child.animate() .setStartDelay(100 + i*DELAY) .setInterpolator(interpolator) .alpha(1) .scaleX(1) .scaleY(1); &#125;&#125; 上述方法为底部的4个圆执行了一个放大动画，使用ViewPropertyAnimator类。 四、更多还有一些不同的方式来创建循环揭露动画，关键是使用动画效果让用户更好地理解这个app有些什么东西，将会产生怎样的效果。 1. 从目标视图的中心创建循环揭露动画 1234567891011public void revealGreenAtMiddle(View view) &#123; int centerX = (bgViewGroup.getLeft() + bgViewGroup.getRight()) / 2; int centerY = (bgViewGroup.getTop() + bgViewGroup.getBottom()) / 2; int endRadius = (int) Math.hypot(bgViewGroup.getWidth()/2, bgViewGroup.getHeight()/2); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.green); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start();&#125; 2. 从目标视图的顶部创建循环揭露动画+底部按钮动画 1234567891011121314151617181920public void revealBlueAtTop(View view) &#123; animateButtonsOut(); int centerX = (bgViewGroup.getLeft() + bgViewGroup.getRight()) / 2; int centerY = 0; int endRadius = (int) Math.hypot(bgViewGroup.getWidth()/2, bgViewGroup.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.blue); animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationEnd(Animator animation) &#123; animateButtonsIn(); &#125; ... &#125;); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start();&#125; 此处动画效果经历了以下3个步骤： 隐藏底部按钮（通过控制按钮的透明度、缩放比例） 从顶部执行循环揭露动画 监听器监听到揭露动画执行完后，显示底部按钮（还是通过控制按钮的透明度、缩放比例） 3. 在点击位置创建循环揭露动画 首先，给橘色圆添加触摸监听事件，获取点击到的橘色圆的位置坐标： 123456789findViewById(R.id.iv_square_orange).setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (v.getId() == R.id.iv_square_orange) &#123; revealOrangeAtPoint(event.getRawX(), event.getRawY()); &#125; return false; &#125;&#125;); 接着，就跟前面一样了，根据获取到的坐标位置创建循环揭露动画： 1234567891011private void revealOrangeAtPoint(float rawX, float rawY) &#123; int centerX = (int) rawX; int centerY = (int) rawY; int endRadius = (int) Math.hypot(bgViewGroup.getWidth(), bgViewGroup.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.orange); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start();&#125; 4. 属性变化动画+循环揭露动画 这个会难那么一丢丢，毕竟是两个动画效果的组合技，但是只要抓住上一篇讲的属性变化动画和上面讲的循环揭露动画这两个点，就不难理解了。 123456789101112131415161718192021222324252627private void revealRedAtCenter() &#123; final ViewGroup.LayoutParams originalParams = ivSquareRed.getLayoutParams(); Transition transition = TransitionInflater.from(this).inflateTransition(R.transition.changebounds_with_arcmotion); transition.addListener(new Transition.TransitionListener() &#123; @Override public void onTransitionEnd(Transition transition) &#123; int centerX = (bgViewGroup.getLeft() + bgViewGroup.getRight()) / 2; int centerY = (bgViewGroup.getTop() + bgViewGroup.getBottom()) / 2; int endRadius = (int) Math.hypot(bgViewGroup.getWidth(), bgViewGroup.getHeight()); Animator animator = ViewAnimationUtils.createCircularReveal(bgViewGroup, centerX, centerY, 0, endRadius); bgViewGroup.setBackgroundResource(R.color.red); animator.setDuration(getResources().getInteger(android.R.integer.config_longAnimTime)); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.start(); ivSquareRed.setLayoutParams(originalParams); &#125; ... &#125;); TransitionManager.beginDelayedTransition(bgViewGroup, transition); RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT); params.addRule(RelativeLayout.CENTER_IN_PARENT); ivSquareRed.setLayoutParams(params);&#125; 五、总结本篇的重点就1个内容：createCircularReveal (View view, int centerX, int centerY, float startRadius, float endRadius) 只要抓住这两条主线，其它的内容都可以按主线来抽丝拨茧，一切难题都可以迎刃而解。 项目代码已分享到Github：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 六、参考资料Material Animations PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Material","slug":"Material","permalink":"http://sherlockshi.github.io/tags/Material/"},{"name":"Animations","slug":"Animations","permalink":"http://sherlockshi.github.io/tags/Animations/"},{"name":"View Animations","slug":"View-Animations","permalink":"http://sherlockshi.github.io/tags/View-Animations/"}]},{"title":"Material Animations 3：View Animations","date":"2016-10-07T15:02:00.000Z","path":"2016/10/07/15_Android/1545_动画/MaterialAnimations3_ViewAnimations/","text":"项目地址：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 一、前言 Transition框架可以用来给一个View的布局属性变化增加动画效果。你要做的事，就是改变你想改变的属性，然后Transition框架就会自动为你展示必要的动画效果。 Transition框架也可以用来给当前界面布局(current activity layout)里面的元素变化增加动画效果。Transition发生在各个场景(Scenes)中，一个场景只是我们UI布局中的一个常见的静态布局而已。只要从一个场景切换到另一个，Transition框架就会自动为场景的切换增加动画效果。 属性变化指的是某一个View，比如一个ImageView，它的宽度、高度、位置等参数的变化；元素变化指的是整个布局、场景里面的元素位置等参数的变化。它们的区别主要在于面向的对象不同，一个是针对View，一个是针对Layout。 二、效果图 属性变化 元素变化 三、属性变化1. 调用beginDelayedTransition()方法调用这行代码，就相当我们告诉Transition框架，“大哥，界面要变化了，你准备下，帮忙给点动效撒～” 1TransitionManager.beginDelayedTransition(llytRoot); 2. 改变View的属性然后只要改变View的某一个或多个属性。 123ViewGroup.LayoutParams params = ivSquareGreen.getLayoutParams();params.width = 200;ivSquareGreen.setLayoutParams(params); 改变View的宽度属性，会触发layoutMeasure，Transition框架就会记录下起始值和结束值，然后展示从起始值到结束值的动画效果。 四、元素变化1. 调用getSceneForLayout()方法这个方法会根据每一个布局文件，创建出一个个的场景(Scene)。 1234scene1 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene1, this);scene2 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene2, this);scene3 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene3, this);scene4 = Scene.getSceneForLayout(flytRoot, R.layout.activity_animations_scene4, this); 2. 调用go()方法调用这个方法，会跳转到下一个场景，并基于当前场景和目标场景展示指定的动画效果。 1TransitionManager.go(scene1, new ChangeBounds()); 五、参考资料Material Animations PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Material","slug":"Material","permalink":"http://sherlockshi.github.io/tags/Material/"},{"name":"Animations","slug":"Animations","permalink":"http://sherlockshi.github.io/tags/Animations/"},{"name":"View Animations","slug":"View-Animations","permalink":"http://sherlockshi.github.io/tags/View-Animations/"}]},{"title":"Material Design风格常用控件的使用与定制","date":"2016-10-06T13:25:19.000Z","path":"2016/10/06/15_Android/1545_动画/Material Design风格常用控件的使用与定制/","text":"项目地址：https://github.com/SherlockShi/MaterialWidgetPractise 一、前言你是否还在使用selector来定制Button普通状态、按下状态的变化呢？ 你是否也想自己的Button有Material Design的阴影效果呢？ 你是否也想让各种控件轻松变换各种颜色风格呢？ 那么看完这篇分享，你就会有答案了。 二、4种风格的Button系统默认有4种风格的Button效果，分别是 1234567Widget.AppCompat.ButtonWidget.AppCompat.Button.ColoredWidget.AppCompat.Button.BorderlessWidget.AppCompat.Button.Borderless.Colored 效果如下（1-4）： 按命名、并结合效果图可以看出，这4种风格对应两个属性：字体颜色、边框颜色（或称背景颜色）; 4种风格可完整描述为默认边框默认字体、彩色边框默认字体、无边框默认字体、无边框彩色字体，使用方法也很简单，只需在普通Button的xml布局文件中，加上style属性即可： 123456789101112131415&lt;Button ... style=\"@style/Widget.AppCompat.Button\" /&gt;&lt;Button ... style=\"@style/Widget.AppCompat.Button.Colored\" /&gt; &lt;Button ... style=\"@style/Widget.AppCompat.Button.Borderless\" /&gt; &lt;Button ... style=\"@style/Widget.AppCompat.Button.Borderless.Colored\" /&gt; 从上图也可以看到，不加style属性的话，默认是使用Widget.AppCompat.Button风格的。 后面两种无边框Button，只需要改变textColor属性来设置效果，没什么好说的；主要是前面两种，其实就是同一种效果：有边框颜色的Button，如何定制请看下一节内容。 三、各种颜色的Button你是否还在用selector文件来定制各种颜色、各种不同状态下的Button呢？如果一个应用中需要10个不同的Button，你是否需要定义10*4个xml文件呢？(normal状态+pressed状态+disabled状态+selector选择器) 其实使用系统的Button控件就可以轻松实现，只需要配置一定的属性。 首先，确保主题使用Material风格主题需要使用Theme.AppCompat或Theme.Design类的子主题（建议使用Theme.AppCompat子类主题，兼容Android 5.0以下版本），如Theme.AppCompat.Light。 其次，在style文件中设置Button颜色在styles.xml文件中设置colorButtonNormal属性： values/styles.xml 123&lt;style name=\"RedButton\"&gt; &lt;item name=\"colorButtonNormal\"&gt;#F44336&lt;/item&gt;&lt;/style&gt; 好了，一起来见证奇迹在布局文件中定义Button，增加theme属性(注意，是theme，不是style)： 123&lt;Button ... android:theme=\"@style/RedButton\" /&gt; 效果如下： 现在，就可以看到Button变成了你想要的颜色，而且点击后Button颜色也加深了，完全跟使用selector定制出来的一模一样。并且如果使用Android 5.0以上的手机，还会默认带有水纹波和阴影的炫酷效果。 四、其它各种常用控件 其余控件像CheckBox、RadioButton，可以用colorControlNormal、colorControlActivated（或colorAccent）来控制正常状态和按下状态的背景颜色； 而像Switch、EditText等控件，可以用colorControlActivated（或colorAccent）来控制背景颜色。 五、总结其实本篇主要只有两部分内容： 4种Button风格： 1234Widget.AppCompat.ButtonWidget.AppCompat.Button.ColoredWidget.AppCompat.Button.BorderlessWidget.AppCompat.Button.Borderless.Colored 4个控件属性 1234colorButtonNormal: Button正常状态颜色colorControlNormal: 控件正常状态颜色colorControlActivated: 选中或者点击获得焦点后的颜色colorAccent: 选中或者点击获得焦点后的颜色 现在，你是否对本篇开头的几个问题有了答案了呢？ PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"http://sherlockshi.github.io/tags/Material-Design/"},{"name":"控件","slug":"控件","permalink":"http://sherlockshi.github.io/tags/控件/"},{"name":"定制","slug":"定制","permalink":"http://sherlockshi.github.io/tags/定制/"}]},{"title":"为CardView添加点击后的抬升效果","date":"2016-10-05T12:34:38.000Z","path":"2016/10/05/15_Android/1545_动画/为CardView添加点击后的抬升效果/","text":"一、效果图在真机上阴影效果很好，录屏效果差一点。 二、实现方法1. 创建一个TranslationZ的变换动画 res/animator/touch_raise.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_enabled=\"true\" android:state_pressed=\"true\"&gt; &lt;objectAnimator android:duration=\"@android:integer/config_shortAnimTime\" android:propertyName=\"translationZ\" android:valueTo=\"8dp\" android:valueType=\"floatType\" /&gt; &lt;/item&gt; &lt;item&gt; &lt;objectAnimator android:duration=\"@android:integer/config_shortAnimTime\" android:propertyName=\"translationZ\" android:valueTo=\"0dp\" android:valueType=\"floatType\" /&gt; &lt;/item&gt;&lt;/selector&gt; 2. 为CardView加上属性CardView布局中加入属性android:stateListAnimator=&quot;@animator/touch_raise&quot;。 这样，你的卡片按住时就会有浮起的效果了（或称抬升、阴影加深）。 三、参考资料关于使用 CardView 开发过程中要注意的细节-泡在网上的日子 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"http://sherlockshi.github.io/tags/Material-Design/"},{"name":"CardView","slug":"CardView","permalink":"http://sherlockshi.github.io/tags/CardView/"}]},{"title":"Material Animations 2：Shared Element Transition","date":"2016-10-04T12:48:47.000Z","path":"2016/10/04/15_Android/1545_动画/MaterialAnimations2_SharedElements/","text":"项目地址：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 一、前言元素共享变换（shared element transition）决定了共享的view元素从一个Activity/Fragment 到另一个Activity/Fragment的切换中是如何动画变化的。 请记住，共享元素变换并不是真正实现了两个Activity或者Fragment之间元素的共享，界面还是两个不同界面，只不过Framework采用了不同的方法来达到相同的视觉效果。 二、效果图 三、实现方法1. 在主题中启用窗口内容转换 values-v21/styles.xml 1234&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; ... &lt;item name=\"android:windowContentTransitions\"&gt;true&lt;/item&gt;&lt;/style&gt; 2. 在styles.xml文件中指定一个共享元素转换 values-v21/styles.xml 12345678&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; ... &lt;item name=\"android:windowSharedElementExitTransition\"&gt;@transition/def_transition&lt;/item&gt; &lt;item name=\"android:windowSharedElementReenterTransition\"&gt;@transition/def_transition&lt;/item&gt; &lt;item name=\"android:windowSharedElementEnterTransition\"&gt;@transition/def_transition&lt;/item&gt; &lt;item name=\"android:windowSharedElementReturnTransition\"&gt;@transition/def_transition&lt;/item&gt;&lt;/style&gt; 此处也可以直接使用系统默认自带的转换效果，如果这么做，则下一步将转换效果定义为XML资源可省略 12345678&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; ... &lt;item name=\"android:windowSharedElementExitTransition\"&gt;@android:transition/move&lt;/item&gt; &lt;item name=\"android:windowSharedElementReenterTransition\"&gt;@android:transition/move&lt;/item&gt; &lt;item name=\"android:windowSharedElementEnterTransition\"&gt;@android:transition/move&lt;/item&gt; &lt;item name=\"android:windowSharedElementReturnTransition\"&gt;@android:transition/move&lt;/item&gt;&lt;/style&gt; 3. 将转换效果定义为XML资源（可选） transition-v21/def_transition.xml 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;transitionSet xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;changeBounds/&gt; &lt;changeTransform/&gt; &lt;changeClipBounds/&gt; &lt;changeImageTransform/&gt;&lt;/transitionSet&gt; changeBounds - 为目标视图的布局边界的变化添加动画。 changeClipBounds - 为目标视图的裁剪边界的变化添加动画。 changeTransform - 为目标视图的缩放与旋转变化添加动画。 changeImageTransform - 为目标图像的大小与缩放变化添加动画。 详细文档可参考Transition类或具体某一属性的API文档。 4. 为共享元素指定transitionName利用android:transitionName属性对两个布局中的共享元素指定一个通用名称： layout/activity_main.xml 12345678910111213&lt;ImageView android:id=\"@+id/iv_square_blue\" android:layout_width=\"48dp\" android:layout_height=\"48dp\" android:src=\"@drawable/circle_blue\" android:transitionName=\"@string/transition_name_square_blue\"/&gt;&lt;TextView android:id=\"@+id/tv_element_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/activity_main_shared_elements\" android:transitionName=\"@string/transition_name_element_title\"/&gt; activity_shared_elements.xml 1234567891011&lt;ImageView android:layout_width=\"120dp\" android:layout_height=\"120dp\" android:src=\"@drawable/circle_blue\" android:transitionName=\"@string/transition_name_square_blue\"/&gt;&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/activity_main_shared_elements\" android:transitionName=\"@string/transition_name_element_title\"/&gt; 要点：共享元素尽量设置固定值或wrap_content，否则在界面过渡的开始、结束位置容易出现闪屏。分析原因可能为：由于元素的居中等显示属性的不同导致，如设置文本居中显示，则元素从起始位置开始移动，到达结束位置时，先移动到结束时的居中位置，然后瞬间变到结束位置，如果这时候两个位置不一致，会造成闪屏。 5. 使用 makeSceneTransitionAnimation() 方法 MainActivity.java 1234567View ivSquareBlue = findViewById(R.id.iv_square_blue);String squareBlueTransitionName = getString(R.string.transition_name_square_blue);// only one shared elementsActivityOptionsCompat activityOptionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(this, ivSquareBlue, squareBlueTransitionName);startActivity(intent, activityOptionsCompat.toBundle()); 如果有多个共享元素，则使用以下方法： 123456789101112View ivSquareBlue = findViewById(R.id.iv_square_blue);String squareBlueTransitionName = getString(R.string.transition_name_square_blue);View tvElementTitle = findViewById(R.id.tv_element_title);String elementTitleTransitionName = getString(R.string.transition_name_element_title);// multiple shared elementsActivityOptionsCompat activityOptionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(this, Pair.create(ivSquareBlue, squareBlueTransitionName), Pair.create(tvElementTitle, elementTitleTransitionName));startActivity(intent, activityOptionsCompat.toBundle()); 四、参考资料Material Animations定义定制动画-Android开发文档 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Material","slug":"Material","permalink":"http://sherlockshi.github.io/tags/Material/"},{"name":"Animations","slug":"Animations","permalink":"http://sherlockshi.github.io/tags/Animations/"},{"name":"Shared Element","slug":"Shared-Element","permalink":"http://sherlockshi.github.io/tags/Shared-Element/"},{"name":"Transition","slug":"Transition","permalink":"http://sherlockshi.github.io/tags/Transition/"}]},{"title":"Material Animations 1：Content Transitions","date":"2016-10-03T14:36:34.000Z","path":"2016/10/03/15_Android/1545_动画/MaterialAnimations1_ContentTransitions/","text":"项目地址：https://github.com/SherlockShi/AndroidMaterialAnimationPractise 一、前言 同overridePendingTransition()方法执行效果类似 Content Transition也称为Transitions between Activities，或Enter/Exit Transition，包括下图4个部分（本图截取自Udacity）： 1. Exit A: 离开A界面时的转换动画 2. Enter B: 进入B界面时的转换动画 3. Return B: 从B界面返回时的转换动画；可不设置，默认执行Enter B的逆过程 4. Reenter A: 重新进入A界面时的转换动画；可不设置，默认执行Exit A的逆过程 二、效果图 三、实现方法1. 编码实现 ActivityA.java 1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_a); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Slide slide = new Slide(); slide.setDuration(500); slide.setSlideEdge(Gravity.LEFT); getWindow().setExitTransition(slide);// getWindow().setReenterTransition(slide);&#125; ActivityB.java 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_b); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Fade fade = new Fade(); fade.setDuration(500); getWindow().setEnterTransition(fade);// getWindow().setReturnTransition(slide);&#125; 由于大部分相关API只支持API 19以上版本，甚至只支持API 21以上版本，因此需要添加如下判断： 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; ...&#125; 2. XML &amp; Code实例化实现定义XML res/transition-v21/fade.xml 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;fade xmlns:android=\"http://schemas.android.com/apk/res/\" android:duration=\"500\"/&gt; res/transition-v21/slide.xml 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;slide xmlns:android=\"http://schemas.android.com/apk/res/\" android:duration=\"500\"/&gt; Code实例化 ActivityA.java 1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_a); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Slide slide = TransitionInflater.from(this).inflateTransition(R.transition.slide); getWindow().setExitTransition(slide);&#125; ActivityB.java 1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_b); setupWindowAnimations();&#125;private void setupWindowAnimations() &#123; Fade fade = TransitionInflater.from(this).inflateTransition(R.transition.fade); getWindow().setEnterTransition(fade);&#125; 3. XML &amp; Style声明式实现（强烈推荐）定义XML 如果没有其它属性要求，本步骤可跳过，直接在下一步使用系统定义好的XML 同XML &amp; Code实例化实现一样，声明XML文件 res/transition-v21/fade.xml 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;fade xmlns:android=\"http://schemas.android.com/apk/res/\" android:duration=\"500\"/&gt; res/transition-v21/slide.xml 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;slide xmlns:android=\"http://schemas.android.com/apk/res/\" android:duration=\"500\"/&gt; Style文件声明 res/values-v21/styles.xml 12345678&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; ... &lt;item name=\"android:windowExitTransition\"&gt;@transition/slide&lt;/item&gt; &lt;item name=\"android:windowReenterTransition\"&gt;@transition/slide&lt;/item&gt; &lt;item name=\"android:windowEnterTransition\"&gt;@transition/slide&lt;/item&gt; &lt;item name=\"android:windowReturnTransition\"&gt;@transition/slide&lt;/item&gt;&lt;/style&gt; 也可以直接使用系统提供的过渡效果： 12345678&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; ... &lt;item name=\"android:windowExitTransition\"&gt;@android:transition/slide_left&lt;/item&gt; &lt;item name=\"android:windowReenterTransition\"&gt;@android:transition/slide_left&lt;/item&gt; &lt;item name=\"android:windowEnterTransition\"&gt;@android:transition/slide_right&lt;/item&gt; &lt;item name=\"android:windowReturnTransition\"&gt;@android:transition/slide_right&lt;/item&gt;&lt;/style&gt; 声明打开Content Transitions（非必须） 如果上一个步骤继承的父主题不是AppCompt相关主题，还需要在styles.xml文件中声明: 1&lt;item name=\"android:windowContentTransitions\"&gt;true&lt;/item&gt; 四、跳转12startActivity(new Intent(ActivityA.this, ActivityB.class), ActivityOptionsCompat.makeSceneTransitionAnimation(ActivityA.this).toBundle()); 五、返回1finishAfterTransition(); 六、参考资料https://github.com/lgvalle/Material-Animations PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Material","slug":"Material","permalink":"http://sherlockshi.github.io/tags/Material/"},{"name":"Animations","slug":"Animations","permalink":"http://sherlockshi.github.io/tags/Animations/"},{"name":"Transitions","slug":"Transitions","permalink":"http://sherlockshi.github.io/tags/Transitions/"}]},{"title":"nodeppt常用功能","date":"2016-10-03T02:53:30.000Z","path":"2016/10/03/10_Markdown/nodeppt常用功能/","text":"更多功能请参考nodeppt官方文档 一、 启动1nodeppt start 二、导出html导出全部，包括nodeppt的js、img和css文件夹默认导出在publish文件夹1nodeppt generate filepath -a 三、导出ppt使用url?print=1访问页面，然后选择chrome的系统打印即可：打印 -&gt; 使用系统对话框进行打印 -&gt; (左下角)存储为PDF... 注意url中不能包含“#1”等具体页码信息，否则打印时会只打印一页","tags":[{"name":"markdown","slug":"markdown","permalink":"http://sherlockshi.github.io/tags/markdown/"},{"name":"nodeppt","slug":"nodeppt","permalink":"http://sherlockshi.github.io/tags/nodeppt/"},{"name":"ppt","slug":"ppt","permalink":"http://sherlockshi.github.io/tags/ppt/"}]},{"title":"Android程序员简历模板","date":"2016-10-02T14:50:00.000Z","path":"2016/10/02/45_工作/4505_简历/Android程序员简历模板/","text":"其他程序员简历模板可参考ResumeSample Android程序员简历模板本简历模板由国内首家互联网人才拍卖网站「 JobDeer.com 」提供。 （括号里的是我们的顾问编写的说明，建议在简历书写完成后统一删除） 先讲讲怎样才是一份好的技术简历首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。 Feature：是什么 Advantage：比别人好在哪些地方 Benefit：如果雇佣你，招聘方会得到什么好处 其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。 举个例子，下边内容是虚构的： 2006年，我参与了手机XX网发布系统WAPCMS的开发（这部分是大家都会写的）。作为核心程序员，我不但完成了网站界面、调度队列的开发工作，更提出了高效的组件级缓存系统，通过碎片化缓冲有效的提升了系统的渲染效率。（这部分是很多同学忘掉的，要写出你在这个项目中具体负责的部分，以及你贡献出来的价值。）在该系统上线后，Web前端性能从10QPS提升到200QPS，服务器由10台减少到3台（通过量化的数字来增强可信度）。2008年我升任WAPCMS项目负责人，带领一个3人小组支持着每天超过2亿的PV（这就是Benefit。你能带给前雇主的价值，也就是你能带给新雇主的价值。）。 有同学问，如果我在项目里边没有那么显赫的成绩可以说怎么办？讲不出成绩时，就讲你的成长。因为学习能力也是每家公司都看中的东西。你可以写你在这个项目里边遇到了一个什么样的问题，别人怎么解决的，你怎么解决的，你的方案好在什么地方，最终这个方案的效果如何。 具体、量化、有说服力，是技术简历特别需要注重的地方。 （以上内容在写完简历后，对每一段进行评估，完成后再删除） 联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机：135** （如果是外地手机，可注明。如经常关机，要写上最优联系时间） Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G） QQ/微信号：6*（提供一个通过网络可以联系到你的方式） 个人信息 胶布帝/男/1990 本科/萌鹿大学计算机系 工作年限：3年 微博：@JobDeer （如果没有技术相关内容，也可以不放） 技术博客：http://blog.github.io ( 使用GitHub Host的Big较高 ) GitHub: http://github.com/geekcompany ( 有原创repo的GitHub帐号会极大的提升你的个人品牌 ) 期望职位：Android高级程序员，应用架构师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目（对于程序员来讲，没有什么比Show me the code能有说服力了） STU : 项目的简要说明，Star和Fork数多的可以注明 WXYZ : 项目的简要说明，Star和Fork数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自HeroKu的HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014架构师大会演讲：如何通过Docker优化内部开发 9月公司内部分享：云计算的前生今世 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 参考技能关键字本技能关键字列表是从最近招聘Android的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。 android(1830) java(386) ui(180) app(178) http(149) sdk(135) tcp(95) socket(93) api(60) xml(48) framework(48) eclipse(41) linux(38) json(28) ndk(27) ios(27) sqlite(26) andriod(25) 2%的HR把android给写错了 T_T html5(25) web(23) github(21) jni(20) svn(15) gui(14) git(13) wifi(10) 3g(10) j2me(10) mysql(10) oracle(9) html(9) sql(8) tv(8) mvc(8) lbs(8) code review(7) im(7) mobile(6) view(6) stackoverflow(6) xmpp(6) o2o(5) ue(5) objective(5) js(5) blog(5) andorid(5) rom(5) launcher(5) restful(5) webservice(4) apk(4) androidsdk(4) oo(4) javascript(4) j2ee(4) opengl(4) uml(4) sms(3) windows(3) market(3) audio(3) httptps(3) udp(3) store(3) php(3) unity3d(3) native(3) webview(3) 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"程序员","slug":"程序员","permalink":"http://sherlockshi.github.io/tags/程序员/"},{"name":"简历","slug":"简历","permalink":"http://sherlockshi.github.io/tags/简历/"},{"name":"模板","slug":"模板","permalink":"http://sherlockshi.github.io/tags/模板/"}]},{"title":"宽高比可配置的ImageView-AspectRatioImageView","date":"2016-10-02T13:08:17.000Z","path":"2016/10/02/15_Android/1540_Widget/宽高比可配置的ImageView-AspectRatioImageView/","text":"Github项目地址：https://github.com/SherlockShi/AspectRatioImageView 一、前言在项目开发过程中，经常会有这样的情况：美工MM切好一张图，个人信息界面顶部的背景，美美的，但是要求宽高比例一定要5：3，不然图片会变形。好，说干就干。 width肯定是要match_parent了，图片宽度才能与屏幕宽度一致，但是高度呢？wrap_content？那肯定不行，图片肯定变形了。某个固定的高度值呢？那也不行。 如此，便有了这个方便的自定义View - AspectRatioImageView，简单得只需要像普通的ImageView一样使用，再配置一定的宽度比例值、高度比例值，就可轻松实现上面的需求了。 二、一言不合就上图 三、使用方法依赖使用Gradle依赖:1234dependencies &#123; ... compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1'&#125; 或使用Maven依赖:123456&lt;dependency&gt; &lt;groupId&gt;com.sherlockshi.widget&lt;/groupId&gt; &lt;artifactId&gt;aspectratioimageview&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 用法像使用ImageView一样，在XML文件中使用:1234567&lt;com.sherlockshi.widget.AspectRatioImageView android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:scaleType=\"centerCrop\" app:width_ratio=\"4\" app:height_ratio=\"2\" android:src=\"...\"/&gt; 属性AspectRatioImageView有以下两个属性:width_ratio: 宽度比例值，类型为integerheight_ratio: 高度比例值，类型为integer 以上两个属性，只要有一个属性未设置，就会使用默认比例3:2. 以上，你就可以和美工MM愉快地出去喝一杯了，不不，你就可以轻松实现项目需求了。 PS：欢迎关注SherlockShi博客","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"自定义","slug":"自定义","permalink":"http://sherlockshi.github.io/tags/自定义/"},{"name":"View","slug":"View","permalink":"http://sherlockshi.github.io/tags/View/"},{"name":"ImageView","slug":"ImageView","permalink":"http://sherlockshi.github.io/tags/ImageView/"},{"name":"AspectRatioImageView","slug":"AspectRatioImageView","permalink":"http://sherlockshi.github.io/tags/AspectRatioImageView/"}]},{"title":"Hexo常用命令","date":"2016-10-02T03:45:47.000Z","path":"2016/10/02/30_博客/3005_Hexo/Hexo常用命令/","text":"一、启动服务预览1hexo s hexo s = hexo server 二、快捷部署1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g == hexo generate #生成静态网页hexo d == hexo deploy #开始部署","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://sherlockshi.github.io/tags/Hexo/"},{"name":"命令","slug":"命令","permalink":"http://sherlockshi.github.io/tags/命令/"},{"name":"常用","slug":"常用","permalink":"http://sherlockshi.github.io/tags/常用/"}]},{"title":"使用Android Studio把自己的Android library分发到JCenter","date":"2016-09-29T15:28:01.000Z","path":"2016/09/29/15_Android/1555_Maven/使用Android Studio把自己的Android library分发到jCenter/","text":"前言如果你想在Android Studio中引入一个library到你的项目，你只需添加如下的一行代码到模块的build.gradle文件中: 1compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1' 就是如此简单的一行代码，你就可以使用这个library了。 酷呆了。不过你可能很好奇Android Studio是从哪里得到这个library的。这篇文章将详细讲解这是怎么回事，包括如何把你的库发布出去分享给世界各地的其他开发者，这样不仅可以让世界更美好，还可以耍一次酷。 一、Android studio 是从哪里得到库的？先从这个简单的问题开始，我相信不是每个人都完全明白Android studio 是从哪里得到这些library的。莫非就是Android studio 从google搜索然后下载了一个合适的给我们？ 呵呵，没那么复杂。Android Studio是从build.gradle里面定义的Maven 仓库服务器上下载library的。Apache Maven是Apache开发的一个工具，提供了用于贡献library的文件服务器。总的来说，只有两个标准的Android library文件服务器：JCenter 和 Maven Central。 1. JCenterJCenter是一个由bintray.com维护的Maven仓库 。你可以在这里看到整个仓库的内容。我们在项目的build.gradle 文件中如下定义仓库，就能使用JCenter了： 12345allprojects &#123; repositories &#123; jcenter() &#125;&#125; 2. Maven CentralMaven Central 则是由sonatype.org维护的Maven仓库。你可以在这里看到整个仓库。 注：不管是JCenter还是Maven Central ，两者都是Maven仓库 我们在项目的build.gradle 文件中如下定义仓库，就能使用Maven Central了： 12345allprojects &#123; repositories &#123; mavenCentral() &#125;&#125; 注意，虽然JCenter和Maven Central 都是标准的 android library仓库，但是它们维护在完全不同的服务器上，由不同的人提供内容，两者之间毫无关系。在JCenter上有的可能 Maven Central 上没有，反之亦然。 除了两个标准的服务器之外，如果我们使用的library的作者是把该library放在自己的服务器上，我们还可以自己定义特有的Maven仓库服务器。Twitter的Fabric.io 就是这种情况，它们在 https://maven.fabric.io/public 上维护了一个自己的Maven仓库。如果你想使用Fabric.io的library，你必须自己如下定义仓库的url。 123repositories &#123; maven &#123; url 'https://maven.fabric.io/public' &#125;&#125; 然后在里面使用相同的方法获取一个library: 1compile 'com.crashlytics.sdk.android:crashlytics:2.2.4@aar' 但是将library上传到标准的服务器与自建服务器，哪种方法更好呢？当然是前者。如果将我们的library公开，其他开发者除了一行定义依赖名的代码之外不需要定义任何东西。因此这篇文章中，我们将只关注对开发者更友好的JCenter 和 Maven Central 。 实际上可以在Android Studio上使用的除了Maven 仓库之外还有另外一种仓库：Ivy 仓库 。但是根据我的经验来看，我还没看到任何人用过它，包括我，因此本文就直接忽略了。 二、理解JCenter和Maven Central为何有两个标准的仓库？ 事实上两个仓库都具有相同的使命：提供Java或者Android library服务。上传到哪个（或者都上传）取决于开发者。 起初，Android Studio 选择Maven Central作为默认仓库。如果你使用老版本的Android Studio创建一个新项目，mavenCentral()会自动的定义在build.gradle中。 但是Maven Central的最大问题是对开发者不够友好。上传library异常困难。上传上去的开发者都是某种程度的极客。同时还因为诸如安全方面的其他原因，Android Studio团队决定把默认的仓库替换成JCenter。正如你看到的，一旦使用最新版本的Android Studio创建一个项目，JCenter()自动被定义，而不是mavenCentral()。 有许多将Maven Central替换成JCenter的理由，下面是几个主要的原因。 JCenter通过CDN发送library，开发者可以享受到更快的下载体验。 JCenter是全世界最大的Java仓库，因此在Maven Central 上有的，在JCenter上也极有可能有。换句话说JCenter是Maven Central的超集。 上传library到仓库很简单，不需要像在Maven Central上做很多复杂的事情。 友好的用户界面 如果你想把library上传到Maven Central ，你可以在bintray网站上直接点击一个按钮就能实现。 基于上面的原因以及我自己的经验，可以说替换到JCenter是明智之举。 所以我们这篇文章将把重心放在JCenter，反正如果你能成功把library放在JCenter，转到 Maven Central 是非常容易的事情。 三、gradle是如何从仓库上获取一个library的？在讨论如何上传library到JCenter之前，我们先看看gradle是如何从仓库获取library的。比如我们在 build.gradle输入如下代码的时候，这些库是如果奇迹般下载到我们的项目中的。 1compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1' 一般来说，我们需要知道library的字符串形式，包含3部分 1GROUP_ID:ARTIFACT_ID:VERSION 上面的例子中，GROUP_ID是com.sherlockshi.widget，ARTIFACT_ID是aspectratioimageview，VERSION是1.0.1。 GROUP_ID定义了library的group。有可能在同样的上下文中存在多个不同功能的library。如果library具有相同的group，那么它们将共享一个GROUP_ID。通常我们以开发者包名紧跟着library的group名称来命名，比如com.squareup.picasso。然后ARTIFACT_ID中是library的真实名称。至于VERSION，就是版本号而已，虽然可以是任意文字，但是我建议设置为x.y.z的形式，如果喜欢还可以加上beta这样的后缀。 下面是Square library的一个例子。你可以看到每个都可以很容易的分辨出library和开发者的名称。 123456dependencies &#123; compile 'com.squareup:otto:1.3.7' compile 'com.squareup.picasso:picasso:2.5.2' compile 'com.squareup.okhttp:okhttp:2.4.0' compile 'com.squareup.retrofit:retrofit:1.9.0'&#125; 那么在添加了上面的依赖之后会发生什么呢？简单。Gradle会询问Maven仓库服务器这个library是否存在，如果是，gradle会获得请求library的路径，一般这个路径都是这样的形式：GROUP_ID/ARTIFACT_ID/VERSION_ID。比如可以在http://jcenter.bintray.com/com/squareup/otto/1.3.7 和 https://oss.sonatype.org/content/repositories/releases/com/squareup/otto/1.3.7/下获得com.squareup:otto:1.3.7的library文件。 然后Android Studio 将下载这些文件到我们的电脑上，与我们的项目一起编译。整个过程就是这么简单，一点都不复杂。 我相信你应该清楚的知道从仓库上下载的library只是存储在仓库服务器上的jar 或者aar文件而已。有点类似于自己去下载这些文件，拷贝然后和项目一起编译。但是使用gradle依赖管理的最大好处是你除了添加几行文字之外啥也不做。library一下子就可以在项目中使用了。 四、了解aar文件等等，我刚才说了仓库中存储的有两种类型的library：jar 和 aar。jar文件大家都知道，但是什么是aar文件呢？ aar文件时在jar文件之上开发的。之所以有它是因为有些Android Library需要植入一些安卓特有的文件，比如AndroidManifest.xml，资源文件，Assets或者JNI。这些都不是jar文件的标准。 因此aar文件就时发明出来包含所有这些东西的。总的来说它和jar一样只是普通的zip文件，不过具有不同的文件结构。jar文件以classes.jar的名字被嵌入到aar文件中。其余的文件罗列如下：– /AndroidManifest.xml (mandatory)– /classes.jar (mandatory)– /res/ (mandatory)– /R.txt (mandatory)– /assets/ (optional)– /libs/.jar (optional)– /jni//.so (optional)– /proguard.txt (optional)– /lint.jar (optional)可以看到.aar文件是专门为安卓设计的。因此这篇文章将教你如何创建与上传一个aar形式的library。 五、如何上传library到JCenter我相信你已经知道了仓库系统的大体工作原理。现在我们来开始最重要的部分：上传。这个任务和如何上传library文件到http://jcenter.bintray.com 一样简单。如果做到，这个library就算发布了。好吧，有两个需要考虑：如何创建aar文件以及如何上传构建的文件到仓库。 虽然需要若干步骤，但是我还是想强调这事并不复杂，因为已经准备好了所有事情。整个过程如下图： 因为细节比较多，我分为以下几个部分，一步一步的详细解释清楚。 1. 在bintray上创建package第一步 在bintray.com上注册一个账号。（注册过程很简单，自己完成，也可以直接使用Github账号） 第二步 完成注册之后，登录网站，然后点击+号 第三步 输入Repository相关信息，创建一个Repository 第四步 点击打开刚才创建好的Repository 第五步 点击Add New Package，为我们的library创建一个新的package 第六步 按页面要求填写相关信息 完工！现在你有了自己在Bintray上的Maven仓库，可以准备上传library到上面了。 2. 准备一个Android Studio项目很多情况下，我们需要同时上传一个以上的library到仓库，也可能不需要上传东西。因此我建议最好将每部分分成一个Module。最好分成两个module，一个Application Module一个Library Module。Application Module用于展示库的用法，Library Module是library的源代码。如果你的项目有一个以上的library，尽量创建另外的module：1个 module对应1 个library。我相信大家知道如何创建一个新的module，因此就不会深入讲解这个问题了。其实很简单，基本就是选择 File -&gt; New -&gt; Module，选择Android Library，然后就完了。 添加bintray插件 我们需要修改项目的build.gradle文件中的依赖部分，如下： 12345dependencies &#123; ... classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1'&#125; 配置Bintray账号以及开发者信息 接下来我们将修改local.properties。在里面定义api key的用户名以及被创建key的密码，用于bintray的认证。之所以要把这些东西放在这个文件是因为这些信息时比较敏感的，不应该到处分享，包括版本控制里面。幸运的是在创建项目的时候local.properties文件就已经被添加到.gitignore了。因此这些敏感数据不会被误传到git服务器。 下面是要添加的代码： 12345678#bintraybintray.user=******bintray.apikey=******#developerdeveloper.id=******developer.name=******developer.email=****** bintray.user：你的Bintray的用户名 bintray.apikey：你的的Bintray的API Key,可以在Edit Profile页面的 API Key 选项卡中找到 developer.id：通常是你在开源社区的昵称 developer.name：你的姓名 developer.email：你的邮箱 配置项目信息 在library module目录下新建project.properties文件，输入以下内容： 1234567891011#projectproject.name=AspectRatioImageViewproject.bintrayRepo=android-widgetsproject.groupId=com.sherlockshi.widgetproject.artifactId=aspectratioimageviewproject.packaging=aarproject.siteUrl=https://github.com/SherlockShi/AspectRatioImageViewproject.gitUrl=https://github.com/SherlockShi/AspectRatioImageView.git#javadocjavadoc.name=AspectRatioImageView project.name：项目名称 project.groupId：项目组ID project.artifactId：项目ID project.packaging：包类型，Android库是aar project.siteUrl：项目官方网站的地址，没有的话就用Github上的地址 project.gitUrl：项目的Git地址 javadoc.name：生成的javadoc打开后主页显示的名称，通常跟项目名称一样即可 配置bintrayUpload.gradle 本步骤也可以直接使用别人打包好的脚本引入即可，但本文主要介绍原理，有需要的可以自己搜索。 首先在library module目录下新建bintrayUpload.gradle文件，直接粘贴以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'// load propertiesProperties properties = new Properties()File localPropertiesFile = project.file(\"../local.properties\");if(localPropertiesFile.exists())&#123; properties.load(localPropertiesFile.newDataInputStream())&#125;File projectPropertiesFile = project.file(\"project.properties\");if(projectPropertiesFile.exists())&#123; properties.load(projectPropertiesFile.newDataInputStream())&#125;// read propertiesdef projectName = properties.getProperty(\"project.name\")def projectBintrayRepo = properties.getProperty(\"project.bintrayRepo\")def projectGroupId = properties.getProperty(\"project.groupId\")def projectArtifactId = properties.getProperty(\"project.artifactId\")def projectVersionName = android.defaultConfig.versionNamedef projectPackaging = properties.getProperty(\"project.packaging\")def projectSiteUrl = properties.getProperty(\"project.siteUrl\")def projectGitUrl = properties.getProperty(\"project.gitUrl\")def developerId = properties.getProperty(\"developer.id\")def developerName = properties.getProperty(\"developer.name\")def developerEmail = properties.getProperty(\"developer.email\")def bintrayUser = properties.getProperty(\"bintray.user\")def bintrayApikey = properties.getProperty(\"bintray.apikey\")def javadocName = properties.getProperty(\"javadoc.name\")group = projectGroupId// This generates POM.xml with proper parametersinstall &#123; repositories.mavenInstaller &#123; pom &#123; project &#123; name projectName groupId projectGroupId artifactId projectArtifactId version projectVersionName packaging projectPackaging url projectSiteUrl licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; id developerId name developerName email developerEmail &#125; &#125; scm &#123; connection projectGitUrl developerConnection projectGitUrl url projectSiteUrl &#125; &#125; &#125;.writeTo(\"$buildDir/poms/pom-default.xml\").writeTo(\"pom.xml\") &#125;&#125;// This generates sources.jartask sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;// This generates javadoc.jartask javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;// javadoc configurationjavadoc &#123; options&#123; encoding \"UTF-8\" charSet 'UTF-8' author true version projectVersionName links \"http://docs.oracle.com/javase/7/docs/api\" title javadocName &#125;&#125;// bintray configurationbintray &#123; user = bintrayUser key = bintrayApikey configurations = ['archives'] pkg &#123; repo = projectBintrayRepo name = projectName websiteUrl = projectSiteUrl vcsUrl = projectGitUrl licenses = [\"Apache-2.0\"] publish = true &#125;&#125; 然后修改你的library module的build.gradle文件，在最后加上： 1apply from: \"bintrayUpload.gradle\" 3. 把library上传到你的bintray空间打开终端进入项目目录下，执行gradlew bintrayUpload命令即可 另外，如果你的本地已经配置了Gradle了，那么执行gradle bintrayUpload命令也可以。gradlew是Gradle的一层封装，如果你本地没有安装Gradle, gradlew就会自动下载Gradle。 在bintray的网页上检查一下你的package。你会发现在版本区域的变化。 点击进去，进入Files选项卡，你会看见那里有我们所上传的library文件。 恭喜，你的library终于放在了互联网上，任何人都可以使用了！ 不过也别高兴过头，library现在仍然只是在你自己的Maven仓库，而不是在JCenter上。如果有人想使用你的library，他必须定义仓库的url，如下： 1234567891011repositories &#123; maven &#123; url 'https://dl.bintray.com/sherlockshi/android-widgets/' &#125;&#125;...dependencies &#123; compile 'com.sherlockshi.widgets:aspectratioimageview:1.0.1'&#125; 你可以在bintray的web界面找到自己Maven仓库的url，或者直接吧nuuneoi替换成你的bintray用户名（因为前面部分其实都是一样的）。我还建议你直接访问那个链接，看看里面到底是什么。 但是，就如我们前面所讲的那样，让开发者去定义url这种复杂的事情并不是分享library的最佳方式。想象一下，使用10个library不得添加10个url？所以为了更好的体验，我们把library从自己的仓库传到JCenter上。 4. 同步bintray用户仓库到JCenter把library同步到JCenter非常容易，只需访问网页在package界面Linked To区域点击右下角的Add to JCenter，什么也不用填，直接点击Send。 现在我们所能做的就是等待bintray团队审核我们的请求，大概4-5个小时。一旦同步的请求审核通过，你会收到一封确认此更改的邮件。现在我们去网页上确认，你会在 Linked To 部分看到已链接到JCenter仓库。 5. 用法从此之后，任何开发者都可以使用JCenter() repository 外加一行gradle脚本来使用我们的library了 1compile 'com.sherlockshi.widget:aspectratioimageview:1.0.1' 想检查一下自己的library在JCenter上是否存在？你可以直接访问http://jcenter.bintray.com ，然后进入和你library的group id 以及artifact id匹配的目录。在本例中就是com -&gt; sherlockshi -&gt; widget -&gt; aspectratioimageview -&gt; 1.0.1。 请注意链接到JCenter是一个只需做一次的操作。如果你对你的package做了任何修改，比如上传了一个新版本的binary，删除了旧版本的binary等等，这些改变也会影响到JCenter。不过毕竟你自己的仓库和JCenter在不同的地方，所以需要等待2－3分钟让JCenter同步这些修改。 同时注意，如果你决定删除整个package，放在JCenter仓库上的library不会被删除。它们会像僵尸一样的存在，没有人再能删除它了。因此我建议，如果你想删除整个package，请在移除package之前先在网页上删除每一个版本。 恭喜！虽然需要许多步骤，但是每一步都很简单。而且大部分操作都是一劳永逸的。 期待能在上面看到你的library大作！ 六、踩坑经历1. 编译上传时，提示jar包未找到12:aspectratioimageview:bintrayUpload: file /Users/sherlock/work/workspace/AndroidStudio/AspectRatioImageView/aspectratioimageview/build/libs/aspectratioimageview-1.0.1-javadoc.jar could not be found.:aspectratioimageview:bintrayUpload: file /Users/sherlock/work/workspace/AndroidStudio/AspectRatioImageView/aspectratioimageview/build/libs/aspectratioimageview-1.0.1-sources.jar could not be found. 解决方法：先执行gradlew install，再执行gradlew bintrayUpload 七、参考如何使用Android Studio把自己的Android library分发到JCenter和Maven Central 5分钟发布Android Library项目到JCenter","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://sherlockshi.github.io/tags/Android-Studio/"},{"name":"library","slug":"library","permalink":"http://sherlockshi.github.io/tags/library/"},{"name":"JCenter","slug":"JCenter","permalink":"http://sherlockshi.github.io/tags/JCenter/"},{"name":"Maven","slug":"Maven","permalink":"http://sherlockshi.github.io/tags/Maven/"}]},{"title":"使用natapp进行微信本地开发调试","date":"2016-08-18T07:26:52.000Z","path":"2016/08/18/40_微信公众平台/使用natapp进行微信本地开发调试/","text":"一、在本地部署微信公众平台服务器在eclipse中使用tomcat部署微信公众平台程序 二、注册natapp 参考使用natapp超简单minecraft (我的世界) 映射开服,公网联机 1. 购买一条tcp型隧道,免费 付费均可. 2. 在后台-&gt;我的隧道 找到刚才那条购买的隧道,点击配置,输入如下配置 因tomcat默认使用的端口号是8080，所以此处的本地端口可用8080 配置好后,点击修改. 3. 下载natapp在natapp.cn下载相应版本的natapp.cn，并解压 4. 运行natapp1natapp -authtoken=ee3e7xxxxx 在Linux/Mac 下 需要先给执行权限 1chmod a+x natapp 然后再运行 1./natapp -authtoken=ee3e7xxxxx 运行成功,界面如下: 三、配置微信公众平台在微信公众平台注册公众号后，在基本配置界面，填写URL(格式为：上一步映射出来的外网IP/工程名/入口方法名)： 1tcp://ngrok.natapp.cn:33460/wechatsino/CoreServlet 点击保存即可（其余配置请参考微信公众平台进行配置） 四、调试此时，只要关注公众号后，发送消息或进行其它操作，微信公众平台就会把消息转发到上一步配置的URL对应的服务器，此处即为本地的工程，即可进行本地调试。","tags":[{"name":"微信公众平台","slug":"微信公众平台","permalink":"http://sherlockshi.github.io/tags/微信公众平台/"},{"name":"natapp","slug":"natapp","permalink":"http://sherlockshi.github.io/tags/natapp/"},{"name":"调试","slug":"调试","permalink":"http://sherlockshi.github.io/tags/调试/"}]},{"title":"Android Studio配置应用签名","date":"2016-07-30T00:17:34.000Z","path":"2016/07/30/15_Android/1505_安全/Android Studio配置应用签名/","text":"本文主要参考：在gradle中为release版本配置签名 任何一个Android APK 发布之前都会进行签名，没有签名的APK是无法在Android device上进行安装和使用的，而且对于发布到Google Play上的同一个应用，自始至终必须使用同一个签名文件，所以必须保存好签名文件。本文介绍如何在build.gradle中为release版本配置签名文件，这样在打包release版本时可以自动进行签名。 明文配置一般来说，我们直接在Android Studio中配置签名文件，是使用明文配置的，如： 1234567891011121314151617android &#123; signingConfigs &#123; release &#123; storeFile file(\"/Users/xxx/release_key.jks\") storePassword \"123456789\" keyAlias \"release_key_alias\" keyPassword \"987654321\" &#125; &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125; &#125;&#125; 注：此处的storeFile，如果是在Windows系统下，会是以下格式 1storeFile file(\"C\\:\\\\Users\\\\xxx\\\\release_key.jks\") 这样在打包release版本时就会自动签名了。 隐藏密码配置如果你的代码不会开源，或者是公司项目，公司会保护的很好，那么直接用上面的方式就可以了。但如果是开源项目，那么上面的写法就不太可取了 ，因为这样直接配置会暴露密码啊。接下来介绍如果隐藏密码进行配置： 利用property，将密码和签名文件路径信息保存在项目根目录的local.properties文件里，因为这个文件一般都在.gitignore里自动配置了，所以不会上传出去。 在根目录的local.properties文件中配置以下内容： 1234keystore.path=/Users/xxx/release_key.jkskeystore.password=123456789keystore.alias=release_key_aliaskeystore.alias_password=987654321 然后在你的app目录的build.gradle文件中增加以下代码： 123456789101112131415161718192021222324252627282930313233343536373839// =====配置keystore start=====def keystoreFilePath = ''def keystorePSW = ''def keystoreAlias = ''def keystoreAliasPSW = ''// default keystore file, PLZ config file path in local.propertiesdef keyfile = file('s.keystore.temp')Properties properties = new Properties()// local.properties file in the root directorproperties.load(project.rootProject.file('local.properties').newDataInputStream())keystoreFilePath = properties.getProperty(\"keystore.path\")if (keystoreFilePath) &#123; keystorePSW = properties.getProperty(\"keystore.password\") keystoreAlias = properties.getProperty(\"keystore.alias\") keystoreAliasPSW = properties.getProperty(\"keystore.alias_password\") keyfile = file(keystoreFilePath)&#125;// =====配置keystore end=====android &#123; signingConfigs &#123; release &#123; storeFile keyfile storePassword keystorePSW keyAlias keystoreAlias keyPassword keystoreAliasPSW &#125; &#125; buildTypes &#123; release &#123; if (keyfile.exists()) &#123; signingConfig signingConfigs.release &#125; &#125; &#125;&#125; 这样就达到了隐藏的目的。","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"签名","slug":"签名","permalink":"http://sherlockshi.github.io/tags/签名/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://sherlockshi.github.io/tags/Android-Studio/"}]},{"title":"Android ScrollView无法match_parent的问题","date":"2016-07-28T08:22:06.000Z","path":"2016/07/28/15_Android/1590_Others/Android ScrollView无法match_parent的问题/","text":"一、问题Android ScrollView无法match_parent的问题 二、解决办法在ScrollView的属性里加上： 1234&lt;ScrollView ... android:fillViewport=\"true\" &gt;&lt;/ScrollView&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"ScrollView","slug":"ScrollView","permalink":"http://sherlockshi.github.io/tags/ScrollView/"},{"name":"match_parent","slug":"match-parent","permalink":"http://sherlockshi.github.io/tags/match-parent/"}]},{"title":"Android Studio常见问题","date":"2016-07-24T15:12:43.000Z","path":"2016/07/24/15_Android/1530_开发工具/AndroidStudio/Android Studio常见问题/","text":"Android Studio使用建议：将SDK Manager里面的相关工具提前下载下来，并定期更新 Tools目录：全部下载（包括SDK Tools、SDK Platform-tools、SDK Build-tools） 各个版本的Android SDK：按需下载，一般下载SDK Platform、Documentation、APIs、Sources Extras目录：Android Support Repository、Android Support Library、Google Repository 1. Gradle版本问题12345678910111213Error:A problem occurred configuring root project 'XylqPda'.&gt; Could not resolve all dependencies for configuration ':classpath'. &gt; Could not resolve com.android.tools.build:gradle:2.0.0. Required by: :XylqPda:unspecified &gt; Could not resolve com.android.tools.build:gradle:2.0.0. &gt; Could not get resource 'https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; Could not GET 'https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; peer not authenticated &gt; Could not resolve com.android.tools.build:gradle:2.0.0. &gt; Could not get resource 'https://jcenter.bintray.com/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; Could not GET 'https://jcenter.bintray.com/com/android/tools/build/gradle/2.0.0/gradle-2.0.0.pom'. &gt; peer not authenticated 原因分析 一般为Android Studio版本号和Gradle版本号不一致导致。 解决方法 将项目根目录下的build.gradle中dependencies内的 1classpath 'com.android.tools.build:gradle:2.1.2' 版本号设为跟Android Studio版本号一致。 2. 下载Build-tools失败12Error:failed to find Build Tools revision 24.0.1Install Build Tools 24.0.1 and sync project http://blog.csdn.net/barryhappy/article/details/44813951 3. 更新 Gradle 错误停止在Refreshing Gradle Project ,有时新建项目的时候报 Gradle Project Compile Error 等等相关的问题http://www.cnblogs.com/neozhu/p/3525404.html","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://sherlockshi.github.io/tags/Android-Studio/"},{"name":"开发工具","slug":"开发工具","permalink":"http://sherlockshi.github.io/tags/开发工具/"},{"name":"常见问题","slug":"常见问题","permalink":"http://sherlockshi.github.io/tags/常见问题/"}]},{"title":"Gradle基础","date":"2016-07-24T14:53:35.000Z","path":"2016/07/24/15_Android/1530_开发工具/AndroidStudio/Gradle基础/","text":"一、什么是Gradle？Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的领域专用（DSL）语言。 二、安装Gradle在Android Studio中新建项目成功后会下载Gradle，貌似这个过程不翻墙也是可以下载，但是访问特别慢，建议翻墙下载。那么下载的Gradle到什么地方呢？ Mac上会默认下载到 /Users/&lt;用户名&gt;/.gradle/wrapper/dists 目录Win平台会默认下载到 C:\\Users\\&lt;用户名&gt;\\.gradle\\wrapper\\dists 目录 你会看到这个目录下有个 gradle-x.xx-all 的文件夹, 如果下载实在太慢，但是又不想翻墙的话，可以自己手动到Gradle官网、或者jcenter里下载对应的版本，然后将下载的.zip文件复制到上述的gradle-x.xx-all 文件夹下，不过还是建议让它直接下载的好。 三、项目中的 Gradle 相关目录和文件1. app/build.gradle这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 声明是Android程序apply plugin: 'com.android.application'android &#123; // 编译SDK的版本 compileSdkVersion 21 // build tools的版本 buildToolsVersion \"21.1.1\" defaultConfig &#123; // 应用的包名 applicationId \"me.storm.ninegag\" minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName \"1.0.0\" &#125; // java版本 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 &#125; buildTypes &#123; debug &#123; // debug模式 &#125; release &#123; // 是否进行混淆 minifyEnabled false // 混淆文件的位置 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125; // 移除lint检查的error lintOptions &#123; abortOnError false &#125;&#125;dependencies &#123; // 编译libs目录下的所有jar包 compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:support-v4:21.0.2' compile 'com.etsy.android.grid:library:1.0.5' compile 'com.alexvasilkov:foldable-layout:1.0.1' // 编译extras目录下的ShimmerAndroid模块 compile project(':extras:ShimmerAndroid')&#125; 2. gradle/这个目录下有个 wrapper 文件夹，里面可以看到有两个文件，我们主要看下 gradle-wrapper.properties 这个文件的内容： 123456#Mon Dec 28 10:00:20 PST 2015distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip 可以看到里面声明了gradle的目录与下载路径以及当前项目使用的gradle版本，这些默认的路径我们一般不会更改的，这个文件里指明的gradle版本不对也是很多导包不成功的原因之一。 3. build.gradle这个文件是整个项目的gradle基础配置文件 12345678910111213141516// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.0.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 内容主要包含了两个方面： 一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。 另一个是声明了android gradle plugin的版本，android studio 1.0正式版必须要求支持gradle plugin 1.0的版本。 4. settings.gradle这个文件是全局的项目配置文件，里面主要声明一些需要加入gradle的module 1include ':app' 四、Android Studio中几个关于Gradle的不同概念1. Gradle、Gradle Plugin：Gradle 是新一代的自动化构建工具，它是一个独立的项目，跟 AS、Android 无关，但是 Gradle 官方还是很看重 Android 开发的，Google 在推出 AS 的时候选中了 Gradle 作为构建工具，为了支持 Gradle 能在 AS 上使用，Google 做了个 AS 的插件叫 Android Gradle Plugin ，所以我们能在 AS 上使用 Gradle 完全是因为这个插件的原因。在项目的根目录有个 build.gradle 文件，里面有这么一句代码： 1classpath 'com.android.tools.build:gradle:2.1.2' 这个就是依赖 gradle 插件的代码，后面的版本号代表的是 android gradle plugin 的版本，而不是 Gradle 的版本，这个是 Google 定的，跟 Gradle 官方没关系。 2. Gradle Wrapper字面意思是Gradle的包装器，主要是这样的应用场景：假设我们本地有多个项目，一个是比较老的项目，还用着 Gradle 1.0 的版本，一个是比较新的项目用了 Gradle 2.0 的版本，但是你两个项目肯定都想要同时运行的，如果你只装了 Gradle 1.0 的话那肯定不行，所以为了解决这个问题，Google 推出了 Gradle Wrapper 的概念，就是他在你每个项目都配置了一个指定版本的 Gradle ，你可以理解为每个 Android 项目本地都有一个小型的 Gradle ，通过这个每个项目你可以支持用不同的 Gradle 版本来构建项目。 五、推荐阅读给 Android 初学者的 Gradle 知识普及Android 开发你需要了解的 Gradle 配置","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://sherlockshi.github.io/tags/Android-Studio/"},{"name":"开发工具","slug":"开发工具","permalink":"http://sherlockshi.github.io/tags/开发工具/"},{"name":"Gradle","slug":"Gradle","permalink":"http://sherlockshi.github.io/tags/Gradle/"}]},{"title":"Android代码混淆问题汇总","date":"2016-07-21T06:20:34.000Z","path":"2016/07/21/15_Android/1505_安全/Android代码混淆问题汇总/","text":"一、问题1Android studio打包中遇到了这样的问题： 1Warning:Exception while processing task java.io.IOException: The same input jar […….jar] is specified twice. 解决办法打开proguard-rules.pro，注释掉所有的-libraryjars行，或者直接删除，如： 1#-libraryjars xxxx.jar 原因分析build.gradle文件配置了 123dependencies &#123; compile fileTree(include: '*.jar', dir: 'libs')&#125; 里面已经添加过jar包，sdk 通过 proguard 混淆代码时默认已经将 lib目录中的 jar 都已经添加到打包脚本中，所以不需要再次手动添加。 二、问题212345678910Warning:com.baidu.platform.comapi.map.f: can't find referenced method 'float sqrt(float)' in library class android.util.FloatMathWarning:okio.DeflaterSink: can't find referenced class org.codehaus.mojo.animal_sniffer.IgnoreJRERequirementWarning:okio.Okio: can't find referenced class java.nio.file.FilesWarning:okio.Okio: can't find referenced class java.nio.file.PathWarning:okio.Okio: can't find referenced class java.nio.file.OpenOptionWarning:Exception while processing task java.io.IOException: Please correct the above warnings first.:app:transformClassesAndResourcesWithProguardForRelease FAILEDError:Execution failed for task ':app:transformClassesAndResourcesWithProguardForRelease'.&gt; java.io.IOException: Please correct the above warnings first.","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"安全","slug":"安全","permalink":"http://sherlockshi.github.io/tags/安全/"},{"name":"代码混淆","slug":"代码混淆","permalink":"http://sherlockshi.github.io/tags/代码混淆/"}]},{"title":"HttpURLConnection用法","date":"2016-07-19T12:36:45.000Z","path":"2016/07/19/15_Android/1525_网络/HttpURLConnection用法/","text":"原文链接：http://www.blogjava.net/supercrsky/articles/247449.htmlhttp://blog.csdn.net/woxueliuyun/article/details/43267365 任何网络连接都需要经过socket才能连接，HttpURLConnection不需要设置socket，所以，HttpURLConnection并不是底层的连接，而是在底层连接上的一个请求。这就是为什么HttpURLConneciton只是一个抽象类，自身不能被实例化的原因。HttpURLConnection只能通过URL.openConnection()方法创建具体的实例。 虽然底层的网络连接可以被多个HttpURLConnection实例共享，但每一个HttpURLConnection实例只能发送一个请求。请求结束之后，应该调用HttpURLConnection实例的InputStream或OutputStream的close()方法以释放请求的网络资源，不过这种方式对于持久化连接没用。对于持久化连接，得用disconnect()方法关闭底层连接的socket。 一、创建HttpURLConnection12345678910URL url = new URL(\"http://localhost:8080/xxx.do\"); URLConnection rulConnection = url.openConnection();// 此处的urlConnection对象实际上是根据URL的 // 请求协议(此处是http)生成的URLConnection类 // 的子类HttpURLConnection,故此处最好将其转化 // 为HttpURLConnection类型的对象,以便用到 // HttpURLConnection更多的API.如下: HttpURLConnection httpUrlConnection = (HttpURLConnection) rulConnection; 二、设置HttpURLConnection参数 若为Get请求，不用设置下述参数，只需要最后一步的connect()即可 12345678910111213141516171819// 设定请求的方法为\"POST\"，默认是GET httpUrlConnection.setRequestMethod(\"POST\"); // 设置是否向httpUrlConnection输出，因为这个是post请求，参数要放在 // http正文内，因此需要设为true, 默认情况下是false; httpUrlConnection.setDoOutput(true); // 设置是否从httpUrlConnection读入，默认情况下是true; httpUrlConnection.setDoInput(true); // Post 请求不能使用缓存 httpUrlConnection.setUseCaches(false); // 设定传送的内容类型是可序列化的java对象 // (如果不设此项,在传送序列化对象时,当WEB服务默认的不是这种类型时可能抛java.io.EOFException) httpUrlConnection.setRequestProperty(\"Content-type\", \"application/x-java-serialized-object\"); // 连接，从上述url.openConnection()至此的配置必须要在connect之前完成， httpUrlConnection.connect(); 三、URLConnection建立连接1234// 此处getOutputStream会隐含的进行connect(即：如同调用上面的connect()方法， // 所以在开发中不调用上述的connect()也可以)。 OutputStream outStrm = httpUrlConnection.getOutputStream();//getInputStream()也是同理。 四、HttpURLConnection发送请求123456789101112// 现在通过输出流对象构建对象输出流对象，以实现输出可序列化的对象。 ObjectOutputStream objOutputStrm = new ObjectOutputStream(outStrm); // 向对象输出流写出数据，这些数据将存到内存缓冲区中 objOutputStrm.writeObject(new String(\"我是测试数据\")); // 刷新对象输出流，将任何字节都写入潜在的流中（些处为ObjectOutputStream） objOutputStm.flush(); // 关闭流对象。此时，不能再向对象输出流写入任何数据，先前写入的数据存在于内存缓冲区中, // 在调用下边的getInputStream()函数时才把准备好的http请求正式发送到服务器 objOutputStm.close(); 五、HttpURLConneciton获取响应12// 调用HttpURLConnection连接对象的getInputStream()函数InputStream inStrm = httpConn.getInputStream(); 六、设置POST参数1234567OutputStream os = httpConn.getOutputStream(); String param = new String(); param = \"CorpID=\" + CorpID + \"&amp;LoginName=\" + LoginName+ \"&amp;send_no=\" + phoneNumber + \"&amp;msg=\" + java.net.URLEncoder.encode(msg,\"GBK\"); ; os.write(param.getBytes()); 超时设置，防止网络异常的情况下，可能会导致程序僵死而不继续往下执行12System.setProperty(\"sun.net.client.defaultConnectTimeout\", \"30000\");System.setProperty(\"sun.net.client.defaultReadTimeout\", \"30000\"); 其中：sun.net.client.defaultConnectTimeout：连接主机的超时时间（单位：毫秒）sun.net.client.defaultReadTimeout：从主机读取数据的超时时间（单位：毫秒） JDK 1.5以前的版本，只能通过设置这两个系统属性来控制网络超时。在1.5中，还可以使用HttpURLConnection的父类URLConnection的以下两个方法： setConnectTimeout：设置连接主机超时（单位：毫秒）setReadTimeout：设置从主机读取数据超时（单位：毫秒） 123HttpURLConnection urlCon = (HttpURLConnection)url.openConnection(); urlCon.setConnectTimeout(30000); urlCon.setReadTimeout(30000);","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"网络","slug":"网络","permalink":"http://sherlockshi.github.io/tags/网络/"},{"name":"HttpURLConnection","slug":"HttpURLConnection","permalink":"http://sherlockshi.github.io/tags/HttpURLConnection/"}]},{"title":"Android Studio入门教程","date":"2016-07-13T07:53:01.000Z","path":"2016/07/13/15_Android/1530_开发工具/AndroidStudio/Android Studio入门教程/","text":"一、前言在Android Studio出现之前，开发Android应用主要是使用Eclipse ADT，也就是说，虽然那时候Android系统已经安装在9亿台设备上，但是没有一个专门的开发环境供Android开发者来开发Android应用。直到2013年的Google I/O大会，Google发布了Android Studio 0.1版本，我们才有了像iOS开发者的XCode一样的官方IDE。 2013年5月发布早期预览版本，版本号为0.1。2014年6月发布0.8版本，至此进入beta阶段。第一个稳定版本1.0于2014年12月8日发布，之后还有好多版本，比较稳定有的1.5正式版，2.0正式版，以及现在最新的2.1版本。 早期版本的Android Studio非常的难用，内存消耗非常严重，各种Bug，只有后面的1.5版本以后的版本才比较好，现在的2.0版本已经很好了。 二、下载、安装Android开发者官方网站(需翻墙)Android开发工具网站(需翻墙)中文社区 配置建议：内存8G+JDK8 三、配置 JDK 环境变量：JAVA_HOME、PATH、CLASSPATH Windows系统设置方法 Mac系统设置方法 测试是否安装成功： java，javac，java -version 四、项目介绍在新建一个项目之前，这里先普及Android Studio和eclipse在某些概念不同的地方。 Android Studio 中，有一些概念是和 eclipse 不同的，从 eclipse 迁移至 Android Studio 会有很多上手不顺的情况发生，当然在明确了概念的不同之后，还是容易可以切换过来。 对比 eclipse Android Studio 工作区 workspace project 项目 project module 引用 preference module dependency 简单的来说，Android Stduio把一个项目比喻成一个工程的一个个模块，外部的依赖也是一个个模块，这样一个项目的结构就很清晰明了。当然也有一个缺点，就是一个窗口只能打开一个project，不能像eclipse那样一次一个窗口打开多个项目。 1. 新建项目两个方式： Android Studio欢迎界面时： start a new Android Studio project Android Studio已有打开的项目时： File -&gt; New -&gt; New Project... 2. 模拟器＝＝＝＝＝＝＝＝建议使用真机＝＝＝＝＝＝＝＝ 自带的Genymotion3. 目录结构目录展现模式：Project、Android app/ libs/： 右击jar包，Add as library main src/ res/ AndroidManifest.xml proguard-rules.pro：混淆文件 这里还有一些关于Gradle的配置文件还没有介绍，统一在下一节进行介绍。 五、Gradle介绍详见Gradle基础 六、插件 gson format android-butterknife-zelezny Android Postfix Completion ECTranslation .gitignore Android开发工具 七、常用快捷键Preferences -&gt; KeymapHelp -&gt; Default Keymap Reference 1. 常用 Action Mac OSX Win/Linux Search everywhere Double Shift Double Shift 注释代码(//) Cmd + / Ctrl + / 注释代码(/**/) Cmd + Option + / Ctrl + Shift + / 格式化代码 Cmd + Option + L Ctrl + Alt + L 清除无效包引用 Option + Control + O Alt + Ctrl + O 查找 Cmd + F Ctrl + F 查找+替换 Cmd + R Ctrl + R 上下移动代码 Option + Shift + Up/Down Alt + Shift + Up/Down 删除行 Cmd + Delete Ctrl + Y 复制行 Cmd + D Ctrl + D 重命名 Shift+F6 Shift+F6 重构 Cmd + Option + M Shift+F6 扩大缩小选中范围 Option + Up/Down Ctrl + W/Ctrl + Shift + W 快捷生成结构体 Cmd + Option + T Ctrl + Alt + T 快捷覆写方法 Cmd + O Ctrl + O 快捷定位到行首/尾 Cmd + Left/Right Ctrl + Left/Right 折叠展开代码块 Cmd + Plus,Minus Ctrl + Plus/Minus 折叠展开全部代码块 Cmd + Shift + Plus,Minus Ctrl + Shift + Plus,Minus 文件方法结构 Cmd + F12 Ctrl + F12 查找调用的位置 Ctrl + Option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U 2. 自动导包我们只有每次引用一些类的时候必须要导包，而Android Studio可以通过设置自动导包，简直太实用了. 到 Preferences -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Java 把以下选项勾上就OK了 八、常见问题详见Android Studio常见问题 九、学习资料stormzhang的Android Studio详细教程汇总Gradle中文教程Android Studio视频教程Gradle教程 十、翻墙软件1. 免费XX-Net蓝灯 2. 付费Shadowsocks云梯VPN","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://sherlockshi.github.io/tags/Android-Studio/"},{"name":"开发工具","slug":"开发工具","permalink":"http://sherlockshi.github.io/tags/开发工具/"},{"name":"教程","slug":"教程","permalink":"http://sherlockshi.github.io/tags/教程/"}]},{"title":"Andrdoid代码混淆","date":"2016-07-01T01:12:46.000Z","path":"2016/07/01/15_Android/1505_安全/Andrdoid代码混淆/","text":"本文主要参考5分钟搞定android混淆 一、前言 二、上模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#-------------------------------------------定制化区域----------------------------------------------#---------------------------------1.实体类、自定义控件------------------------keep class com.sherlockshi.core.model.entity.** &#123; *; &#125; #实体类不参与混淆-keep class com.sherlockshi.core.ui.custom.** &#123; *; &#125; #自定义控件不参与混淆#-------------------------------------------------------------------------#---------------------------------2.第三方包-------------------------------#-------------------------------------------------------------------------#---------------------------------3.与js互相调用的类------------------------#-------------------------------------------------------------------------#---------------------------------4.反射相关的类和方法-----------------------#----------------------------------------------------------------------------#---------------------------------------------------------------------------------------------------#-------------------------------------------基本不用动区域--------------------------------------------#---------------------------------基本指令区-----------------------------------optimizationpasses 5-dontskipnonpubliclibraryclassmembers-printmapping proguardMapping.txt-optimizations !code/simplification/cast,!field/*,!class/merging/*-keepattributes *Annotation*,InnerClasses-keepattributes Signature-keepattributes SourceFile,LineNumberTable#----------------------------------------------------------------------------#---------------------------------默认保留区----------------------------------keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService-keep class android.support.** &#123;*;&#125;-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;-keep class **.R$* &#123; *;&#125;-keepclassmembers class * &#123; void *(**On*Event);&#125;#----------------------------------------------------------------------------#---------------------------------webview-------------------------------------keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;#----------------------------------------------------------------------------#--------------------------------------------------------------------------------------------------- 三、分析1. 实体类、自定义控件实体类由于涉及到与服务端的交互，各种gson的交互如此等等，是要保留的，自定义控件也是一样。将你项目中实体类都拎出来，用以下语法进行保留。 12-keep class 你的实体类所在的包.** &#123; *; &#125;-keep class 你的自定义控件所在的包.** &#123; *; &#125; 如我的项目下类User的完整路径为：com.demo.login.bean.User, 那我的混淆如下123456#---------------------------------1.实体类、自定义控件------------------------keep class com.demo.login.bean.** &#123; *; &#125; #实体类不参与混淆-keep class com.demo.android.view.** &#123; *; &#125; #自定义控件不参与混淆#------------------------------------------------------------------------- 当然你的实体类、自定义控件肯定不止这一个，请用上边的方式一一添加，如果你的实体类、自定义控件都在一个包下，那你就幸福了。 2. 第三方包打开你app下的build.gradle文件，查看你用了哪些第三方的包。 1234dependencies &#123; compile 'com.github.bumptech.glide:glide:3.7.0' compile 'org.greenrobot:eventbus:3.0.0'&#125; 我这里用了glide，eventbus。我去他们的官网把已经写好的混淆copy下来。 1234567891011121314151617181920#---------------------------------2.第三方包-------------------------------#eventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;#glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;#------------------------------------------------------------------------- 一般官网都是有混淆的，没有的话就google，也没有的话自己按照上面的写法自己写，还不会的话。。。。。只能换个包。。。。。如果你是直接包含的jar包的话，你这样写 12345678#---------------------------------2.第三方包-------------------------------#log4j-libraryjars log4j-1.2.17.jar-dontwarn org.apache.log4j.**-keep class org.apache.log4j.** &#123; *;&#125;#------------------------------------------------------------------------- 大致意思就是不混淆，不报warn。如果gradle报错的话，可以考虑注释掉-libraryjars log4j-1.2.17.jar这句。 3. 与js互相调用的类工程中没有直接跳过，一般你可以这样写 1-keep class 你的类所在的包.** &#123; *; &#125; 如果是内部类的话，你可以这样1-keepclasseswithmembers class 你的类所在的包.父类$子类 &#123; &lt;methods&gt;; &#125; 例如123-keepclasseswithmembers class com.demo.login.bean.ui.MainActivity$JSInterface &#123; &lt;methods&gt;;&#125; 4. 反射相关的类和方法工程中没有直接跳过，类的话直接这样1-keep class 你的类所在的包.** &#123; *; &#125; 四、深入了解先逐条介绍下基本指令区指令的含义 代码混淆的压缩比例，值在0-7之间：1-optimizationpasses 5 混淆后类名都为小写：1-dontusemixedcaseclassnames 指定不去忽略非公共的库的类：1-dontskipnonpubliclibraryclasses 指定不去忽略非公共的库的类的成员：1-dontskipnonpubliclibraryclassmembers 不做预校验的操作：1-dontpreverify 生成原类名和混淆后的类名的映射文件：12-verbose-printmapping proguardMapping.txt 指定混淆是采用的算法：1-optimizations !code/simplification/cast,!field/*,!class/merging/* 不混淆Annotation：1-keepattributes *Annotation*,InnerClasses 不混淆泛型：1-keepattributes Signature 抛出异常时保留代码行号：1-keepattributes SourceFile,LineNumberTable 基本指令区基本介绍完了，说下2条用的最多的指令： 保留类名不变，也就是类名不混淆，而类中的成员名不保证。当然也可以是继承XXX类的所有类名不混淆，具体代码不贴了，重在理解。 1-keep class XXXX 保留类名和成员名。当然也可以是类中特定方法，代码不贴了，理由同上。 1-keepclasseswithmembers class XXXX 五、附：完整的混淆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#-------------------------------------------定制化区域----------------------------------------------#---------------------------------1.实体类----------------------------------keep class com.demo.login.bean.** &#123; *; &#125;-keep class com.demo.main.bean.** &#123; *; &#125;#-------------------------------------------------------------------------#---------------------------------2.第三方包-------------------------------#eventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;#glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;#log4j-libraryjars log4j-1.2.17.jar-dontwarn org.apache.log4j.**-keep class org.apache.log4j.** &#123; *;&#125;#-------------------------------------------------------------------------#---------------------------------3.与js互相调用的类-------------------------keepclasseswithmembers class com.demo.login.bean.ui.MainActivity$JSInterface &#123; &lt;methods&gt;;&#125;#-------------------------------------------------------------------------#---------------------------------4.反射相关的类和方法-----------------------#TODO 我的工程里没有。。。#----------------------------------------------------------------------------#---------------------------------------------------------------------------------------------------#-------------------------------------------基本不用动区域--------------------------------------------#---------------------------------基本指令区-----------------------------------optimizationpasses 5-dontusemixedcaseclassnames-dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers-dontpreverify-verbose-printmapping proguardMapping.txt-optimizations !code/simplification/cast,!field/*,!class/merging/*-keepattributes *Annotation*,InnerClasses-keepattributes Signature-keepattributes SourceFile,LineNumberTable#----------------------------------------------------------------------------#---------------------------------默认保留区----------------------------------keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService-keep class android.support.** &#123;*;&#125;-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;-keep class **.R$* &#123; *;&#125;-keepclassmembers class * &#123; void *(**On*Event);&#125;#----------------------------------------------------------------------------#---------------------------------webview-------------------------------------keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;#----------------------------------------------------------------------------#--------------------------------------------------------------------------------------------------- 六、后言将app下的build.gradle中minifyEnabled设置为true打个包试试吧 1234release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"安全","slug":"安全","permalink":"http://sherlockshi.github.io/tags/安全/"},{"name":"代码混淆","slug":"代码混淆","permalink":"http://sherlockshi.github.io/tags/代码混淆/"}]},{"title":"Android里Button只显示大写字母的问题","date":"2016-06-27T03:01:37.000Z","path":"2016/06/27/15_Android/1590_Others/Android里Button只显示大写字母的问题/","text":"一、问题在XML布局文件里面直接给Button设置英文text时，会出现text内容全部变成大写，如设置text为Take(Small)Picture，但实际显示为TAKE(SMALL)PICTURE 二、解决办法在Button的属性里加上： 123&lt;Button ... android:textAllCaps=\"false\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"Button","slug":"Button","permalink":"http://sherlockshi.github.io/tags/Button/"},{"name":"大写","slug":"大写","permalink":"http://sherlockshi.github.io/tags/大写/"}]},{"title":"Android官方相机教程：简单的相机应用和自定义相机","date":"2016-06-27T02:41:40.000Z","path":"2016/06/27/15_Android/1520_相机/Android官方相机教程：简单的相机应用和自定义相机/","text":"本文基于Android相机官方教程及极客学院Wiki整理 轻松拍摄照片这节课将讲解如何使用已有的相机应用拍摄照片。 1. 请求使用相机权限如果拍照是应用的必要功能，那么应该令它在Google Play中仅对有相机的设备可见。为了让用户知道我们的应用需要依赖相机，在Manifest清单文件中添加标签: 12345&lt;manifest ... &gt; &lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"true\" /&gt; ...&lt;/manifest&gt; 如果我们的应用使用相机，但相机并不是应用的正常运行所必不可少的组件，可以将android:required设置为”false”。这样的话，Google Play 也会允许没有相机的设备下载该应用。当然我们有必要在使用相机之前通过调用hasSystemFeature(PackageManager.FEATURE_CAMERA)方法来检查设备上是否有相机。如果没有，我们应该禁用和相机相关的功能！ 2. 使用相机应用程序进行拍照利用一个描述了执行目的Intent对象，Android可以将某些执行任务委托给其他应用。整个过程包含三部分： Intent 本身，一个函数调用来启动外部的 Activity，当焦点返回到我们的Activity时，处理返回图像数据的代码。 下面的函数通过发送一个Intent来捕获照片： 12345678910static final int REQUEST_IMAGE_CAPTURE = 1;private void dispatchTakePictureIntent() &#123; if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)) &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE); &#125; &#125;&#125; 注意在调用startActivityForResult()方法之前，先调用resolveActivity()，这个方法会返回能处理该Intent的第一个Activity（译注：即检查有没有能处理这个Intent的Activity）。执行这个检查非常重要，因为如果在调用startActivityForResult()时，没有应用能处理你的Intent，应用将会崩溃。所以只要返回结果不为null，使用该Intent就是安全的。 3. 获取缩略图拍摄照片并不是应用的最终目的，我们还想要从相机应用那里取回拍摄的照片，并对它执行某些操作。 Android的相机应用会把拍好的照片编码为缩小的Bitmap，使用extra value的方式添加到返回的Intent当中，并传送给onActivityResult()，对应的Key为”data”。下面的代码展示的是如何获取这一图片并显示在ImageView上。 12345678@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get(\"data\"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; Note: 这张从”data”中取出的缩略图适用于作为图标，但其他作用会比较有限。而处理一张全尺寸图片需要做更多的工作。 4. 保存全尺寸照片如果我们提供了一个File对象给Android的相机程序，它会保存这张全尺寸照片到给定的路径下。另外，我们必须提供存储图片所需要的含有后缀名形式的文件名。 一般而言，用户使用设备相机所拍摄的任何照片都应该被存放在设备的公共外部存储中，这样它们就能被所有的应用访问。将DIRECTORY_PICTURES作为参数，传递给getExternalStoragePublicDirectory()方法，可以返回适用于存储公共图片的目录。由于该方法提供的目录被所有应用共享，因此对该目录进行读写操作分别需要READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限。另外，因为写权限隐含了读权限，所以如果需要外部存储的写权限，那么仅仅需要请求一项权限就可以了： 1234&lt;manifest ...&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; ...&lt;/manifest&gt; 然而，如果希望照片对我们的应用而言是私有的，那么可以使用getExternalFilesDir()提供的目录。在Android 4.3及以下版本的系统中，写这个目录需要WRITE_EXTERNAL_STORAGE权限。从Android 4.4开始，该目录将无法被其他应用访问，所以该权限就不再需要了，你可以通过添加maxSdkVersion属性，声明只在低版本的Android设备上请求这个权限。 12345&lt;manifest ...&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" android:maxSdkVersion=\"18\" /&gt; ...&lt;/manifest&gt; 所有存储在getExternalFilesDir()提供的目录中的文件会在用户卸载你的app后被删除。 一旦选定了存储文件的目录，我们还需要设计一个保证文件名不会冲突的命名规则。当然我们还可以将路径存储在一个成员变量里以备在将来使用。下面的例子使用日期时间戳作为新照片的文件名： 123456789101112131415161718String mCurrentPhotoPath;private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date()); String imageFileName = \"JPEG_\" + timeStamp + \"_\"; File storageDir = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, /* prefix */ \".jpg\", /* suffix */ storageDir /* directory */ ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = \"file:\" + image.getAbsolutePath(); return image;&#125; 有了上面的方法，我们就可以给新照片创建文件对象了，现在我们可以像这样创建并触发一个Intent： 12345678910111213141516171819202122static final int REQUEST_TAKE_PHOTO = 1;private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // Ensure that there's a camera activity to handle the intent if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File ... &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(photoFile)); startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO); &#125; &#125;&#125; 5. 将照片添加到相册中由于我们通过Intent创建了一张照片，因此图片的存储位置我们是知道的。对其他人来说，也许查看我们的照片最简单的方式是通过系统的Media Provider。 Note: 如果将图片存储在getExternalFilesDir()提供的目录中，Media Scanner将无法访问到我们的文件，因为它们隶属于应用的私有数据。 下面的例子演示了如何触发系统的Media Scanner，将我们的照片添加到Media Provider的数据库中，这样就可以使得Android相册程序与其他程序能够读取到这些照片。 1234567private void galleryAddPic() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); this.sendBroadcast(mediaScanIntent);&#125; 6. 解码一幅缩放图片在有限的内存下，管理许多全尺寸的图片会很棘手。如果发现应用在展示了少量图片后消耗了所有内存，我们可以通过缩放图片到目标视图尺寸，之后再载入到内存中的方法，来显著降低内存的使用，下面的例子演示了这个技术： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void setPic() &#123; // Get the dimensions of the View int targetW = mImageView.getWidth(); int targetH = mImageView.getHeight(); // Get the dimensions of the bitmap BitmapFactory.Options bmOptions = new BitmapFactory.Options(); bmOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); int photoW = bmOptions.outWidth; int photoH = bmOptions.outHeight; // Decode the image file into a Bitmap sized to fill the View bmOptions.inJustDecodeBounds = false; bmOptions.inSampleSize = calculateInSampleSize(bmOptions, targetW, targetH); bmOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); mImageView.setImageBitmap(bitmap);&#125;public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; // Calculate ratios of height and width to requested height and // width final int heightRatio = Math.round((float) height / (float) reqHeight); final int widthRatio = Math.round((float) width / (float) reqWidth); // Choose the smallest ratio as inSampleSize value, this will // guarantee // a final image with both dimensions larger than or equal to the // requested height and width. inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio; &#125; return inSampleSize;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://sherlockshi.github.io/tags/Android/"},{"name":"相机","slug":"相机","permalink":"http://sherlockshi.github.io/tags/相机/"}]},{"title":"使用Hexo搭建个人博客过程的各种问题","date":"2016-06-23T13:47:09.000Z","path":"2016/06/23/30_博客/3005_Hexo/使用Hexo搭建个人博客过程的各种问题/","text":"一、问题1Q: hexo server后访问浏览器 http://0.0.0.0:4000/ 出现 cannot get A: 依次执行如下命令就行： 123456789npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --savenpm install hexo-cli -ghexo init blogcd blognpm installhexo server 二、问题2Q: npm install时报错： A: 执行如下命令： 1sudo npm install 三、问题3Q: 社会化评论多说duoshuo_shortname在哪看？ A: 到多说官网创建站点(站点为xxx.github.io)，之后就会得到short_name。 四、问题4Q: 如何设置分类和标签？ A: 在文章的开始位置进行如下设置： 12345678---title: 使用Hexo搭建个人博客过程的各种问题categories: - Hexotags: - Hexo - 问题--- 五、问题5Q: 首页的文章目录，怎么设置显示部分摘要和read more? A: 在文章中加一行如下的标记，在这个标记之前的就是摘要 1&lt;!--more--&gt; 六、问题6Q: 运行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d命令后报错：1ERROR Deployer not found: git A: 执行以下命令，安装hexo-deployer-git自动部署发布工具：1npm install hexo-deployer-git --save","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://sherlockshi.github.io/tags/Hexo/"},{"name":"问题","slug":"问题","permalink":"http://sherlockshi.github.io/tags/问题/"}]},{"title":"Markdown语言常用语法","date":"2016-04-28T13:34:01.000Z","path":"2016/04/28/10_Markdown/Markdown语言常用语法/","text":"本文主要记录Markdown语言的常用语法，做为备忘，本文内容主要参考：https://segmentfault.com/markdown 一、代码1. 行内代码用法 把代码用反引号 ` (键盘上Esc键下面的键)包起，如： `toString()`方法 效果 toString()方法 2. 代码块用法1 用 3个`(Esc下面的键)包裹一段代码，并指定一种语言，如： 12345```java public class BookViewHolder extends RecyclerView.ViewHolder &#123; public TextView tvBook; &#125; ``` 用法2 也可以在代码块的每一行使用 4 空格缩进，实现相同的的效果，此处不再举例，可自己尝试。 效果 123public class BookViewHolder extends RecyclerView.ViewHolder &#123; public TextView tvBook;&#125; 支持的语言：actionscript, apache, bash, clojure, cmake, coffeescript, cpp, cs, css, d, delphi, django, erlang, go, haskell, html, http, ini, java, javascript, json, lisp, lua, markdown, matlab, nginx, objectivec, perl, php, python, r, ruby, scala, smalltalk, sql, tex, vbscript, xml 二、标题用法 使用1-6个#号连接内容，如： # 一级标题 ## 二级标题 ### 三级标题 效果 一级标题二级标题三级标题三、粗体与斜体用法 正常字前后不加*号，1个*为斜体，2个*为粗体，3个*为粗斜体，如： 这是正常的字 *这是斜体的字* **这是加粗的字** ***这是粗斜体的字*** 效果 这是正常的字这是斜体的字这是加粗的字这是粗斜体的字 四、链接1. 常用链接方法用法 文字链接： [百度](http://www.baidu.com) 网址链接： &lt;http://www.baidu.com&gt; 效果 文字链接： 百度网址链接： http://www.baidu.com 2. 高级链接技巧用法 这个链接用 1 作为网址变量 [Google][1]. 这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. 然后在文档的结尾为变量赋值（网址）: [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 效果 这个链接用 1 作为网址变量 Google.这个链接用 yahoo 作为网址变量 Yahoo!. 五、图片1. 用法1跟链接的方法区别在于前面加了个感叹号!，这样是不是觉得好记多了呢？ 用法 ![图片名称](http://图片网址)，如： ![奇犽](http://7xlpfl.com1.z0.glb.clouddn.com/16-10-1/61240869.jpg) 效果 2. 用法2当然，你也可以像网址那样对图片网址使用变量： 这个链接用 1 作为网址变量 [Google][1]. 然后在文档的结尾位变量赋值（网址） [1]: http://www.google.com/logo.png 3. 用法3也可以使用 HTML 的图片语法来自定义图片的宽高大小： &lt;img src=&quot;htt://example.com/sample.png&quot; width=&quot;250&quot; height=&quot;250&quot; alt=&quot;奇犽&quot;&gt; 4. 用法4如果使用七牛进行存储的图片，还可以在URL后面添加参数，控制加载的图片大小： ?imageView2/2/w/100/ ?imageView2/2/w/150/ ?imageView2/2/w/200/ 具体参数可参考七牛图片处理接口文档 六、列表1. 普通无序列表用法 - 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 效果 列表文本前使用 [减号+空格] 列表文本前使用 [加号+空格] 列表文本前使用 [星号+空格] 2. 普通有序列表用法 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 效果 列表前使用 [数字+空格] 我们会自动帮你添加数字 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 3. 列表嵌套用法 1. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格 2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格 4. 列表里代码段： 效果 列出所有元素： 无序列表元素 A 元素 A 的有序子列表 前面加四个空格 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 列表里引用： 前面空一行仍然需要在 &gt; 前面加四个空格 列表里代码段：待补充。 七、引用1. 普通引用用法 &gt; 引用文本前使用 [大于号+空格] &gt; 折行可以不加，新起一行都要加上哦 效果 引用文本前使用 [大于号+空格]折行可以不加，新起一行都要加上哦 2. 引用里嵌套引用用法 &gt; 最外层引用 &gt; &gt; 多一个 &gt; 嵌套一层引用 &gt; &gt; &gt; 可以嵌套很多层 效果 最外层引用 多一个 &gt; 嵌套一层引用 可以嵌套很多层 3. 引用里嵌套列表用法 &gt; - 这是引用里嵌套的一个列表 &gt; - 还可以有子列表 &gt; * 子列表需要从 - 之后延后四个空格开始 效果 这是引用里嵌套的一个列表 还可以有子列表 子列表需要从 - 之后延后四个空格开始 4. 引用里嵌套代码块用法 &gt; 同样的，在前面加四个空格形成代码块 效果 同样的，在前面加四个空格形成代码块 八、换行如果另起一行，只需在当前行结尾加 2 个空格 在当前行的结尾加 2 个空格 这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 九、分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行： 前面的段落 --- 后面的段落 十、符号转义如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠\\进行避免。 用法 \\_不想这里的文本变斜体\\_ \\*\\*不想这里的文本被加粗\\*\\* 效果 _不想这里的文本变斜体_**不想这里的文本被加粗** 十一、表格用法 abc | def | kdka --- | --- | --- ld | dk | dk ld | dk | dk 效果 abc def kdka ld dk dk ld dk dk 十二、复杂表格1. 在Excel中填写表格在 Excel 中正常填写你的表格内容，之后在标题行下插入一行，要居中的填入:-:，要右对齐的填-:，其它全部填上-。 2. 生成表格复制、粘贴表格：选中表格，复制，然后粘贴到 Markdown 编辑器中。 用|替换tab：复制出来的 Excel 默认以tab作为单元格分隔符，而 Markdown 则以|为分隔符。顺理成章，当我们使用 | 对原tab分隔符进行替换后，即可生成 Markdown 化的表格： -|左对齐|居中对齐|右对齐 :-:|-|:-:|-: 1|Left|Center|Right 2|Left|Center|Right 3|Left|Center|Right 效果 - 左对齐 居中对齐 右对齐 1 Left Center Right 2 Left Center Right 3 Left Center Right 3. 在线生成Markdown表格http://www.tablesgenerator.com/markdown_tables 4. 复杂表格生成办法 我们仍然建议使用其他的方式替代复杂的表格，甚至尽量少用表格。 在你本地或者远程的HTML编辑器上生成复杂表格，然后粘贴表格的HTML代码到编辑区即可。","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://sherlockshi.github.io/tags/Markdown/"},{"name":"语法","slug":"语法","permalink":"http://sherlockshi.github.io/tags/语法/"}]},{"title":"RecyclerView学习笔记1_入门","date":"2016-04-19T14:27:01.000Z","path":"2016/04/19/15_Android/1510_View/RecyclerView/RecyclerView学习笔记1_入门/","text":"一、 前言RecyclerView是谷歌V7包下新增的控件,用来替代ListView、GridView的使用. 要点 LayoutManager：布局管理器,目前SDK中提供了三种自带的LayoutManager: 123LinearLayoutManager-----类似ListViewGridLayoutManager-----类似GridViewStaggeredGridLayoutManager-----瀑布流 ItemDecoration：Item间的分割线样式 ItemAnimator：Item增加、删除的动画 点击、长按事件：比较麻烦 二、开发环境 IDE: Android Studio 2.0 Beta 6 SDK: Android 23 三、使用1. 配置 app/build.gradle 1234dependencies &#123; ... compile 'com.android.support:recyclerview-v7:23.1.1'&#125; 2. 主布局文件 activity_main.xml 1234567891011121314151617&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.sh.recyclerviewstudy1.MainActivity\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_book\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/RelativeLayout&gt; 3. 子布局文件 rv_item_book.xml 123456789101112&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"@dimen/activity_horizontal_margin\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_book\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"16sp\"/&gt;&lt;/LinearLayout&gt; 4. ViewHolder文件 BookViewHolder.java 123456789public class BookViewHolder extends RecyclerView.ViewHolder &#123; public TextView tvBook; public BookViewHolder(View view) &#123; super(view); tvBook = (TextView) view.findViewById(R.id.tv_book); &#125;&#125; 5. 适配器 BookRecyclerViewAdapter.java 123456789101112131415161718192021222324252627282930313233public class BookRecyclerViewAdapter extends RecyclerView.Adapter&lt;BookViewHolder&gt; &#123; private LayoutInflater mLayoutInflater; private Context mContext; private String[] mBooks; public BookRecyclerViewAdapter(Context context, String[] mBooks) &#123; this.mBooks = mBooks; this.mContext = context; mLayoutInflater = LayoutInflater.from(context); &#125; @Override public BookViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; // 创建一个View View view = mLayoutInflater.inflate(R.layout.rv_item_book, parent, false); // 创建一个ViewHolder BookViewHolder bookViewHolder = new BookViewHolder(view); return bookViewHolder; &#125; @Override public void onBindViewHolder(BookViewHolder holder, int position) &#123; // 绑定数据到ViewHolder上 holder.tvBook.setText(mBooks[position]); &#125; @Override public int getItemCount() &#123; // item数量 return mBooks.length; &#125;&#125; 6. 主界面 MainActivity.java 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; private RecyclerView rvBook; private String[] mBooks = &#123;\"认知盈余\", \"和喜欢的一切在一起\", \"从0到1\", \"从你的全世界路过\", \"打工旅行\", \"番茄工作法图解\"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); rvBook = (RecyclerView) findViewById(R.id.rv_book); // 1\\. 这里用线性显示,类似于ListView rvBook.setLayoutManager(new LinearLayoutManager(this)); // 2\\. 这里用线性宫格显示,类似于GridView// rvBook.setLayoutManager(new GridLayoutManager(this, 2)); // 3\\. 这里用线性宫格显示,类似于瀑布流// rvBook.setLayoutManager(new StaggeredGridLayoutManager(2, OrientationHelper.VERTICAL)); rvBook.setAdapter(new BookRecyclerViewAdapter(MainActivity.this, mBooks)); &#125;&#125; 四、总结RecyclerView的另一个特点是标准化了 ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。","tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://sherlockshi.github.io/tags/RecyclerView/"},{"name":"入门","slug":"入门","permalink":"http://sherlockshi.github.io/tags/入门/"}]},{"title":"Hexo入门","date":"2016-04-19T14:05:38.000Z","path":"2016/04/19/30_博客/3005_Hexo/Hexo入门/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://sherlockshi.github.io/tags/Hexo/"},{"name":"命令","slug":"命令","permalink":"http://sherlockshi.github.io/tags/命令/"}]}]